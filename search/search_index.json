{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Fetch.ai developer resources. Let's get started. Developing agents Speed up the development of Autonomous Economic Agents using our framework Using the ledger Learn how to make transfers, deploy smart contracts, etc Deploying a node Run your own local node What is Fetch.ai There are billions of devices, processes and pipelines around the world that are desperate for automation and communication. Most blockchains aren't built to handle such a large number of transactions, and none enable their clients to learn from the data generated and exchanged. Fetch.ai is a platform built to bring value to data, by connecting devices and facilitating the creation of new markets based on what they learn from each other. It is the platform where truly autonomous decisions can be made. Some of the technical features that will enable this autonomous world are: Blockchain sharding to increase concurrency and scalability Smart contract language with ML and AI capabilities Framework for rapid development of Autonomous Economic Agents (AEAs) that can be deployed in any device Support for fixed-point arithmetics to guarantee precision and determinism across all operations and transactions Fetch.ai glossary Collective learning: The act by which autonomous agents, with competitive or complementary interests, increase their understanding of the state and behavior of the decentralized ecosystem they are connected to. Ideally, this will allow them to improve their solutions to a problem. Etch: Our native language in which smart contracts can be written, with support for ML and AI. FET: The cryptocurrency that powers the Fetch.ai ecosystem. Its first version is an ERC-20 token in the Ethereum blockchain, but following versions are native to the Fetch.ai ledger. Synergetic contracts: Type of smart contract that allows anyone to register a problem on the ledger, with miners then using their computational power to solve it and earn a reward. What can you do *now* with Fetch.ai All the components of the Fetch.ai stack and the interfaces to interact with them are open source. Take a look at our SDKs (Python Ledger API, JavaScript Ledger API, Agent Framework and Etch language) so you can start building smart contracts, new agents connected to Fetch.ai, or new ways of interacting with the ledger. And if you want to go even further, you can fork and build any components from the Fetch.ai stack! Versions and release notes As with any software and its documentation, things do change and evolve. We at Fetch.ai try to support backwards compatibility as much as possible, but deprecations will occur. Keep an eye our release notes, as these list all major changes. If you want to view older versions of the documentation, you can select them using the drop down at the bottom of the left hand menu. Updates! November 29th, 2019 Documentation updated for Fetch.ai ledger v0.10.x. See summary details here .","title":"Home"},{"location":"playground/","text":"The most basic introduction etch is a high-level, statically-typed programming language designed for creating smart contracts on the Fetch.ai constellation ledger. Unlike similar languages, etch allows developers to code advanced compute-intensive logic for high performance scenarios such as machine learning and AI. Check out the Fetch.ai etch language guide here . But for the quickest start... Hello World function main () for ( i in 0 : 5 ) printLn ( \"Hello World, how are you? (\" + toString ( i ) + \")\" ); endfor endfunction Copy/paste the code into the window on the left. Click run and you will see the results in the right. The main function is where execution starts. The for loop prints out \u201cHello world\u201d along with a number representing the loop index. Flow control and looping As well as for , etch also supports while : function main () var i : Int32 = 0 ; while ( i < 10 ) printLn ( toString ( i )); i ++ ; endwhile endfunction for and while support continue and break which skip an iteration or break out of the loop respectively. Note that we support ++ for increment. We also support operators for += , -- , -= , etc. Also observe that we declare the variable i as an Int32 a 32 bit integer type. etch has many built-in types, and they include: Fixed32 , Fixed64 , Fixed128 , Int32 , Int64 , UInt32 , UInt64 , Bool , String , Array , and more. For flow control, use the if/else/elseif/endif structure: function main () var colourIndex = 15 ; var insertCharacter : String = \" \" ; if ( colourIndex < 2 ) insertCharacter = \" \" ; elseif ( colourIndex < 8 ) insertCharacter = \"'\" ; elseif ( colourIndex < 20 ) insertCharacter = \"*\" ; else insertCharacter = \"@\" ; endif printLn ( insertCharacter ); endfunction Check out the guide for further details, including information on complex data structures and smart contract creation.","title":"Playground"},{"location":"playground/#the-most-basic-introduction","text":"etch is a high-level, statically-typed programming language designed for creating smart contracts on the Fetch.ai constellation ledger. Unlike similar languages, etch allows developers to code advanced compute-intensive logic for high performance scenarios such as machine learning and AI. Check out the Fetch.ai etch language guide here . But for the quickest start...","title":"The most basic introduction"},{"location":"playground/#hello-world","text":"function main () for ( i in 0 : 5 ) printLn ( \"Hello World, how are you? (\" + toString ( i ) + \")\" ); endfor endfunction Copy/paste the code into the window on the left. Click run and you will see the results in the right. The main function is where execution starts. The for loop prints out \u201cHello world\u201d along with a number representing the loop index.","title":"Hello World"},{"location":"playground/#flow-control-and-looping","text":"As well as for , etch also supports while : function main () var i : Int32 = 0 ; while ( i < 10 ) printLn ( toString ( i )); i ++ ; endwhile endfunction for and while support continue and break which skip an iteration or break out of the loop respectively. Note that we support ++ for increment. We also support operators for += , -- , -= , etc. Also observe that we declare the variable i as an Int32 a 32 bit integer type. etch has many built-in types, and they include: Fixed32 , Fixed64 , Fixed128 , Int32 , Int64 , UInt32 , UInt64 , Bool , String , Array , and more. For flow control, use the if/else/elseif/endif structure: function main () var colourIndex = 15 ; var insertCharacter : String = \" \" ; if ( colourIndex < 2 ) insertCharacter = \" \" ; elseif ( colourIndex < 8 ) insertCharacter = \"'\" ; elseif ( colourIndex < 20 ) insertCharacter = \"*\" ; else insertCharacter = \"@\" ; endif printLn ( insertCharacter ); endfunction Check out the guide for further details, including information on complex data structures and smart contract creation.","title":"Flow control and looping"},{"location":"summary/","text":"November 29th, 2019 Documentation has been updated for Fetch.ai ledger v0.10.x New style, and new section on Machine Learning on Fetch.ai. We will be continuously updating these docs. Please see github.com/fetchai/docs for latest updates. There have been a number of other minor corrections and updates.","title":"Summary"},{"location":"aea/","text":"The AEA framework provides the tools for creating Autonomous Economic Agents (AEA). What are AEAs? We define an autonomous economic agent or AEA as: an intelligent agent acting on an owner's behalf, with limited or no interference, and whose goal is to generate economic value to its owner. In short, \"software that works for you\". AEAs act independently of constant user input and autonomously execute actions to achieve their goal. Their goal is to create economic value for you, their owner. AEAs have a wide range of application areas and we provide demo guides for some examples. AEAs are not: just any agents: AEAs have an express purpose to generate economic value. APIs or sensors which do not have agency. smart contracts which do not display any proactiveness and are purely reactive to external requests (=contract calls). artificial general intelligence (AGI): AEAs can have a very narrow goal directed focus involving some economic gain and implemented via simple conditional logic. What is the AEA Framework? The AEA framework is a Python-based development suite which equips you with an efficient and accessible set of tools for building AEAs. The framework is modular, extensible, and composable. This framework attempts to make agent development as straightforward an experience as possible, similar to web development using popular web frameworks. To get started developing your own AEA, check out the quick start . To learn more about some of the distinctive characteristics of agent-oriented development, check out the guide on agent-oriented development . AEAs achieve their goals with the help of the OEF - a search and discovery platform for agents by Fetch.ai - and using Fetch.ai's blockchain as a financial settlement layer. Third-party blockchains, such as Ethereum, may also allow AEA integration. Note This developer documentation is a work in progress. If you spot any errors please open an issue here .","title":"Introduction"},{"location":"aea/#what-are-aeas","text":"We define an autonomous economic agent or AEA as: an intelligent agent acting on an owner's behalf, with limited or no interference, and whose goal is to generate economic value to its owner. In short, \"software that works for you\". AEAs act independently of constant user input and autonomously execute actions to achieve their goal. Their goal is to create economic value for you, their owner. AEAs have a wide range of application areas and we provide demo guides for some examples. AEAs are not: just any agents: AEAs have an express purpose to generate economic value. APIs or sensors which do not have agency. smart contracts which do not display any proactiveness and are purely reactive to external requests (=contract calls). artificial general intelligence (AGI): AEAs can have a very narrow goal directed focus involving some economic gain and implemented via simple conditional logic.","title":"What are AEAs?"},{"location":"aea/#what-is-the-aea-framework","text":"The AEA framework is a Python-based development suite which equips you with an efficient and accessible set of tools for building AEAs. The framework is modular, extensible, and composable. This framework attempts to make agent development as straightforward an experience as possible, similar to web development using popular web frameworks. To get started developing your own AEA, check out the quick start . To learn more about some of the distinctive characteristics of agent-oriented development, check out the guide on agent-oriented development . AEAs achieve their goals with the help of the OEF - a search and discovery platform for agents by Fetch.ai - and using Fetch.ai's blockchain as a financial settlement layer. Third-party blockchains, such as Ethereum, may also allow AEA integration. Note This developer documentation is a work in progress. If you spot any errors please open an issue here .","title":"What is the AEA Framework?"},{"location":"aea/aea-vs-mvc/","text":"The AEA framework borrows several concepts from popular web frameworks like Django and Ruby on Rails. Both aforementioned web frameworks use the MVC (model-view-controller) architecture. Models: contain business logic and data representations View: contain the html templates Controller: deals with the request-response handling The AEA framework is based on asynchronous messaging. Hence, there is not a direct 1-1 relationship between MVC based architectures and the AEA framework. Nevertheless, there are some parallels which can help a developer familiar with MVC make progress in the AEA framework in particular, the development of Skills , quickly: Handler : receive the messages for the protocol they are registered against and are supposed to handle these messages. They are the reactive parts of a skill and can be thought of as similar to the Controller in MVC. Behaviour : a behaviour encapsulates pro-active components of the agent. Since web apps do not have any goals or intentions they do not pro-actively pursue an objective. Therefore, there is no equivalent concept in MVC. Task : are meant to deal with long running executions and can be thought of as the equivalent of background tasks in traditional web apps. Model : implement business logic and data representation, as such they are similar to the Model in MVC. The View concept is probably best compared to the Message of a given Protocol in the AEA framework. Whilst views, represent information to the client, messages represent information sent to other agents.","title":"AEA and web frameworks"},{"location":"aea/agent-oriented-development/","text":"Agent-oriented development In this section, we highlight some of the most fundamental characteristics of the agent-oriented approach to solution development, which might be different from some of the existing paradigms and methodologies you may be used to. We hope that with this, we can guide you towards having the right mindset when you are designing your own agent-based solutions to real world problems. Decentralisation Multi-Agent Systems ( MAS ) are inherently decentralised. The vision is, an environment in which every agent is able to directly connect with everyone else and interact with them without having to rely on third-parties to facilitate this. This is in direct contrast to centralised systems in which a single entity is the central point of authority, through which all interactions happen. For example systems based on the client-server architecture, in which clients interact with one another, regarding a specific service (e.g. communication, trade), only through the server. Note, this is not to say that facilitators and middlemen have no place in a multi-agent system; rather it is the 'commanding reliance on middlemen' that MAS disagrees with. Division of responsibilities: In a decentralised system, every agent is equally privileged, and (in principle) should be able to interact with any other agent. The idea is very much aligned with the peer-to-peer paradigm, in which it is the voluntary participation and contribution of peers that creates the infrastructure. As such, in a decentralised system, there is no central 'enforcer'. This means all the work that would typically fall under the responsibilities of a central entity must be performed by individual parties in a decentralised system. Blockchain-based cryptocurrencies are a good example of this. People who are getting into cryptocurrencies are often reminded that, due to the lack of a central trusted entity (e.g. a bank), most security precautions related to the handling of digital assets and the execution of transactions fall on individuals themselves. Decentralisation vs distribution: It is important to emphasise that by decentralisation we do not mean distribution; although multi-agent systems typically do tend to also be distributed. A distributed system is one whose components are physically located in different places and connected over a network. A fully centralised system, owned and operated by a single entity, may in fact be highly distributed. Google's infrastructure is an example of this, where all of the components are distributed across the globe, yet designed to work together highly efficiently and function in unison. Decentralisation on the other hand refers to a system whose components may be owned, operated, and managed by different stakeholders, each with their own personal objectives, interests, and preferences, which may not necessarily be aligned with one another or that of the system itself. Therefore, distribution refers to the physical placement of a system's components, whereas decentralisation refers to a) the diversity of ownership and control over a system's constituents, and b) the absence of a central point of authority between them. Example: To better illustrate the distinction between centralised and decentralised systems, consider another example: search and discoverability in a commerce environment. In a centralised system (say amazon.com), there is a single search service -- provided, owned and run by the commerce company itself -- which takes care of all search related functionality for every product within their domain. So to be discoverable in this system, all sellers must register their products with this particular service. However in a decentralised system, there may not necessarily be a single search service provider. There may be multiple such services, run by different, perhaps competing entities. Each seller has the freedom to register with (i.e. make themselves known to) one or a handful of services. On the buyers side, the more services they contact and query, the higher their chances of finding the product they are looking for. Conflicting Environment As discussed above, the notion of decentralisation extends as far as ownership and control. Therefore, the different components that make up a decentralised system may each be owned by a different entity, designed according to very different principles and standards, with heterogeneous software and hardware, and each with internal objectives that may be fundamentally inconsistent, worst yet contradictory, with those of others. As such, a distinctive characteristic of a multi-agent environment, is that it is inhabited by more than one agent (as the name suggests), where each agent may be owned potentially by a different stakeholder (individual, company, government). Since by design, each agent represents and looks after the interests of its owner(s), and because different stakeholders may have unaligned, conflicting, or contradictory interests, it is very common to have multi-agent systems in which the agents' objectives, values and preferences are unaligned, conflicting, or contradictory. In practice: There are practical implications that follow from the above when it comes to designing an agent. For example, it is not rational for an agent to automatically rely on the information it receives from other agents. The information could be: Incomplete: what is unrevealed may have been deemed private for strategic reasons. Uncertain: it may be the result of an inaccurate prediction. Incorrect: it could be an outright lie, due to the adversarial nature of the environment. Therefore one can argue, that there is a degree of uncertainty attached to almost all information an agent receives or infers in a multi-agent system. It wouldn't then be illogical for an agent to take a sceptical approach: treating everything as uncertain, unless proved otherwise. Asynchronisation The conflicting nature of multi-agent systems, consisting of self-interested autonomous agents, points to asynchronisation as the preferred method of designing and managing processes and interactions. Synchronisation vs asynchronisation: In general, asynchronisation refers to the decoupling of events that do interact with one another but do not occur at predetermined intervals, not necessarily relying on each other's existence to function. This is in contrast with synchronous systems in which processes are aware of one another, where one's execution depends in some way on the other. Asynchronisation in MAS: In the context of multi-agent systems, the decentralised and potentially conflicting nature of the environment creates uncertainty over the behaviour of the whole system, in particular of other agents. For example, suppose an agent i sends a message requesting some resources from an agent j . Since MAS often tends to be distributed, there is the usual uncertainties with communication over a network: j may never receive i 's request, or may receive it after a long delay. Furthermore, j could receive the request in time and respond immediately, but as mentioned in the last section, its answer might be incomplete (gives only some of the requested resources), uncertain (promises to give the resources, but cannot be fully trusted), or incorrect (sends a wrong resource). In addition, since agents are self-interested, j may decide to reply much later, to the point that the resource is no longer useful to agent i , or j may simply decide not to respond at all. There might be a myriad of reasons why it may choose to do that; it could be because j assigns a low priority to answering i over its other tasks. But that's beside the point. The take away is that agents' autonomy strongly influences what can be expected of them, and of an environment inhabited by them. As such, developing for a system whose constituents are autonomous, e.g. agents in a multi-agent system, is fundamentally different from one whose constituents aren't, e.g. objects in an object-oriented system. Objects vs agents: In object-oriented systems, objects are entities that encapsulate state and perform actions, i.e. call methods, on this state. In object-oriented languages, like C++ and Java, it is common practice to declare methods as public, so they can be invoked by other objects in the system whenever they wish. This implies that an object does not control its own behaviour. If an object\u2019s method is public, the object has no control over whether or not that method is executed. We cannot take for granted that an agent j will execute an action (the equivalent of a method in object-oriented systems) just because another agent i wants it to; this action may not be in the best interests of agent j . So we do not think of agents as invoking methods on one another, rather as requesting actions. If i requests j to perform an action, then j may or may not perform the action. It may choose to do it later or do it in exchange for something. The locus of control is therefore different in object-oriented and agent-oriented systems. In the former, the decision lies with the object invoking the method, whereas in the latter, the decision lies with the agent receiving the request. This distinction could be summarised by the following slogan (from An Introduction to MultiAgent Systems by Michael Wooldridge ): objects do it for free; agents do it because they want to. All of this makes asynchronisation the preferred method for designing agent processes and interactions. An agent's interactions should be independent of each other, as much as possible, and of the agent's decision making processes and actions. This means the success or failure of, or delay in any single interaction does not block the agent's other tasks. Complex, Incomplete, Inconsistent and Uncertain The forth characteristic(s) relate to the environment in which agents are expected to operate in, and these have been mentioned a number of times in the previous sections. The environment agents are suited for typically tend to be complex, to the point that it is usually impossible for any single agent to perceive the whole of the environment on its own. This means that at any point in time, any agent has a limited knowledge about the state of the environment. In other words, the agents;' information tend to be incomplete due to the complexity and sophistication of the world in which they reside. Consider an agent which represents a driverless vehicle. The complexity of the problem of driving on the road makes it impossible for a single vehicle to have an accurate and up-to-date knowledge of the overall state of the world . This means that an agent's model of the world is at best uncertain. For instance, the vehicle, through its sensor may detect green light at a junction, and by being aware of what it means, it may infer that it is safe to cross a junction. However, that simply may not be true as another car in the opposite direction may still cross the junction violating their red light. Therefore, there is uncertainty associated with the knowledge \"it is safe to cross the road because the light is green\", and the agent must recognise that. Furthermore, the often conflicting nature of the environment means information obtained from multiple sources (agents) may be inconsistent. Again, this must be taken into consideration when designing an agent which is expected to operate successfully in a potentially conflicting environment.","title":"Agent-oriented development"},{"location":"aea/agent-oriented-development/#agent-oriented-development","text":"In this section, we highlight some of the most fundamental characteristics of the agent-oriented approach to solution development, which might be different from some of the existing paradigms and methodologies you may be used to. We hope that with this, we can guide you towards having the right mindset when you are designing your own agent-based solutions to real world problems.","title":"Agent-oriented development"},{"location":"aea/agent-oriented-development/#decentralisation","text":"Multi-Agent Systems ( MAS ) are inherently decentralised. The vision is, an environment in which every agent is able to directly connect with everyone else and interact with them without having to rely on third-parties to facilitate this. This is in direct contrast to centralised systems in which a single entity is the central point of authority, through which all interactions happen. For example systems based on the client-server architecture, in which clients interact with one another, regarding a specific service (e.g. communication, trade), only through the server. Note, this is not to say that facilitators and middlemen have no place in a multi-agent system; rather it is the 'commanding reliance on middlemen' that MAS disagrees with. Division of responsibilities: In a decentralised system, every agent is equally privileged, and (in principle) should be able to interact with any other agent. The idea is very much aligned with the peer-to-peer paradigm, in which it is the voluntary participation and contribution of peers that creates the infrastructure. As such, in a decentralised system, there is no central 'enforcer'. This means all the work that would typically fall under the responsibilities of a central entity must be performed by individual parties in a decentralised system. Blockchain-based cryptocurrencies are a good example of this. People who are getting into cryptocurrencies are often reminded that, due to the lack of a central trusted entity (e.g. a bank), most security precautions related to the handling of digital assets and the execution of transactions fall on individuals themselves. Decentralisation vs distribution: It is important to emphasise that by decentralisation we do not mean distribution; although multi-agent systems typically do tend to also be distributed. A distributed system is one whose components are physically located in different places and connected over a network. A fully centralised system, owned and operated by a single entity, may in fact be highly distributed. Google's infrastructure is an example of this, where all of the components are distributed across the globe, yet designed to work together highly efficiently and function in unison. Decentralisation on the other hand refers to a system whose components may be owned, operated, and managed by different stakeholders, each with their own personal objectives, interests, and preferences, which may not necessarily be aligned with one another or that of the system itself. Therefore, distribution refers to the physical placement of a system's components, whereas decentralisation refers to a) the diversity of ownership and control over a system's constituents, and b) the absence of a central point of authority between them. Example: To better illustrate the distinction between centralised and decentralised systems, consider another example: search and discoverability in a commerce environment. In a centralised system (say amazon.com), there is a single search service -- provided, owned and run by the commerce company itself -- which takes care of all search related functionality for every product within their domain. So to be discoverable in this system, all sellers must register their products with this particular service. However in a decentralised system, there may not necessarily be a single search service provider. There may be multiple such services, run by different, perhaps competing entities. Each seller has the freedom to register with (i.e. make themselves known to) one or a handful of services. On the buyers side, the more services they contact and query, the higher their chances of finding the product they are looking for.","title":"Decentralisation"},{"location":"aea/agent-oriented-development/#conflicting-environment","text":"As discussed above, the notion of decentralisation extends as far as ownership and control. Therefore, the different components that make up a decentralised system may each be owned by a different entity, designed according to very different principles and standards, with heterogeneous software and hardware, and each with internal objectives that may be fundamentally inconsistent, worst yet contradictory, with those of others. As such, a distinctive characteristic of a multi-agent environment, is that it is inhabited by more than one agent (as the name suggests), where each agent may be owned potentially by a different stakeholder (individual, company, government). Since by design, each agent represents and looks after the interests of its owner(s), and because different stakeholders may have unaligned, conflicting, or contradictory interests, it is very common to have multi-agent systems in which the agents' objectives, values and preferences are unaligned, conflicting, or contradictory. In practice: There are practical implications that follow from the above when it comes to designing an agent. For example, it is not rational for an agent to automatically rely on the information it receives from other agents. The information could be: Incomplete: what is unrevealed may have been deemed private for strategic reasons. Uncertain: it may be the result of an inaccurate prediction. Incorrect: it could be an outright lie, due to the adversarial nature of the environment. Therefore one can argue, that there is a degree of uncertainty attached to almost all information an agent receives or infers in a multi-agent system. It wouldn't then be illogical for an agent to take a sceptical approach: treating everything as uncertain, unless proved otherwise.","title":"Conflicting Environment"},{"location":"aea/agent-oriented-development/#asynchronisation","text":"The conflicting nature of multi-agent systems, consisting of self-interested autonomous agents, points to asynchronisation as the preferred method of designing and managing processes and interactions. Synchronisation vs asynchronisation: In general, asynchronisation refers to the decoupling of events that do interact with one another but do not occur at predetermined intervals, not necessarily relying on each other's existence to function. This is in contrast with synchronous systems in which processes are aware of one another, where one's execution depends in some way on the other. Asynchronisation in MAS: In the context of multi-agent systems, the decentralised and potentially conflicting nature of the environment creates uncertainty over the behaviour of the whole system, in particular of other agents. For example, suppose an agent i sends a message requesting some resources from an agent j . Since MAS often tends to be distributed, there is the usual uncertainties with communication over a network: j may never receive i 's request, or may receive it after a long delay. Furthermore, j could receive the request in time and respond immediately, but as mentioned in the last section, its answer might be incomplete (gives only some of the requested resources), uncertain (promises to give the resources, but cannot be fully trusted), or incorrect (sends a wrong resource). In addition, since agents are self-interested, j may decide to reply much later, to the point that the resource is no longer useful to agent i , or j may simply decide not to respond at all. There might be a myriad of reasons why it may choose to do that; it could be because j assigns a low priority to answering i over its other tasks. But that's beside the point. The take away is that agents' autonomy strongly influences what can be expected of them, and of an environment inhabited by them. As such, developing for a system whose constituents are autonomous, e.g. agents in a multi-agent system, is fundamentally different from one whose constituents aren't, e.g. objects in an object-oriented system. Objects vs agents: In object-oriented systems, objects are entities that encapsulate state and perform actions, i.e. call methods, on this state. In object-oriented languages, like C++ and Java, it is common practice to declare methods as public, so they can be invoked by other objects in the system whenever they wish. This implies that an object does not control its own behaviour. If an object\u2019s method is public, the object has no control over whether or not that method is executed. We cannot take for granted that an agent j will execute an action (the equivalent of a method in object-oriented systems) just because another agent i wants it to; this action may not be in the best interests of agent j . So we do not think of agents as invoking methods on one another, rather as requesting actions. If i requests j to perform an action, then j may or may not perform the action. It may choose to do it later or do it in exchange for something. The locus of control is therefore different in object-oriented and agent-oriented systems. In the former, the decision lies with the object invoking the method, whereas in the latter, the decision lies with the agent receiving the request. This distinction could be summarised by the following slogan (from An Introduction to MultiAgent Systems by Michael Wooldridge ): objects do it for free; agents do it because they want to. All of this makes asynchronisation the preferred method for designing agent processes and interactions. An agent's interactions should be independent of each other, as much as possible, and of the agent's decision making processes and actions. This means the success or failure of, or delay in any single interaction does not block the agent's other tasks.","title":"Asynchronisation"},{"location":"aea/agent-oriented-development/#complex-incomplete-inconsistent-and-uncertain","text":"The forth characteristic(s) relate to the environment in which agents are expected to operate in, and these have been mentioned a number of times in the previous sections. The environment agents are suited for typically tend to be complex, to the point that it is usually impossible for any single agent to perceive the whole of the environment on its own. This means that at any point in time, any agent has a limited knowledge about the state of the environment. In other words, the agents;' information tend to be incomplete due to the complexity and sophistication of the world in which they reside. Consider an agent which represents a driverless vehicle. The complexity of the problem of driving on the road makes it impossible for a single vehicle to have an accurate and up-to-date knowledge of the overall state of the world . This means that an agent's model of the world is at best uncertain. For instance, the vehicle, through its sensor may detect green light at a junction, and by being aware of what it means, it may infer that it is safe to cross a junction. However, that simply may not be true as another car in the opposite direction may still cross the junction violating their red light. Therefore, there is uncertainty associated with the knowledge \"it is safe to cross the road because the light is green\", and the agent must recognise that. Furthermore, the often conflicting nature of the environment means information obtained from multiple sources (agents) may be inconsistent. Again, this must be taken into consideration when designing an agent which is expected to operate successfully in a potentially conflicting environment.","title":"Complex, Incomplete, Inconsistent and Uncertain"},{"location":"aea/agent-vs-aea/","text":"AEAs are more than just agents. In this guide we show some of the differences in terms of code. The Build an AEA programmatically guide shows how to programmatically build an AEA. We can build an agent of the Agent class programmatically as well. First, import the python and application specific libraries. import os import time from threading import Thread from typing import List , Optional from aea.agent import Agent from aea.connections.base import Connection from aea.connections.stub.connection import StubConnection from aea.identity.base import Identity from aea.mail.base import Envelope Unlike an AEA , an Agent does not require a Wallet , LedgerApis or Resources module. However, we need to implement 5 abstract methods: - setup() - act() - react() - update() - teardown() When we run an agent, start() calls setup() and then the main agent loop. The main agent loop calls act() , react() and update() on each tick. When the agent is stopped via stop() then teardown() is called. Such a lightweight agent can be used to implement simple logic. Code an Agent We define our Agent which simply receives envelopes, prints the sender address and protocol_id and returns it unopened. INPUT_FILE = \"input.txt\" OUTPUT_FILE = \"output.txt\" class MyAgent ( Agent ): def __init__ ( self , identity : Identity , connections : List [ Connection ]): super () . __init__ ( identity , connections ) def setup ( self ): pass def act ( self ): print ( \"Act called for tick {} \" . format ( self . tick )) def react ( self ): print ( \"React called for tick {} \" . format ( self . tick )) while not self . inbox . empty (): envelope = self . inbox . get_nowait () # type: Optional[Envelope] if envelope is not None : sender = envelope . sender receiver = envelope . to envelope . to = sender envelope . sender = receiver print ( \"Received envelope from {} with protocol_id= {} \" . format ( sender , envelope . protocol_id ) ) self . outbox . put ( envelope ) def update ( self ): print ( \"Update called for tick {} \" . format ( self . tick )) def teardown ( self ): pass Instantiate an Agent # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # Create an addresses identity: identity = Identity ( name = \"my_agent\" , address = \"some_address\" ) # Set up the stub connection stub_connection = StubConnection ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE ) # Create our Agent my_agent = MyAgent ( identity , [ stub_connection ]) Start the agent We run the agent from a different thread so that we can still use the main thread to pass it messages. # Set the agent running in a different thread try : t = Thread ( target = my_agent . start ) t . start () # Wait for everything to start up time . sleep ( 3 ) Send and receive an envelope We use the input and output text files to send an envelope to our agent and receive a response # Create a message inside an envelope and get the stub connection to pass it into the agent message_text = ( \"my_agent,other_agent,fetchai/default:0.1.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : f . write ( message_text ) # Wait for the envelope to get processed time . sleep ( 2 ) # Read the output envelope generated by the agent with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"output message: \" + f . readline ()) Shutdown Finally stop our agent and wait for it to finish finally : # Shut down the agent my_agent . stop () t . join () Your turn Now it is your turn to develop a simple agent with the Agent class. Entire code listing If you just want to copy and paste the entire script in you can find it here: Click here to see full listing import os import time from threading import Thread from typing import List , Optional from aea.agent import Agent from aea.connections.base import Connection from aea.connections.stub.connection import StubConnection from aea.identity.base import Identity from aea.mail.base import Envelope INPUT_FILE = \"input.txt\" OUTPUT_FILE = \"output.txt\" class MyAgent ( Agent ): def __init__ ( self , identity : Identity , connections : List [ Connection ]): super () . __init__ ( identity , connections ) def setup ( self ): pass def act ( self ): print ( \"Act called for tick {} \" . format ( self . tick )) def react ( self ): print ( \"React called for tick {} \" . format ( self . tick )) while not self . inbox . empty (): envelope = self . inbox . get_nowait () # type: Optional[Envelope] if envelope is not None : sender = envelope . sender receiver = envelope . to envelope . to = sender envelope . sender = receiver print ( \"Received envelope from {} with protocol_id= {} \" . format ( sender , envelope . protocol_id ) ) self . outbox . put ( envelope ) def update ( self ): print ( \"Update called for tick {} \" . format ( self . tick )) def teardown ( self ): pass def run (): # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # Create an addresses identity: identity = Identity ( name = \"my_agent\" , address = \"some_address\" ) # Set up the stub connection stub_connection = StubConnection ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE ) # Create our Agent my_agent = MyAgent ( identity , [ stub_connection ]) # Set the agent running in a different thread try : t = Thread ( target = my_agent . start ) t . start () # Wait for everything to start up time . sleep ( 3 ) # Create a message inside an envelope and get the stub connection to pass it into the agent message_text = ( \"my_agent,other_agent,fetchai/default:0.1.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : f . write ( message_text ) # Wait for the envelope to get processed time . sleep ( 2 ) # Read the output envelope generated by the agent with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"output message: \" + f . readline ()) finally : # Shut down the agent my_agent . stop () t . join () if __name__ == \"__main__\" : run ()","title":"AEAs vs Agents"},{"location":"aea/agent-vs-aea/#code-an-agent","text":"We define our Agent which simply receives envelopes, prints the sender address and protocol_id and returns it unopened. INPUT_FILE = \"input.txt\" OUTPUT_FILE = \"output.txt\" class MyAgent ( Agent ): def __init__ ( self , identity : Identity , connections : List [ Connection ]): super () . __init__ ( identity , connections ) def setup ( self ): pass def act ( self ): print ( \"Act called for tick {} \" . format ( self . tick )) def react ( self ): print ( \"React called for tick {} \" . format ( self . tick )) while not self . inbox . empty (): envelope = self . inbox . get_nowait () # type: Optional[Envelope] if envelope is not None : sender = envelope . sender receiver = envelope . to envelope . to = sender envelope . sender = receiver print ( \"Received envelope from {} with protocol_id= {} \" . format ( sender , envelope . protocol_id ) ) self . outbox . put ( envelope ) def update ( self ): print ( \"Update called for tick {} \" . format ( self . tick )) def teardown ( self ): pass","title":"Code an Agent"},{"location":"aea/agent-vs-aea/#instantiate-an-agent","text":"# Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # Create an addresses identity: identity = Identity ( name = \"my_agent\" , address = \"some_address\" ) # Set up the stub connection stub_connection = StubConnection ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE ) # Create our Agent my_agent = MyAgent ( identity , [ stub_connection ])","title":"Instantiate an Agent"},{"location":"aea/agent-vs-aea/#start-the-agent","text":"We run the agent from a different thread so that we can still use the main thread to pass it messages. # Set the agent running in a different thread try : t = Thread ( target = my_agent . start ) t . start () # Wait for everything to start up time . sleep ( 3 )","title":"Start the agent"},{"location":"aea/agent-vs-aea/#send-and-receive-an-envelope","text":"We use the input and output text files to send an envelope to our agent and receive a response # Create a message inside an envelope and get the stub connection to pass it into the agent message_text = ( \"my_agent,other_agent,fetchai/default:0.1.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : f . write ( message_text ) # Wait for the envelope to get processed time . sleep ( 2 ) # Read the output envelope generated by the agent with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"output message: \" + f . readline ())","title":"Send and receive an envelope"},{"location":"aea/agent-vs-aea/#shutdown","text":"Finally stop our agent and wait for it to finish finally : # Shut down the agent my_agent . stop () t . join ()","title":"Shutdown"},{"location":"aea/agent-vs-aea/#your-turn","text":"Now it is your turn to develop a simple agent with the Agent class.","title":"Your turn"},{"location":"aea/agent-vs-aea/#entire-code-listing","text":"If you just want to copy and paste the entire script in you can find it here: Click here to see full listing import os import time from threading import Thread from typing import List , Optional from aea.agent import Agent from aea.connections.base import Connection from aea.connections.stub.connection import StubConnection from aea.identity.base import Identity from aea.mail.base import Envelope INPUT_FILE = \"input.txt\" OUTPUT_FILE = \"output.txt\" class MyAgent ( Agent ): def __init__ ( self , identity : Identity , connections : List [ Connection ]): super () . __init__ ( identity , connections ) def setup ( self ): pass def act ( self ): print ( \"Act called for tick {} \" . format ( self . tick )) def react ( self ): print ( \"React called for tick {} \" . format ( self . tick )) while not self . inbox . empty (): envelope = self . inbox . get_nowait () # type: Optional[Envelope] if envelope is not None : sender = envelope . sender receiver = envelope . to envelope . to = sender envelope . sender = receiver print ( \"Received envelope from {} with protocol_id= {} \" . format ( sender , envelope . protocol_id ) ) self . outbox . put ( envelope ) def update ( self ): print ( \"Update called for tick {} \" . format ( self . tick )) def teardown ( self ): pass def run (): # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # Create an addresses identity: identity = Identity ( name = \"my_agent\" , address = \"some_address\" ) # Set up the stub connection stub_connection = StubConnection ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE ) # Create our Agent my_agent = MyAgent ( identity , [ stub_connection ]) # Set the agent running in a different thread try : t = Thread ( target = my_agent . start ) t . start () # Wait for everything to start up time . sleep ( 3 ) # Create a message inside an envelope and get the stub connection to pass it into the agent message_text = ( \"my_agent,other_agent,fetchai/default:0.1.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : f . write ( message_text ) # Wait for the envelope to get processed time . sleep ( 2 ) # Read the output envelope generated by the agent with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"output message: \" + f . readline ()) finally : # Shut down the agent my_agent . stop () t . join () if __name__ == \"__main__\" : run ()","title":"Entire code listing"},{"location":"aea/app-areas/","text":"An AEA is an intelligent agent whose goal is generating economic value for its owner. It can represent machines, humans, or data. There are five general application areas for AEAs: Inhabitants : agents paired with real world hardware devices such as drones, laptops, heat sensors, etc. An example can be found here . Interfaces : facilitation agents which provide the necessary API interfaces for interaction between old (Web 2.0) and new (Web 3.0) economic models. Pure software : software agents living in the digital space that interact with inhabitant and interface agents and others. Digital data sales agents : pure software agents that attach to data sources and sell it via the open economic framework. An example can be found here . Representative : an agent which represents an individual's activities on the Fetch.ai network. An example can be found here . Multi-agent system versus agent-based modelling The Fetch.ai multi agent system is a real world multi-agent technological system and, although there is some overlap, it is not the same as agent based modelling where the goal is scientific behavioural observation rather than practical economic gain. Moreover, there is no restriction to multi . Single-agent applications are also possible.","title":"Application areas"},{"location":"aea/app-areas/#multi-agent-system-versus-agent-based-modelling","text":"The Fetch.ai multi agent system is a real world multi-agent technological system and, although there is some overlap, it is not the same as agent based modelling where the goal is scientific behavioural observation rather than practical economic gain. Moreover, there is no restriction to multi . Single-agent applications are also possible.","title":"Multi-agent system versus agent-based modelling"},{"location":"aea/aries-cloud-agent/","text":"Demonstrating the interaction between an AEA and an instance of Aries Cloud Agent (ACA). Discussion This demo illustrates how an AEA may connect to an Aries Cloud Agent (ACA). Hyperledger Aries Cloud Agent is a foundation for building self-sovereign identity/decentralized identity services using verifiable credentials. You can read more about Hyperledger here and the Aries project here . In this demo, you will learn how an AEA could connect with an ACA, to send it administrative commands (e.g. issue verifiable credential to another AEA) and receive DID related notifications (e.g. receive a request for a credential proof from another AEA). Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. ACA Install ACA Install Aries cloud-agents (run pip install aries-cloudagent or see here ) if you do not have it on your machine. Run the demo test Run the following test file using PyTest: PyTest tests/test_examples/test_http_client_connection_to_aries_cloud_agent.py You should see that the two tests pass. Demo code Take a look at the test file you ran above tests/test_examples/test_http_client_connection_to_aries_cloud_agent.py . The main class is TestAEAToACA . The setup_class method initialises the scenario. @pytest . mark . asyncio class TestAEAToACA : \"\"\"End-to-end test for an AEA connecting to an ACA via the http client connection.\"\"\" @classmethod def setup_class ( cls ): \"\"\"Initialise the class.\"\"\" cls . aca_admin_address = \"127.0.0.1\" cls . aca_admin_port = 8020 ... The address and port fields cls.aca_admin_address and cls.aca_admin_port specify where the ACA should listen to receive administrative commands from the AEA. The following runs an ACA: cls . process = subprocess . Popen ( # nosec [ \"aca-py\" , \"start\" , \"--admin\" , cls . aca_admin_address , str ( cls . aca_admin_port ), \"--admin-insecure-mode\" , \"--inbound-transport\" , \"http\" , \"0.0.0.0\" , \"8000\" , \"--outbound-transport\" , \"http\" , ] ) Now take a look at the following method. This is where the demo resides. It first creates an AEA programmatically. @pytest . mark . asyncio async def test_end_to_end_aea_aca ( self ): # AEA components ledger_apis = LedgerApis ({}, FETCHAI ) wallet = Wallet ({ FETCHAI : FETCHAI_PRIVATE_KEY_FILE }) identity = Identity ( name = \"my_aea_1\" , address = wallet . addresses . get ( FETCHAI ), default_address_key = FETCHAI , ) http_client_connection = HTTPClientConnection ( agent_address = self . aea_address , provider_address = self . aca_admin_address , provider_port = self . aca_admin_port , ) resources = Resources () # create AEA aea = AEA ( identity , [ http_client_connection ], wallet , ledger_apis , resources ) ... It then adds the HTTP protocol to the AEA. THe HTTP protocol defines the format of HTTP interactions (e.g. HTTP Request and Response). # Add http protocol to AEA resources http_protocol_configuration = ProtocolConfig . from_json ( yaml . safe_load ( open ( os . path . join ( self . cwd , \"packages\" , \"fetchai\" , \"protocols\" , \"http\" , \"protocol.yaml\" , ) ) ) ) http_protocol = Protocol ( HttpMessage . protocol_id , HttpSerializer (), http_protocol_configuration , ) resources . protocol_registry . register ( HttpMessage . protocol_id , http_protocol ) Then, the request message and envelope is created: # Request message & envelope request_http_message = HttpMessage ( dialogue_reference = ( \"\" , \"\" ), target = 0 , message_id = 1 , performative = HttpMessage . Performative . REQUEST , method = \"GET\" , url = \"http:// {} : {} /status\" . format ( self . aca_admin_address , self . aca_admin_port ), headers = \"\" , version = \"\" , bodyy = b \"\" , ) request_envelope = Envelope ( to = \"ACA\" , sender = \"AEA\" , protocol_id = HTTP_PROTOCOL_PUBLIC_ID , message = HttpSerializer () . encode ( request_http_message ), ) Note that the performative is set to HttpMessage.Performative.REQUEST , the method GET corresponds with HTTP GET method, and url is where the request is sent. This is the location the ACA is listening for administrative commands. In the following part, the AEA is started in another thread t_aea = Thread(target=aea.start) , the HTTP request message created above is placed in the agent's outbox aea.outbox.put(request_envelope) to be sent to the ACA, and the received response is checked for success (e.g. assert aea_handler.handled_message.status_text == \"OK\" ). # start AEA thread t_aea = Thread ( target = aea . start ) try : t_aea . start () time . sleep ( 1.0 ) aea . outbox . put ( request_envelope ) time . sleep ( 5.0 ) assert ( aea_handler . handled_message . performative == HttpMessage . Performative . RESPONSE ) assert aea_handler . handled_message . version == \"\" assert aea_handler . handled_message . status_code == 200 assert aea_handler . handled_message . status_text == \"OK\" assert aea_handler . handled_message . headers is not None assert aea_handler . handled_message . version is not None finally : aea . stop () t_aea . join () Note that the response from the ACA is caught by the AEAHandler class which just saves the handled message. In the above interaction, and in general, the HTTP client connection the added to the AEA, takes care of the translation between messages and envelopes in the AEA world and the HTTP request/response format in the HTTP connection with the ACA.","title":"Aries Cloud Agent"},{"location":"aea/aries-cloud-agent/#discussion","text":"This demo illustrates how an AEA may connect to an Aries Cloud Agent (ACA). Hyperledger Aries Cloud Agent is a foundation for building self-sovereign identity/decentralized identity services using verifiable credentials. You can read more about Hyperledger here and the Aries project here . In this demo, you will learn how an AEA could connect with an ACA, to send it administrative commands (e.g. issue verifiable credential to another AEA) and receive DID related notifications (e.g. receive a request for a credential proof from another AEA).","title":"Discussion"},{"location":"aea/aries-cloud-agent/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/aries-cloud-agent/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/aries-cloud-agent/#aca","text":"","title":"ACA"},{"location":"aea/aries-cloud-agent/#install-aca","text":"Install Aries cloud-agents (run pip install aries-cloudagent or see here ) if you do not have it on your machine.","title":"Install ACA"},{"location":"aea/aries-cloud-agent/#run-the-demo-test","text":"Run the following test file using PyTest: PyTest tests/test_examples/test_http_client_connection_to_aries_cloud_agent.py You should see that the two tests pass.","title":"Run the demo test"},{"location":"aea/aries-cloud-agent/#demo-code","text":"Take a look at the test file you ran above tests/test_examples/test_http_client_connection_to_aries_cloud_agent.py . The main class is TestAEAToACA . The setup_class method initialises the scenario. @pytest . mark . asyncio class TestAEAToACA : \"\"\"End-to-end test for an AEA connecting to an ACA via the http client connection.\"\"\" @classmethod def setup_class ( cls ): \"\"\"Initialise the class.\"\"\" cls . aca_admin_address = \"127.0.0.1\" cls . aca_admin_port = 8020 ... The address and port fields cls.aca_admin_address and cls.aca_admin_port specify where the ACA should listen to receive administrative commands from the AEA. The following runs an ACA: cls . process = subprocess . Popen ( # nosec [ \"aca-py\" , \"start\" , \"--admin\" , cls . aca_admin_address , str ( cls . aca_admin_port ), \"--admin-insecure-mode\" , \"--inbound-transport\" , \"http\" , \"0.0.0.0\" , \"8000\" , \"--outbound-transport\" , \"http\" , ] ) Now take a look at the following method. This is where the demo resides. It first creates an AEA programmatically. @pytest . mark . asyncio async def test_end_to_end_aea_aca ( self ): # AEA components ledger_apis = LedgerApis ({}, FETCHAI ) wallet = Wallet ({ FETCHAI : FETCHAI_PRIVATE_KEY_FILE }) identity = Identity ( name = \"my_aea_1\" , address = wallet . addresses . get ( FETCHAI ), default_address_key = FETCHAI , ) http_client_connection = HTTPClientConnection ( agent_address = self . aea_address , provider_address = self . aca_admin_address , provider_port = self . aca_admin_port , ) resources = Resources () # create AEA aea = AEA ( identity , [ http_client_connection ], wallet , ledger_apis , resources ) ... It then adds the HTTP protocol to the AEA. THe HTTP protocol defines the format of HTTP interactions (e.g. HTTP Request and Response). # Add http protocol to AEA resources http_protocol_configuration = ProtocolConfig . from_json ( yaml . safe_load ( open ( os . path . join ( self . cwd , \"packages\" , \"fetchai\" , \"protocols\" , \"http\" , \"protocol.yaml\" , ) ) ) ) http_protocol = Protocol ( HttpMessage . protocol_id , HttpSerializer (), http_protocol_configuration , ) resources . protocol_registry . register ( HttpMessage . protocol_id , http_protocol ) Then, the request message and envelope is created: # Request message & envelope request_http_message = HttpMessage ( dialogue_reference = ( \"\" , \"\" ), target = 0 , message_id = 1 , performative = HttpMessage . Performative . REQUEST , method = \"GET\" , url = \"http:// {} : {} /status\" . format ( self . aca_admin_address , self . aca_admin_port ), headers = \"\" , version = \"\" , bodyy = b \"\" , ) request_envelope = Envelope ( to = \"ACA\" , sender = \"AEA\" , protocol_id = HTTP_PROTOCOL_PUBLIC_ID , message = HttpSerializer () . encode ( request_http_message ), ) Note that the performative is set to HttpMessage.Performative.REQUEST , the method GET corresponds with HTTP GET method, and url is where the request is sent. This is the location the ACA is listening for administrative commands. In the following part, the AEA is started in another thread t_aea = Thread(target=aea.start) , the HTTP request message created above is placed in the agent's outbox aea.outbox.put(request_envelope) to be sent to the ACA, and the received response is checked for success (e.g. assert aea_handler.handled_message.status_text == \"OK\" ). # start AEA thread t_aea = Thread ( target = aea . start ) try : t_aea . start () time . sleep ( 1.0 ) aea . outbox . put ( request_envelope ) time . sleep ( 5.0 ) assert ( aea_handler . handled_message . performative == HttpMessage . Performative . RESPONSE ) assert aea_handler . handled_message . version == \"\" assert aea_handler . handled_message . status_code == 200 assert aea_handler . handled_message . status_text == \"OK\" assert aea_handler . handled_message . headers is not None assert aea_handler . handled_message . version is not None finally : aea . stop () t_aea . join () Note that the response from the ACA is caught by the AEAHandler class which just saves the handled message. In the above interaction, and in general, the HTTP client connection the added to the AEA, takes care of the translation between messages and envelopes in the AEA world and the HTTP request/response format in the HTTP connection with the ACA.","title":"Demo code"},{"location":"aea/build-aea-programmatically/","text":"Preliminaries These instructions detail the Python code you need for running an AEA outside the cli tool, using the code interface. This guide assumes you have already followed the Preliminaries and Installation section in the quick start guide and so have the framework installed and the packages and scripts directory downloaded into the directory you are working in. Imports First, import the necessary common Python libraries and classes. import os import time from threading import Thread Then, import the application specific libraries. from aea import AEA_DIR from aea.aea import AEA from aea.connections.stub.connection import StubConnection from aea.crypto.fetchai import FETCHAI from aea.crypto.helpers import FETCHAI_PRIVATE_KEY_FILE , _create_fetchai_private_key from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet from aea.identity.base import Identity from aea.protocols.base import Protocol from aea.registries.base import Resources from aea.skills.base import Skill Set up a variable pointing to where the packages directory is located - this should be our current directory - and where the input and output files are located. ROOT_DIR = \"./\" INPUT_FILE = \"input.txt\" OUTPUT_FILE = \"output.txt\" Create a private key We need a private key to populate the AEA's wallet. # Create a private key _create_fetchai_private_key () Clearing the input and output files We will use the stub connection to pass envelopes in and out of the AEA. Ensure that any input and output text files are removed before we start. # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) Initialise the AEA We use the private key file we created to initialise a wallet, we also create the stub connection, tell it what Ledger APIs we are going to use (none in this example) and create a resources object containing skills, protocols and connections (this is initially empty). Then we pass all of this into the AEA constructor to create our AEA. # Set up the Wallet, stub connection, ledger and (empty) resources wallet = Wallet ({ FETCHAI : FETCHAI_PRIVATE_KEY_FILE }) stub_connection = StubConnection ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE ) ledger_apis = LedgerApis ({ \"fetchai\" : { \"network\" : \"testnet\" }}, \"fetchai\" ) resources = Resources () # Create an identity identity = Identity ( name = \"my_aea\" , address = wallet . addresses . get ( FETCHAI ), default_address_key = FETCHAI , ) # Create our AEA my_aea = AEA ( identity , [ stub_connection ], wallet , ledger_apis , resources ) Create the default protocol and add it to the AEA. # Add the default protocol (which is part of the AEA distribution) default_protocol = Protocol . from_dir ( os . path . join ( AEA_DIR , \"protocols\" , \"default\" )) resources . add_protocol ( default_protocol ) Create the error skill (needed by all AEAs) and the echo skill which will bounce our messages back to us, and add them both to the AEA. # Add the error skill (from the local packages dir) and the echo skill (which is part of the AEA distribution) echo_skill = Skill . from_dir ( os . path . join ( ROOT_DIR , \"packages\" , \"fetchai\" , \"skills\" , \"echo\" ), my_aea . context , ) resources . add_skill ( echo_skill ) error_skill = Skill . from_dir ( os . path . join ( AEA_DIR , \"skills\" , \"error\" ), my_aea . context ) resources . add_skill ( error_skill ) Start the AEA We run the AEA from a different thread so that we can still use the main thread to pass it messages. # Set the AEA running in a different thread try : t = Thread ( target = my_aea . start ) t . start () # Wait for everything to start up time . sleep ( 4 ) Send and receive an envelope We use the input and output text files to send an envelope to our AEA and receive a response (from the echo skill) # Create a message inside an envelope and get the stub connection to pass it on to the echo skill message_text = ( \"my_aea,other_agent,fetchai/default:0.1.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : f . write ( message_text ) print ( \"input message: \" + message_text ) # Wait for the envelope to get processed time . sleep ( 4 ) # Read the output envelope generated by the echo skill with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"output message: \" + f . readline ()) Shutdown Finally stop our AEA and wait for it to finish finally : # Shut down the AEA my_aea . stop () t . join () t = None Running the AEA If you now run this python script file, you should see this output: input message: my_aea,other_agent,fetchai/default:0.1.0,\\x08\\x01*\\x07\\n\\x05hello output message: other_agent,my_aea,fetchai/default:0.1.0,\\x08\\x01*\\x07\\n\\x05hello Entire code listing If you just want to copy and past the entire script in you can find it here: Click here to see full listing import os import time from threading import Thread from aea import AEA_DIR from aea.aea import AEA from aea.connections.stub.connection import StubConnection from aea.crypto.fetchai import FETCHAI from aea.crypto.helpers import FETCHAI_PRIVATE_KEY_FILE , _create_fetchai_private_key from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet from aea.identity.base import Identity from aea.protocols.base import Protocol from aea.registries.base import Resources from aea.skills.base import Skill ROOT_DIR = \"./\" INPUT_FILE = \"input.txt\" OUTPUT_FILE = \"output.txt\" def run (): # Create a private key _create_fetchai_private_key () # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # Set up the Wallet, stub connection, ledger and (empty) resources wallet = Wallet ({ FETCHAI : FETCHAI_PRIVATE_KEY_FILE }) stub_connection = StubConnection ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE ) ledger_apis = LedgerApis ({ \"fetchai\" : { \"network\" : \"testnet\" }}, \"fetchai\" ) resources = Resources () # Create an identity identity = Identity ( name = \"my_aea\" , address = wallet . addresses . get ( FETCHAI ), default_address_key = FETCHAI , ) # Create our AEA my_aea = AEA ( identity , [ stub_connection ], wallet , ledger_apis , resources ) # Add the default protocol (which is part of the AEA distribution) default_protocol = Protocol . from_dir ( os . path . join ( AEA_DIR , \"protocols\" , \"default\" )) resources . add_protocol ( default_protocol ) # Add the error skill (from the local packages dir) and the echo skill (which is part of the AEA distribution) echo_skill = Skill . from_dir ( os . path . join ( ROOT_DIR , \"packages\" , \"fetchai\" , \"skills\" , \"echo\" ), my_aea . context , ) resources . add_skill ( echo_skill ) error_skill = Skill . from_dir ( os . path . join ( AEA_DIR , \"skills\" , \"error\" ), my_aea . context ) resources . add_skill ( error_skill ) # Set the AEA running in a different thread try : t = Thread ( target = my_aea . start ) t . start () # Wait for everything to start up time . sleep ( 4 ) # Create a message inside an envelope and get the stub connection to pass it on to the echo skill message_text = ( \"my_aea,other_agent,fetchai/default:0.1.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : f . write ( message_text ) print ( \"input message: \" + message_text ) # Wait for the envelope to get processed time . sleep ( 4 ) # Read the output envelope generated by the echo skill with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"output message: \" + f . readline ()) finally : # Shut down the AEA my_aea . stop () t . join () t = None if __name__ == \"__main__\" : run ()","title":"Build an AEA programmatically"},{"location":"aea/build-aea-programmatically/#preliminaries","text":"These instructions detail the Python code you need for running an AEA outside the cli tool, using the code interface. This guide assumes you have already followed the Preliminaries and Installation section in the quick start guide and so have the framework installed and the packages and scripts directory downloaded into the directory you are working in.","title":"Preliminaries"},{"location":"aea/build-aea-programmatically/#imports","text":"First, import the necessary common Python libraries and classes. import os import time from threading import Thread Then, import the application specific libraries. from aea import AEA_DIR from aea.aea import AEA from aea.connections.stub.connection import StubConnection from aea.crypto.fetchai import FETCHAI from aea.crypto.helpers import FETCHAI_PRIVATE_KEY_FILE , _create_fetchai_private_key from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet from aea.identity.base import Identity from aea.protocols.base import Protocol from aea.registries.base import Resources from aea.skills.base import Skill Set up a variable pointing to where the packages directory is located - this should be our current directory - and where the input and output files are located. ROOT_DIR = \"./\" INPUT_FILE = \"input.txt\" OUTPUT_FILE = \"output.txt\"","title":"Imports"},{"location":"aea/build-aea-programmatically/#create-a-private-key","text":"We need a private key to populate the AEA's wallet. # Create a private key _create_fetchai_private_key ()","title":"Create a private key"},{"location":"aea/build-aea-programmatically/#clearing-the-input-and-output-files","text":"We will use the stub connection to pass envelopes in and out of the AEA. Ensure that any input and output text files are removed before we start. # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE )","title":"Clearing the input and output files"},{"location":"aea/build-aea-programmatically/#initialise-the-aea","text":"We use the private key file we created to initialise a wallet, we also create the stub connection, tell it what Ledger APIs we are going to use (none in this example) and create a resources object containing skills, protocols and connections (this is initially empty). Then we pass all of this into the AEA constructor to create our AEA. # Set up the Wallet, stub connection, ledger and (empty) resources wallet = Wallet ({ FETCHAI : FETCHAI_PRIVATE_KEY_FILE }) stub_connection = StubConnection ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE ) ledger_apis = LedgerApis ({ \"fetchai\" : { \"network\" : \"testnet\" }}, \"fetchai\" ) resources = Resources () # Create an identity identity = Identity ( name = \"my_aea\" , address = wallet . addresses . get ( FETCHAI ), default_address_key = FETCHAI , ) # Create our AEA my_aea = AEA ( identity , [ stub_connection ], wallet , ledger_apis , resources ) Create the default protocol and add it to the AEA. # Add the default protocol (which is part of the AEA distribution) default_protocol = Protocol . from_dir ( os . path . join ( AEA_DIR , \"protocols\" , \"default\" )) resources . add_protocol ( default_protocol ) Create the error skill (needed by all AEAs) and the echo skill which will bounce our messages back to us, and add them both to the AEA. # Add the error skill (from the local packages dir) and the echo skill (which is part of the AEA distribution) echo_skill = Skill . from_dir ( os . path . join ( ROOT_DIR , \"packages\" , \"fetchai\" , \"skills\" , \"echo\" ), my_aea . context , ) resources . add_skill ( echo_skill ) error_skill = Skill . from_dir ( os . path . join ( AEA_DIR , \"skills\" , \"error\" ), my_aea . context ) resources . add_skill ( error_skill )","title":"Initialise the AEA"},{"location":"aea/build-aea-programmatically/#start-the-aea","text":"We run the AEA from a different thread so that we can still use the main thread to pass it messages. # Set the AEA running in a different thread try : t = Thread ( target = my_aea . start ) t . start () # Wait for everything to start up time . sleep ( 4 )","title":"Start the AEA"},{"location":"aea/build-aea-programmatically/#send-and-receive-an-envelope","text":"We use the input and output text files to send an envelope to our AEA and receive a response (from the echo skill) # Create a message inside an envelope and get the stub connection to pass it on to the echo skill message_text = ( \"my_aea,other_agent,fetchai/default:0.1.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : f . write ( message_text ) print ( \"input message: \" + message_text ) # Wait for the envelope to get processed time . sleep ( 4 ) # Read the output envelope generated by the echo skill with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"output message: \" + f . readline ())","title":"Send and receive an envelope"},{"location":"aea/build-aea-programmatically/#shutdown","text":"Finally stop our AEA and wait for it to finish finally : # Shut down the AEA my_aea . stop () t . join () t = None","title":"Shutdown"},{"location":"aea/build-aea-programmatically/#running-the-aea","text":"If you now run this python script file, you should see this output: input message: my_aea,other_agent,fetchai/default:0.1.0,\\x08\\x01*\\x07\\n\\x05hello output message: other_agent,my_aea,fetchai/default:0.1.0,\\x08\\x01*\\x07\\n\\x05hello","title":"Running the AEA"},{"location":"aea/build-aea-programmatically/#entire-code-listing","text":"If you just want to copy and past the entire script in you can find it here: Click here to see full listing import os import time from threading import Thread from aea import AEA_DIR from aea.aea import AEA from aea.connections.stub.connection import StubConnection from aea.crypto.fetchai import FETCHAI from aea.crypto.helpers import FETCHAI_PRIVATE_KEY_FILE , _create_fetchai_private_key from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet from aea.identity.base import Identity from aea.protocols.base import Protocol from aea.registries.base import Resources from aea.skills.base import Skill ROOT_DIR = \"./\" INPUT_FILE = \"input.txt\" OUTPUT_FILE = \"output.txt\" def run (): # Create a private key _create_fetchai_private_key () # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # Set up the Wallet, stub connection, ledger and (empty) resources wallet = Wallet ({ FETCHAI : FETCHAI_PRIVATE_KEY_FILE }) stub_connection = StubConnection ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE ) ledger_apis = LedgerApis ({ \"fetchai\" : { \"network\" : \"testnet\" }}, \"fetchai\" ) resources = Resources () # Create an identity identity = Identity ( name = \"my_aea\" , address = wallet . addresses . get ( FETCHAI ), default_address_key = FETCHAI , ) # Create our AEA my_aea = AEA ( identity , [ stub_connection ], wallet , ledger_apis , resources ) # Add the default protocol (which is part of the AEA distribution) default_protocol = Protocol . from_dir ( os . path . join ( AEA_DIR , \"protocols\" , \"default\" )) resources . add_protocol ( default_protocol ) # Add the error skill (from the local packages dir) and the echo skill (which is part of the AEA distribution) echo_skill = Skill . from_dir ( os . path . join ( ROOT_DIR , \"packages\" , \"fetchai\" , \"skills\" , \"echo\" ), my_aea . context , ) resources . add_skill ( echo_skill ) error_skill = Skill . from_dir ( os . path . join ( AEA_DIR , \"skills\" , \"error\" ), my_aea . context ) resources . add_skill ( error_skill ) # Set the AEA running in a different thread try : t = Thread ( target = my_aea . start ) t . start () # Wait for everything to start up time . sleep ( 4 ) # Create a message inside an envelope and get the stub connection to pass it on to the echo skill message_text = ( \"my_aea,other_agent,fetchai/default:0.1.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : f . write ( message_text ) print ( \"input message: \" + message_text ) # Wait for the envelope to get processed time . sleep ( 4 ) # Read the output envelope generated by the echo skill with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"output message: \" + f . readline ()) finally : # Shut down the AEA my_aea . stop () t . join () t = None if __name__ == \"__main__\" : run ()","title":"Entire code listing"},{"location":"aea/build-aea-step-by-step/","text":"Building an AEA step by step (ensure you have followed the Preliminaries and Installation sections from the AEA quick start first): Set up your AEA project with the CLI: aea create my_aea && cd my_aea Look at, then add the right connections for your usecase: aea search connections , then aea add connection [public_id] Look at, then add or generate the protocols you require: aea search protocols , then aea add protocol [public_id] or aea generate protocol [path_to_specification] Look at, then add or code the skills you need: aea search skills , then aea add skill [public_id] . This guide shows you step by step how to develop a skill. Where required, scaffold any of the above resources with the scaffolding tool or generate a protocol with the protocol generator . Now, run your AEA: aea run --connections [public_id] See information on the CLI tool here for all the available commands.","title":"Build an AEA with the CLI"},{"location":"aea/car-park-skills/","text":"The AEA car-park skills demonstrate an interaction between two AEAs. The carpark_detection AEA provides information on the number of car parking spaces available in a given vicinity. The carpark_client AEA is interested in purchasing information on available car parking spaces in the same vicinity. Discussion The full Fetch.ai car park AEA demo is documented in its own repo here . This demo allows you to test the AEA functionality of the car park AEA demo without the detection logic. It demonstrates how the AEAs trade car park information. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Launch the OEF search and communication node In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for all the following. Demo instructions: Ledger payment Create car detector AEA First, create the car detector AEA: aea create car_detector cd car_detector aea add connection fetchai/oef:0.1.0 aea add skill fetchai/carpark_detection:0.1.0 aea install Alternatively to the previous two steps, simply run: aea fetch fetchai/car_detector:0.1.0 cd car_detector aea install Create car data buyer AEA Then, create the car data client AEA: aea create car_data_buyer cd car_data_buyer aea add connection fetchai/oef:0.1.0 aea add skill fetchai/carpark_client:0.1.0 aea install Alternatively to the previous two steps, simply run: aea fetch fetchai/car_data_buyer:0.1.0 cd car_data_buyer aea install Additionally, create the private key for the car data buyer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai use: aea generate-key fetchai aea add-key fetchai fet_private_key.txt To generate and add a private-public key pair for Ethereum use: aea generate-key ethereum aea add-key ethereum eth_private_key.txt Update the AEA configs Both in car_detector/aea-config.yaml and car_data_buyer/aea-config.yaml , replace ledger_apis: {} with the following based on the network you want to connect. To connect to Fetchai: ledger_apis : fetchai : network : testnet To connect to Ethereum: ledger_apis : ethereum : address : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 gas_price : 50 Generate wealth for the car data buyer AEA Create some wealth for your car data buyer based on the network you want to transact with: On the Fetch.ai testnet network. aea generate-wealth fetchai On the Ethereum ropsten . (It takes a while). aea generate-wealth ethereum Update the skill configs In the carpark detection skill config ( car_detector/vendor/fetchai/skills/carpark_detection/skill.yaml ) under strategy, amend the currency_id , ledger_id , and db_is_rel_to_cwd as follows. | ----------------------------------------------------------------------| | FETCHAI | ETHEREUM | | -----------------------------------|----------------------------------| |models : |models : | | strategy : | strategy : | | class_name : Strategy | class_name : Strategy | | args : | args : | | data_price_fet : 2000 | data_price_fet : 2000 | | db_is_rel_to_cwd : False | db_is_rel_to_cwd : False | | db_rel_dir : ../temp_files | db_rel_dir : ../temp_files | | currency_id : 'FET' | currency_id : 'ETH' | | ledger_id : 'fetchai' | ledger_id : 'ethereum' | | is_ledger_tx : True | is_ledger_tx : True | | seller_tx_fee : 0 | seller_tx_fee : 0 | | ----------------------------------------------------------------------| An other way to update the skill config is via the aea config get/set command. aea config set vendor.fetchai.skills.carpark_detection.models.strategy.args.currency_id ETH aea config set vendor.fetchai.skills.carpark_detection.models.strategy.args.ledger_id ethereum aea config set vendor.fetchai.skills.carpark_detection.models.strategy.args.db_is_rel_to_cwd False --type bool In the carpark data buyer skill config ( car_data_buyer/vendor/fetchai/skills/carpark_client/skill.yaml ) under strategy change the currency_id and ledger_id . | ----------------------------------------------------------------------| | FETCHAI | ETHEREUM | | -----------------------------------|----------------------------------| |models : |models : | | strategy : | strategy : | | class_name : Strategy | class_name : Strategy | | args : | args : | | country : UK | country : UK | | search_interval : 120 | search_interval : 120 | | no_find_search_interval : 5 | no_find_search_interval : 5 | | max_price : 40000 | max_price : 40000 | | max_detection_age : 36000000 | max_detection_age : 36000000 | | currency_id : 'FET' | currency_id : 'ETH' | | ledger_id : 'fetchai' | ledger_id : 'ethereum' | | is_ledger_tx : True | is_ledger_tx : True | | max_buyer_tx_fee : 6000 | max_buyer_tx_fee : 6000 | |ledgers : [ 'fetchai' ] |ledgers : [ 'ethereum' ] | | ----------------------------------------------------------------------| Another way to update the skill config is via the aea config get/set command. aea config set vendor.fetchai.skills.carpark_client.models.strategy.args.max_buyer_tx_fee 6000 --type int aea config set vendor.fetchai.skills.carpark_client.models.strategy.args.currency_id ETH aea config set vendor.fetchai.skills.carpark_client.models.strategy.args.ledger_id ethereum Run both AEAs Finally, run both AEAs from their respective directories: aea run --connections fetchai/oef:0.1.0 You can see that the AEAs find each other, negotiate and eventually trade. Cleaning up When you're finished, delete your AEAs: cd .. aea delete car_detector aea delete car_data_buyer Communication This diagram shows the communication between the various entities as data is successfully sold by the car park AEA to the client. sequenceDiagram participant Search participant Car_Data_Buyer_AEA participant Car_Park_AEA participant Blockchain activate Car_Data_Buyer_AEA activate Search activate Car_Park_AEA activate Blockchain Car_Park_AEA->>Search: register_service Car_Data_Buyer_AEA->>Search: search Search-->>Car_Data_Buyer_AEA: list_of_agents Car_Data_Buyer_AEA->>Car_Park_AEA: call_for_proposal Car_Park_AEA->>Car_Data_Buyer_AEA: propose Car_Data_Buyer_AEA->>Car_Park_AEA: accept Car_Park_AEA->>Car_Data_Buyer_AEA: match_accept Car_Data_Buyer_AEA->>Blockchain: transfer_funds Car_Data_Buyer_AEA->>Car_Park_AEA: send_transaction_hash Car_Park_AEA->>Blockchain: check_transaction_status Car_Park_AEA->>Car_Data_Buyer_AEA: send_data deactivate Client_AEA deactivate Search deactivate Car_Park_AEA deactivate Blockchain","title":"Car park skills"},{"location":"aea/car-park-skills/#discussion","text":"The full Fetch.ai car park AEA demo is documented in its own repo here . This demo allows you to test the AEA functionality of the car park AEA demo without the detection logic. It demonstrates how the AEAs trade car park information.","title":"Discussion"},{"location":"aea/car-park-skills/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/car-park-skills/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/car-park-skills/#launch-the-oef-search-and-communication-node","text":"In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for all the following.","title":"Launch the OEF search and communication node"},{"location":"aea/car-park-skills/#demo-instructions-ledger-payment","text":"","title":"Demo instructions: Ledger payment"},{"location":"aea/car-park-skills/#create-car-detector-aea","text":"First, create the car detector AEA: aea create car_detector cd car_detector aea add connection fetchai/oef:0.1.0 aea add skill fetchai/carpark_detection:0.1.0 aea install Alternatively to the previous two steps, simply run: aea fetch fetchai/car_detector:0.1.0 cd car_detector aea install","title":"Create car detector AEA"},{"location":"aea/car-park-skills/#create-car-data-buyer-aea","text":"Then, create the car data client AEA: aea create car_data_buyer cd car_data_buyer aea add connection fetchai/oef:0.1.0 aea add skill fetchai/carpark_client:0.1.0 aea install Alternatively to the previous two steps, simply run: aea fetch fetchai/car_data_buyer:0.1.0 cd car_data_buyer aea install Additionally, create the private key for the car data buyer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai use: aea generate-key fetchai aea add-key fetchai fet_private_key.txt To generate and add a private-public key pair for Ethereum use: aea generate-key ethereum aea add-key ethereum eth_private_key.txt","title":"Create car data buyer AEA"},{"location":"aea/car-park-skills/#update-the-aea-configs","text":"Both in car_detector/aea-config.yaml and car_data_buyer/aea-config.yaml , replace ledger_apis: {} with the following based on the network you want to connect. To connect to Fetchai: ledger_apis : fetchai : network : testnet To connect to Ethereum: ledger_apis : ethereum : address : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 gas_price : 50","title":"Update the AEA configs"},{"location":"aea/car-park-skills/#generate-wealth-for-the-car-data-buyer-aea","text":"Create some wealth for your car data buyer based on the network you want to transact with: On the Fetch.ai testnet network. aea generate-wealth fetchai On the Ethereum ropsten . (It takes a while). aea generate-wealth ethereum","title":"Generate wealth for the car data buyer AEA"},{"location":"aea/car-park-skills/#update-the-skill-configs","text":"In the carpark detection skill config ( car_detector/vendor/fetchai/skills/carpark_detection/skill.yaml ) under strategy, amend the currency_id , ledger_id , and db_is_rel_to_cwd as follows. | ----------------------------------------------------------------------| | FETCHAI | ETHEREUM | | -----------------------------------|----------------------------------| |models : |models : | | strategy : | strategy : | | class_name : Strategy | class_name : Strategy | | args : | args : | | data_price_fet : 2000 | data_price_fet : 2000 | | db_is_rel_to_cwd : False | db_is_rel_to_cwd : False | | db_rel_dir : ../temp_files | db_rel_dir : ../temp_files | | currency_id : 'FET' | currency_id : 'ETH' | | ledger_id : 'fetchai' | ledger_id : 'ethereum' | | is_ledger_tx : True | is_ledger_tx : True | | seller_tx_fee : 0 | seller_tx_fee : 0 | | ----------------------------------------------------------------------| An other way to update the skill config is via the aea config get/set command. aea config set vendor.fetchai.skills.carpark_detection.models.strategy.args.currency_id ETH aea config set vendor.fetchai.skills.carpark_detection.models.strategy.args.ledger_id ethereum aea config set vendor.fetchai.skills.carpark_detection.models.strategy.args.db_is_rel_to_cwd False --type bool In the carpark data buyer skill config ( car_data_buyer/vendor/fetchai/skills/carpark_client/skill.yaml ) under strategy change the currency_id and ledger_id . | ----------------------------------------------------------------------| | FETCHAI | ETHEREUM | | -----------------------------------|----------------------------------| |models : |models : | | strategy : | strategy : | | class_name : Strategy | class_name : Strategy | | args : | args : | | country : UK | country : UK | | search_interval : 120 | search_interval : 120 | | no_find_search_interval : 5 | no_find_search_interval : 5 | | max_price : 40000 | max_price : 40000 | | max_detection_age : 36000000 | max_detection_age : 36000000 | | currency_id : 'FET' | currency_id : 'ETH' | | ledger_id : 'fetchai' | ledger_id : 'ethereum' | | is_ledger_tx : True | is_ledger_tx : True | | max_buyer_tx_fee : 6000 | max_buyer_tx_fee : 6000 | |ledgers : [ 'fetchai' ] |ledgers : [ 'ethereum' ] | | ----------------------------------------------------------------------| Another way to update the skill config is via the aea config get/set command. aea config set vendor.fetchai.skills.carpark_client.models.strategy.args.max_buyer_tx_fee 6000 --type int aea config set vendor.fetchai.skills.carpark_client.models.strategy.args.currency_id ETH aea config set vendor.fetchai.skills.carpark_client.models.strategy.args.ledger_id ethereum","title":"Update the skill configs"},{"location":"aea/car-park-skills/#run-both-aeas","text":"Finally, run both AEAs from their respective directories: aea run --connections fetchai/oef:0.1.0 You can see that the AEAs find each other, negotiate and eventually trade.","title":"Run both AEAs"},{"location":"aea/car-park-skills/#cleaning-up","text":"When you're finished, delete your AEAs: cd .. aea delete car_detector aea delete car_data_buyer","title":"Cleaning up"},{"location":"aea/car-park-skills/#communication","text":"This diagram shows the communication between the various entities as data is successfully sold by the car park AEA to the client. sequenceDiagram participant Search participant Car_Data_Buyer_AEA participant Car_Park_AEA participant Blockchain activate Car_Data_Buyer_AEA activate Search activate Car_Park_AEA activate Blockchain Car_Park_AEA->>Search: register_service Car_Data_Buyer_AEA->>Search: search Search-->>Car_Data_Buyer_AEA: list_of_agents Car_Data_Buyer_AEA->>Car_Park_AEA: call_for_proposal Car_Park_AEA->>Car_Data_Buyer_AEA: propose Car_Data_Buyer_AEA->>Car_Park_AEA: accept Car_Park_AEA->>Car_Data_Buyer_AEA: match_accept Car_Data_Buyer_AEA->>Blockchain: transfer_funds Car_Data_Buyer_AEA->>Car_Park_AEA: send_transaction_hash Car_Park_AEA->>Blockchain: check_transaction_status Car_Park_AEA->>Car_Data_Buyer_AEA: send_data deactivate Client_AEA deactivate Search deactivate Car_Park_AEA deactivate Blockchain","title":"Communication"},{"location":"aea/cli-commands/","text":"CLI commands Command Description add connection/protocol/skill [public_id] Add connection, protocol, or skill, with [public_id] , to the AEA. add --registry to add from remote registry. add-key fetchai/ethereum file Add a private key from a file. create NAME Create a new aea project called [name] . config get [path] Reads the config specified in [path] and prints its target. config set [path] [--type TYPE] Sets a new value for the target of the [path] . Optionally cast to type. delete NAME Delete an aea project. See below for disabling a resource. fetch PUBLIC_ID Fetch an aea project with [public_id] . fetch --registry to fetch from remote registry. freeze Get all the dependencies needed for the aea project and its components. gui Run the GUI. generate-key fetchai/ethereum/all Generate private keys. The AEA uses a private key to derive the associated public key and address. generate-wealth fetchai/ethereum Generate wealth for address on test network. get-address fetchai/ethereum Get the address associated with the private key. get-wealth fetchai/ethereum Get the wealth associated with the private key. install [-r <requirements_file>] Install the dependencies. (With --install-deps to install dependencies.) init Initialize your AEA configurations. (With --author to define author.) launch [path_to_agent_project]... Launch many agents. list protocols/connections/skills List the installed resources. login USERNAME [--password password] Login to a registry account with credentials. publish Publish the AEA to registry. Needs to be executed from an AEA project. publish --registry to publish to remote registry. push connection/protocol/skill [public_id] Push connection, protocol, or skill with [public_id] to registry. push --registry to push to remote registry. remove connection/protocol/skill [name] Remove connection, protocol, or skill, called [name] , from AEA. run {using [connections, ...]} Run the AEA on the Fetch.ai network with default or specified connections. search protocols/connections/skills Search for components in the registry. search --registry protocols/connections/skills [--query searching_query] to search in remote registry. scaffold connection/protocol/skill [name] Scaffold a new connection, protocol, or skill called [name] . -v DEBUG run Run with debugging. Tip You can also disable a resource without deleting it by removing the entry from the configuration but leaving the package in the skills namespace.","title":"Commands"},{"location":"aea/cli-commands/#cli-commands","text":"Command Description add connection/protocol/skill [public_id] Add connection, protocol, or skill, with [public_id] , to the AEA. add --registry to add from remote registry. add-key fetchai/ethereum file Add a private key from a file. create NAME Create a new aea project called [name] . config get [path] Reads the config specified in [path] and prints its target. config set [path] [--type TYPE] Sets a new value for the target of the [path] . Optionally cast to type. delete NAME Delete an aea project. See below for disabling a resource. fetch PUBLIC_ID Fetch an aea project with [public_id] . fetch --registry to fetch from remote registry. freeze Get all the dependencies needed for the aea project and its components. gui Run the GUI. generate-key fetchai/ethereum/all Generate private keys. The AEA uses a private key to derive the associated public key and address. generate-wealth fetchai/ethereum Generate wealth for address on test network. get-address fetchai/ethereum Get the address associated with the private key. get-wealth fetchai/ethereum Get the wealth associated with the private key. install [-r <requirements_file>] Install the dependencies. (With --install-deps to install dependencies.) init Initialize your AEA configurations. (With --author to define author.) launch [path_to_agent_project]... Launch many agents. list protocols/connections/skills List the installed resources. login USERNAME [--password password] Login to a registry account with credentials. publish Publish the AEA to registry. Needs to be executed from an AEA project. publish --registry to publish to remote registry. push connection/protocol/skill [public_id] Push connection, protocol, or skill with [public_id] to registry. push --registry to push to remote registry. remove connection/protocol/skill [name] Remove connection, protocol, or skill, called [name] , from AEA. run {using [connections, ...]} Run the AEA on the Fetch.ai network with default or specified connections. search protocols/connections/skills Search for components in the registry. search --registry protocols/connections/skills [--query searching_query] to search in remote registry. scaffold connection/protocol/skill [name] Scaffold a new connection, protocol, or skill called [name] . -v DEBUG run Run with debugging. Tip You can also disable a resource without deleting it by removing the entry from the configuration but leaving the package in the skills namespace.","title":"CLI commands"},{"location":"aea/cli-gui/","text":"You can invoke the AEA Command Line Interface (CLI) from a Graphical User Interface (GUI) accessed from a web browser. These instructions will take you through building an AEA, starting an OEF search and communication node , and running the AEA - all from the GUI. Preliminaries Follow the Preliminaries and Installation instructions here . Install the extra dependencies for the CLI GUI. pip install aea [ cli_gui ] Starting the GUI Go to the directory in which you will create new AEAs. If you followed the quick start guide, this will be my_aea . Start the local web-server. aea gui Open this page in a browser: http://127.0.0.1:8001 You should see the following page. On the left-hand side we can see any AEAs you have created and beneath that the protocols, connections and skills they have. Initially this will be empty - unless you have followed the quick start guide previously and not deleted those AEAs. On the right-hand side is a search interface to the Registry which gives you access to protocols, connections, and skills which are available to add to your AEA. To create a new AEA and run it, follow these steps. In the [Create Agent id] box on the left. type the name of your AEA - e.g. my_new_aea. Click the [Create Agent] button - the newly created AEA should appear in the [Local Agents] table. This should now be the currently selected AEA - but you can click on its name in the list to make sure. Click in the search input box and type \"echo\" Click the [Search] button - this will list all the skills with echo in their name or description. Note that at present this search functionality is not working and it will list all the skills Find the Echo skill and click on it - this will select it. Click on the [Add skill] button - which should now say \"Add echo skill to my_new_aea agent\". Start an OEF search and communication node by clicking on the [Start OEF Node] button. Wait for the text saying \"A thing of beauty is a joy forever...\" to appear. When you see that, the node has started successfully. Start the AEA running by clicking on the [start agent] button. You should see the output from the echo AEA appearing on the screen. This is how your whole page should look if you followed the instructions correctly.","title":"GUI"},{"location":"aea/cli-gui/#preliminaries","text":"Follow the Preliminaries and Installation instructions here . Install the extra dependencies for the CLI GUI. pip install aea [ cli_gui ]","title":"Preliminaries"},{"location":"aea/cli-gui/#starting-the-gui","text":"Go to the directory in which you will create new AEAs. If you followed the quick start guide, this will be my_aea . Start the local web-server. aea gui Open this page in a browser: http://127.0.0.1:8001 You should see the following page. On the left-hand side we can see any AEAs you have created and beneath that the protocols, connections and skills they have. Initially this will be empty - unless you have followed the quick start guide previously and not deleted those AEAs. On the right-hand side is a search interface to the Registry which gives you access to protocols, connections, and skills which are available to add to your AEA. To create a new AEA and run it, follow these steps. In the [Create Agent id] box on the left. type the name of your AEA - e.g. my_new_aea. Click the [Create Agent] button - the newly created AEA should appear in the [Local Agents] table. This should now be the currently selected AEA - but you can click on its name in the list to make sure. Click in the search input box and type \"echo\" Click the [Search] button - this will list all the skills with echo in their name or description. Note that at present this search functionality is not working and it will list all the skills Find the Echo skill and click on it - this will select it. Click on the [Add skill] button - which should now say \"Add echo skill to my_new_aea agent\". Start an OEF search and communication node by clicking on the [Start OEF Node] button. Wait for the text saying \"A thing of beauty is a joy forever...\" to appear. When you see that, the node has started successfully. Start the AEA running by clicking on the [start agent] button. You should see the output from the echo AEA appearing on the screen. This is how your whole page should look if you followed the instructions correctly.","title":"Starting the GUI"},{"location":"aea/cli-how-to/","text":"The command line interface is the easiest way to build an AEA. Installation The following installs the AEA cli package. pip install aea [ cli ] The following installs the entire AEA package including the cli. pip install aea [ all ] If you are using zsh rather than bash type pip install 'aea[cli]' and pip install 'aea[all]' respectively. Troubleshooting To ensure no cache is used run. pip install aea [ all ] --force --no-cache-dir And for zsh run: pip install 'aea[all]' --force --no-cache-dir","title":"Installation"},{"location":"aea/cli-how-to/#installation","text":"The following installs the AEA cli package. pip install aea [ cli ] The following installs the entire AEA package including the cli. pip install aea [ all ] If you are using zsh rather than bash type pip install 'aea[cli]' and pip install 'aea[all]' respectively.","title":"Installation"},{"location":"aea/cli-how-to/#troubleshooting","text":"To ensure no cache is used run. pip install aea [ all ] --force --no-cache-dir And for zsh run: pip install 'aea[all]' --force --no-cache-dir","title":"Troubleshooting"},{"location":"aea/cli-vs-programmatic-aeas/","text":"The AEA framework enables us to create agents either from the CLI tool or programmatically. The following demo demonstrates an interaction between two AEAs. The provider of weather data (managed with the CLI). The buyer of weather data (managed programmatically). Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Discussion The scope of the specific demo is to demonstrate how a CLI based AEA can interact with a programmatically managed AEA. In order to achieve this we are going to use the weather station skills. This demo does not utilize a smart contract or a ledger interaction. Launch an OEF search and communication node In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for the entire demo. Demo instructions If you want to create the weather station AEA step by step you can follow this guide here Create the weather station AEA Fetch the weather station AEA with the following command : aea fetch fetchai/weather_station:0.1.0 Update the AEA configs In the terminal change the configuration: aea config set vendor.fetchai.skills.weather_station.models.strategy.args.is_ledger_tx False --type bool The is_ledger_tx will prevent the AEA to communicate with a ledger. Run the weather station AEA aea run --connections fetchai/oef:0.1.0 Create the weather client AEA Since we want to show the interaction between a programmatically created AEA with a CLI based AEA we are going to write some code for the client. Create a new python file and name it weather_client.py and add the following code Weather client full code. import logging import os import time from threading import Thread from typing import cast from aea import AEA_DIR from aea.aea import AEA from aea.crypto.fetchai import FETCHAI from aea.crypto.helpers import FETCHAI_PRIVATE_KEY_FILE , _create_fetchai_private_key from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet from aea.identity.base import Identity from aea.protocols.base import Protocol from aea.registries.base import Resources from aea.skills.base import Skill from packages.fetchai.connections.oef.connection import OEFConnection from packages.fetchai.skills.weather_client.strategy import Strategy HOST = \"127.0.0.1\" PORT = 10000 ROOT_DIR = os . getcwd () # Not sure what level of logging to specify to get the logging to be displayed? logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( level = logging . INFO ) def run (): # Create a private key _create_fetchai_private_key () # Set up the wallet, identity, oef connection, ledger and (empty) resources wallet = Wallet ({ FETCHAI : FETCHAI_PRIVATE_KEY_FILE }) identity = Identity ( \"my_aea\" , address = wallet . addresses . get ( FETCHAI )) oef_connection = OEFConnection ( address = identity . address , oef_addr = HOST , oef_port = PORT ) ledger_apis = LedgerApis ({}, FETCHAI ) resources = Resources () # create the AEA my_aea = AEA ( identity , [ oef_connection ], wallet , ledger_apis , resources , # stub_connection, ) # Add the default protocol (which is part of the AEA distribution) default_protocol = Protocol . from_dir ( os . path . join ( AEA_DIR , \"protocols\" , \"default\" )) resources . add_protocol ( default_protocol ) # Add the oef protocol (which is a package) oef_protocol = Protocol . from_dir ( os . path . join ( os . getcwd (), \"packages\" , \"fetchai\" , \"protocols\" , \"oef_search\" ,) ) resources . add_protocol ( oef_protocol ) # Add the fipa protocol (which is a package) fipa_protocol = Protocol . from_dir ( os . path . join ( os . getcwd (), \"packages\" , \"fetchai\" , \"protocols\" , \"fipa\" ,) ) resources . add_protocol ( fipa_protocol ) # Add the error and weather_station skills error_skill = Skill . from_dir ( os . path . join ( AEA_DIR , \"skills\" , \"error\" ), my_aea . context ) weather_skill = Skill . from_dir ( os . path . join ( ROOT_DIR , \"packages\" , \"fetchai\" , \"skills\" , \"weather_client\" ), my_aea . context , ) strategy = cast ( Strategy , weather_skill . models . get ( \"strategy\" )) strategy . is_ledger_tx = False strategy . max_buyer_tx_fee = 100 strategy . max_row_price = 40 for skill in [ error_skill , weather_skill ]: resources . add_skill ( skill ) # Set the AEA running in a different thread try : logger . info ( \"STARTING AEA NOW!\" ) t = Thread ( target = my_aea . start ) t . start () # Let it run long enough to interact with the weather station time . sleep ( 25 ) finally : # Shut down the AEA logger . info ( \"STOPPING AEA NOW!\" ) my_aea . stop () t . join () if __name__ == \"__main__\" : run () For more details on how to create an agent programmatically follow this guide here Run the weather station AEA In a new terminal window, navigate to the folder that you created the script and run: python weather_client.py You should see both AEAs interacting now.","title":"CLI vs programmatic AEAs"},{"location":"aea/cli-vs-programmatic-aeas/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/cli-vs-programmatic-aeas/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/cli-vs-programmatic-aeas/#discussion","text":"The scope of the specific demo is to demonstrate how a CLI based AEA can interact with a programmatically managed AEA. In order to achieve this we are going to use the weather station skills. This demo does not utilize a smart contract or a ledger interaction.","title":"Discussion"},{"location":"aea/cli-vs-programmatic-aeas/#launch-an-oef-search-and-communication-node","text":"In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for the entire demo.","title":"Launch an OEF search and communication node"},{"location":"aea/cli-vs-programmatic-aeas/#demo-instructions","text":"If you want to create the weather station AEA step by step you can follow this guide here","title":"Demo instructions"},{"location":"aea/cli-vs-programmatic-aeas/#create-the-weather-station-aea","text":"Fetch the weather station AEA with the following command : aea fetch fetchai/weather_station:0.1.0","title":"Create the weather station AEA"},{"location":"aea/cli-vs-programmatic-aeas/#update-the-aea-configs","text":"In the terminal change the configuration: aea config set vendor.fetchai.skills.weather_station.models.strategy.args.is_ledger_tx False --type bool The is_ledger_tx will prevent the AEA to communicate with a ledger.","title":"Update the AEA configs"},{"location":"aea/cli-vs-programmatic-aeas/#run-the-weather-station-aea","text":"aea run --connections fetchai/oef:0.1.0","title":"Run the weather station AEA"},{"location":"aea/cli-vs-programmatic-aeas/#create-the-weather-client-aea","text":"Since we want to show the interaction between a programmatically created AEA with a CLI based AEA we are going to write some code for the client. Create a new python file and name it weather_client.py and add the following code Weather client full code. import logging import os import time from threading import Thread from typing import cast from aea import AEA_DIR from aea.aea import AEA from aea.crypto.fetchai import FETCHAI from aea.crypto.helpers import FETCHAI_PRIVATE_KEY_FILE , _create_fetchai_private_key from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet from aea.identity.base import Identity from aea.protocols.base import Protocol from aea.registries.base import Resources from aea.skills.base import Skill from packages.fetchai.connections.oef.connection import OEFConnection from packages.fetchai.skills.weather_client.strategy import Strategy HOST = \"127.0.0.1\" PORT = 10000 ROOT_DIR = os . getcwd () # Not sure what level of logging to specify to get the logging to be displayed? logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( level = logging . INFO ) def run (): # Create a private key _create_fetchai_private_key () # Set up the wallet, identity, oef connection, ledger and (empty) resources wallet = Wallet ({ FETCHAI : FETCHAI_PRIVATE_KEY_FILE }) identity = Identity ( \"my_aea\" , address = wallet . addresses . get ( FETCHAI )) oef_connection = OEFConnection ( address = identity . address , oef_addr = HOST , oef_port = PORT ) ledger_apis = LedgerApis ({}, FETCHAI ) resources = Resources () # create the AEA my_aea = AEA ( identity , [ oef_connection ], wallet , ledger_apis , resources , # stub_connection, ) # Add the default protocol (which is part of the AEA distribution) default_protocol = Protocol . from_dir ( os . path . join ( AEA_DIR , \"protocols\" , \"default\" )) resources . add_protocol ( default_protocol ) # Add the oef protocol (which is a package) oef_protocol = Protocol . from_dir ( os . path . join ( os . getcwd (), \"packages\" , \"fetchai\" , \"protocols\" , \"oef_search\" ,) ) resources . add_protocol ( oef_protocol ) # Add the fipa protocol (which is a package) fipa_protocol = Protocol . from_dir ( os . path . join ( os . getcwd (), \"packages\" , \"fetchai\" , \"protocols\" , \"fipa\" ,) ) resources . add_protocol ( fipa_protocol ) # Add the error and weather_station skills error_skill = Skill . from_dir ( os . path . join ( AEA_DIR , \"skills\" , \"error\" ), my_aea . context ) weather_skill = Skill . from_dir ( os . path . join ( ROOT_DIR , \"packages\" , \"fetchai\" , \"skills\" , \"weather_client\" ), my_aea . context , ) strategy = cast ( Strategy , weather_skill . models . get ( \"strategy\" )) strategy . is_ledger_tx = False strategy . max_buyer_tx_fee = 100 strategy . max_row_price = 40 for skill in [ error_skill , weather_skill ]: resources . add_skill ( skill ) # Set the AEA running in a different thread try : logger . info ( \"STARTING AEA NOW!\" ) t = Thread ( target = my_aea . start ) t . start () # Let it run long enough to interact with the weather station time . sleep ( 25 ) finally : # Shut down the AEA logger . info ( \"STOPPING AEA NOW!\" ) my_aea . stop () t . join () if __name__ == \"__main__\" : run () For more details on how to create an agent programmatically follow this guide here","title":"Create the weather client AEA"},{"location":"aea/cli-vs-programmatic-aeas/#run-the-weather-station-aea_1","text":"In a new terminal window, navigate to the folder that you created the script and run: python weather_client.py You should see both AEAs interacting now.","title":"Run the weather station AEA"},{"location":"aea/connect-a-frontend/","text":"This demo will discuss the options we have to connect a frontend to the AEA. The following diagram illustrates the two options we are going to discuss. Case 1 The first option we have is to create a Connection that will handle the incoming requests from the rest API. In this scenario, the rest API communicates with the AEA and requests are handled by the HTTP Connection package. The rest API should send CRUD requests to the HTTP Connection which translates these into Envelopes to be consumed by the correct skill. Case 2 The other option would be to create a stand-alone Multiplexer with an OEF connection. In this scenario, the frontend needs to incorporate a Multiplexer with an OEF connection. Then the OEF communication node can be used to send envelopes from the AEA to the frontend. Conclusion The major difference between these two approaches is that in the first case we should know the IP of the AEA to be able to communicate. In case 2 though, the whole communication is handled by the OEF communication node .","title":"Frontend intergration"},{"location":"aea/connect-a-frontend/#case-1","text":"The first option we have is to create a Connection that will handle the incoming requests from the rest API. In this scenario, the rest API communicates with the AEA and requests are handled by the HTTP Connection package. The rest API should send CRUD requests to the HTTP Connection which translates these into Envelopes to be consumed by the correct skill.","title":"Case 1"},{"location":"aea/connect-a-frontend/#case-2","text":"The other option would be to create a stand-alone Multiplexer with an OEF connection. In this scenario, the frontend needs to incorporate a Multiplexer with an OEF connection. Then the OEF communication node can be used to send envelopes from the AEA to the frontend.","title":"Case 2"},{"location":"aea/connect-a-frontend/#conclusion","text":"The major difference between these two approaches is that in the first case we should know the IP of the AEA to be able to communicate. In case 2 though, the whole communication is handled by the OEF communication node .","title":"Conclusion"},{"location":"aea/connection/","text":"A Connection is attached to an AEA within the AEA framework. The connection.py module in the connections directory contains a Connection class, which is a wrapper for an SDK or API An AEA can interact with multiple connections at the same time. Configuration The connection.yaml file in the AEA directory contains protocol details and connection url and port details. For example, the oef connection.yaml contains the connection class name, supported protocols, and any connection configuration details. name: oef author: fetchai version: 0.1 . 0 license: Apache -2.0 fingerprint: \"\" description: \"The oef connection provides a wrapper around the OEF SDK for connection with the OEF search and communication node.\" class_name: OEFConnection protocols: [ \"fetchai/oef_search:0.1.0\" , \"fetchai/fipa:0.1.0\" ] restricted_to_protocols: [] excluded_protocols: [ \"fetchai/gym:0.1.0\" ] config: addr: $ { OEF_ADDR:127.0.0.1 } port: $ { OEF_PORT:10000 } dependencies: colorlog: {} oef: version: == 0.8 . 1 The developer is left to implement the methods of the Connection dependent on the protocol type.","title":"Connection"},{"location":"aea/connection/#configuration","text":"The connection.yaml file in the AEA directory contains protocol details and connection url and port details. For example, the oef connection.yaml contains the connection class name, supported protocols, and any connection configuration details. name: oef author: fetchai version: 0.1 . 0 license: Apache -2.0 fingerprint: \"\" description: \"The oef connection provides a wrapper around the OEF SDK for connection with the OEF search and communication node.\" class_name: OEFConnection protocols: [ \"fetchai/oef_search:0.1.0\" , \"fetchai/fipa:0.1.0\" ] restricted_to_protocols: [] excluded_protocols: [ \"fetchai/gym:0.1.0\" ] config: addr: $ { OEF_ADDR:127.0.0.1 } port: $ { OEF_PORT:10000 } dependencies: colorlog: {} oef: version: == 0.8 . 1 The developer is left to implement the methods of the Connection dependent on the protocol type.","title":"Configuration"},{"location":"aea/core-components/","text":"Multiplexer The Multiplexer is responsible for maintaining potentially multiple connections. Connection Connections wrap an external SDK or API and manage messaging. As such, they allow the agent to connect to an external service with an exposed Python SDK/API. The module connections/base.py contains the abstract class which defines a Connection . A Connection acts as a bridge to the SDK or API to be wrapped, and is, where necessary, responsible for translating between the framework specific Envelope with its contained Message and the external service. The framework provides one default connection: stub : implements an I/O reader and writer to send messages to the agent from a local file. InBox and OutBox The InBox and OutBox are, respectively, queues for incoming and outgoing Envelopes . They are needed to separate the thread which runs the Multiplexer from the thread which runs the main agent loop. Envelope An Envelope is the core object with which agents communicate. It travels from OutBox to another agent or gets translated in the Connection to an external service or protocol. Envelope objects sent from other agents arrive in the InBox via a Connection . An Envelope is a vehicle for messages with five attribute parameters: to : defines the destination address. sender : defines the sender address. protocol_id : defines the id of the protocol. message : is a bytes field which holds the message in serialized form. Optional[context] : an optional field to specify routing information in a URI. Protocol Protocols define how messages are represented and encoded for transport. They also define the rules to which messages have to adhere in a message sequence. For instance, a protocol may contain messages of type START and FINISH . From there, the rules may prescribe that a message of type FINISH must be preceded by a message of type START . The Message class in the protocols/base.py module provides an abstract class with all the functionality a derived Protocol message class requires for a custom protocol, such as basic message generating and management functions and serialisation details. The framework provides one default protocol: default : this protocol provides a bare bones implementation for an AEA protocol which includes a DefaultMessage class and a DefaultSerialization class with functions for managing serialisation. Use this protocol as a starting point for building custom protocols. Additional protocols can be added as packages, including: oef_search : this protocol provides the AEA protocol implementation for communication with the OEF search node including an OefSearchMessage class for hooking up to OEF search node services and search agents. Utility classes are available in the models.py module which provides OEF search node specific requirements, such as classes, needed to perform querying on the OEF search node , such as Description , Query , and Constraint , to name a few. fipa : this protocol provides classes and functions necessary for communication between AEAs via a variant of the FIPA Agent Communication Language. For example, the FipaMessage class provides negotiation terms such as cfp , propose , decline , accept and match_accept . Skill Skills are a result of the framework's extensibility. They are self-contained capabilities that AEAs can dynamically take on board, in order to expand their effectiveness in different situations. A skill can be given permission to read the internal state of the the AEA, and suggest action(s) to the AEA according to its specific logic. As such, more than one skill could exist per protocol, competing with each other in suggesting to the AEA the best course of actions to take. For instance, an AEA who is trading goods, could subscribe to more than one skill, where each skill corresponds to a different trading strategy. The skills could then read the internal state of the AEA, and independently suggest profitable transactions. A skill encapsulates implementations of the abstract base classes Handler , Behaviour , and Task : Handler : each skill has none, one or more Handler objects, each responsible for the registered messaging protocol. Handlers implement AEAs' reactive behaviour. If the AEA understands the protocol referenced in a received Envelope , the Handler reacts appropriately to the corresponding message. Each Handler is responsible for only one protocol. A Handler is also capable of dealing with internal messages. Behaviour : none, one or more Behaviours encapsulate actions that cause interactions with other agents initiated by the AEA. Behaviours implement AEAs' pro-activeness. Task : none, one or more Tasks encapsulate background work internal to the AEA. Skills further allow for Models . Classes that inherit from the Model can be accessed via the SkillContext . Agent Main loop The _run_main_loop() function in the Agent class performs a series of activities while the Agent state is not stopped. act() : this function calls the act() function of all active registered Behaviours. react() : this function grabs all Envelopes waiting in the InBox queue and calls the handle() function for the Handlers currently registered against the protocol of the Envelope . update() : this function dispatches the internal messages from the decision maker to the handler in the relevant skill. Decision maker The DecisionMaker component manages global agent state updates proposed by the skills and processes the resulting ledger transactions. It is responsible for the AEA's crypto-economic security and goal management, and it contains the preference and ownership representation of the AEA. TransactionMessage and StateUpdateMessage Skills communicate with the decision maker via InternalMessages . There exist two types of these: TransactionMessage and StateUpdateMessage . The StateUpdateMessage is used to initialize the decision maker with preferences and ownership states. It can also be used to update the ownership states in the decision maker if the settlement of transaction takes place off chain. The TransactionMessage is used by a skill to propose a transaction to the decision maker. The performative TransactionMessage.Performative.PROPOSE_FOR_SETTLEMENT is used by a skill to propose a transaction which the decision maker is supposed to settle on chain. The performative TransactionMessage.Performative.PROPOSE_FOR_SIGNING is used by the skill to propose a transaction which the decision maker is supposed to sign and which will be settled later. The decision maker processes messages and can accept or reject them. Note For examples how to use these concepts have a look at the `tac_` skills. These functionalities are experimental and subject to change. Filter Filter routes messages to the correct Handler via Resource . It also holds a reference to the currently active Behaviour and Task instances. By default for every skill, each Handler , Behaviour and Task is registered in the Filter . However, note that skills can de-active and re-activate themselves. The Filter also routes internal messages from the DecisionMaker to the respective Handler in the skills. Resource The Resource component is made up of Registries for each type of resource (e.g. Protocol , Handler , Behaviour , Task ). Message Envelopes travel through the Filter which in turn fetches the correct Handler from the Registry . Specific Registry classes are in the registries/base.py module. ProtocolRegistry . HandlerRegistry . BehaviourRegistry . TaskRegistry .","title":"Core components"},{"location":"aea/core-components/#multiplexer","text":"The Multiplexer is responsible for maintaining potentially multiple connections.","title":"Multiplexer"},{"location":"aea/core-components/#connection","text":"Connections wrap an external SDK or API and manage messaging. As such, they allow the agent to connect to an external service with an exposed Python SDK/API. The module connections/base.py contains the abstract class which defines a Connection . A Connection acts as a bridge to the SDK or API to be wrapped, and is, where necessary, responsible for translating between the framework specific Envelope with its contained Message and the external service. The framework provides one default connection: stub : implements an I/O reader and writer to send messages to the agent from a local file.","title":"Connection"},{"location":"aea/core-components/#inbox-and-outbox","text":"The InBox and OutBox are, respectively, queues for incoming and outgoing Envelopes . They are needed to separate the thread which runs the Multiplexer from the thread which runs the main agent loop.","title":"InBox and OutBox"},{"location":"aea/core-components/#envelope","text":"An Envelope is the core object with which agents communicate. It travels from OutBox to another agent or gets translated in the Connection to an external service or protocol. Envelope objects sent from other agents arrive in the InBox via a Connection . An Envelope is a vehicle for messages with five attribute parameters: to : defines the destination address. sender : defines the sender address. protocol_id : defines the id of the protocol. message : is a bytes field which holds the message in serialized form. Optional[context] : an optional field to specify routing information in a URI.","title":"Envelope"},{"location":"aea/core-components/#protocol","text":"Protocols define how messages are represented and encoded for transport. They also define the rules to which messages have to adhere in a message sequence. For instance, a protocol may contain messages of type START and FINISH . From there, the rules may prescribe that a message of type FINISH must be preceded by a message of type START . The Message class in the protocols/base.py module provides an abstract class with all the functionality a derived Protocol message class requires for a custom protocol, such as basic message generating and management functions and serialisation details. The framework provides one default protocol: default : this protocol provides a bare bones implementation for an AEA protocol which includes a DefaultMessage class and a DefaultSerialization class with functions for managing serialisation. Use this protocol as a starting point for building custom protocols. Additional protocols can be added as packages, including: oef_search : this protocol provides the AEA protocol implementation for communication with the OEF search node including an OefSearchMessage class for hooking up to OEF search node services and search agents. Utility classes are available in the models.py module which provides OEF search node specific requirements, such as classes, needed to perform querying on the OEF search node , such as Description , Query , and Constraint , to name a few. fipa : this protocol provides classes and functions necessary for communication between AEAs via a variant of the FIPA Agent Communication Language. For example, the FipaMessage class provides negotiation terms such as cfp , propose , decline , accept and match_accept .","title":"Protocol"},{"location":"aea/core-components/#skill","text":"Skills are a result of the framework's extensibility. They are self-contained capabilities that AEAs can dynamically take on board, in order to expand their effectiveness in different situations. A skill can be given permission to read the internal state of the the AEA, and suggest action(s) to the AEA according to its specific logic. As such, more than one skill could exist per protocol, competing with each other in suggesting to the AEA the best course of actions to take. For instance, an AEA who is trading goods, could subscribe to more than one skill, where each skill corresponds to a different trading strategy. The skills could then read the internal state of the AEA, and independently suggest profitable transactions. A skill encapsulates implementations of the abstract base classes Handler , Behaviour , and Task : Handler : each skill has none, one or more Handler objects, each responsible for the registered messaging protocol. Handlers implement AEAs' reactive behaviour. If the AEA understands the protocol referenced in a received Envelope , the Handler reacts appropriately to the corresponding message. Each Handler is responsible for only one protocol. A Handler is also capable of dealing with internal messages. Behaviour : none, one or more Behaviours encapsulate actions that cause interactions with other agents initiated by the AEA. Behaviours implement AEAs' pro-activeness. Task : none, one or more Tasks encapsulate background work internal to the AEA. Skills further allow for Models . Classes that inherit from the Model can be accessed via the SkillContext .","title":"Skill"},{"location":"aea/core-components/#agent","text":"","title":"Agent"},{"location":"aea/core-components/#main-loop","text":"The _run_main_loop() function in the Agent class performs a series of activities while the Agent state is not stopped. act() : this function calls the act() function of all active registered Behaviours. react() : this function grabs all Envelopes waiting in the InBox queue and calls the handle() function for the Handlers currently registered against the protocol of the Envelope . update() : this function dispatches the internal messages from the decision maker to the handler in the relevant skill.","title":"Main loop"},{"location":"aea/core-components/#decision-maker","text":"The DecisionMaker component manages global agent state updates proposed by the skills and processes the resulting ledger transactions. It is responsible for the AEA's crypto-economic security and goal management, and it contains the preference and ownership representation of the AEA.","title":"Decision maker"},{"location":"aea/core-components/#transactionmessage-and-stateupdatemessage","text":"Skills communicate with the decision maker via InternalMessages . There exist two types of these: TransactionMessage and StateUpdateMessage . The StateUpdateMessage is used to initialize the decision maker with preferences and ownership states. It can also be used to update the ownership states in the decision maker if the settlement of transaction takes place off chain. The TransactionMessage is used by a skill to propose a transaction to the decision maker. The performative TransactionMessage.Performative.PROPOSE_FOR_SETTLEMENT is used by a skill to propose a transaction which the decision maker is supposed to settle on chain. The performative TransactionMessage.Performative.PROPOSE_FOR_SIGNING is used by the skill to propose a transaction which the decision maker is supposed to sign and which will be settled later. The decision maker processes messages and can accept or reject them. Note For examples how to use these concepts have a look at the `tac_` skills. These functionalities are experimental and subject to change.","title":"TransactionMessage and StateUpdateMessage"},{"location":"aea/core-components/#filter","text":"Filter routes messages to the correct Handler via Resource . It also holds a reference to the currently active Behaviour and Task instances. By default for every skill, each Handler , Behaviour and Task is registered in the Filter . However, note that skills can de-active and re-activate themselves. The Filter also routes internal messages from the DecisionMaker to the respective Handler in the skills.","title":"Filter"},{"location":"aea/core-components/#resource","text":"The Resource component is made up of Registries for each type of resource (e.g. Protocol , Handler , Behaviour , Task ). Message Envelopes travel through the Filter which in turn fetches the correct Handler from the Registry . Specific Registry classes are in the registries/base.py module. ProtocolRegistry . HandlerRegistry . BehaviourRegistry . TaskRegistry .","title":"Resource"},{"location":"aea/decision-maker-transaction/","text":"This guide can be considered as a part 2 of the the stand-alone transaction demo we did in a previous guide. After the completion of the transaction, we get the transaction digest. With this we can search for the transaction on the block explorer . The main difference is that now we are going to use the decision-maker to settle the transaction. First, import the libraries and the set the constant values. import logging import time from threading import Thread from typing import Optional , cast from aea.aea import AEA from aea.configurations.base import ProtocolId , PublicId from aea.connections.stub.connection import StubConnection from aea.crypto.fetchai import FETCHAI from aea.crypto.helpers import _create_fetchai_private_key , _try_generate_testnet_wealth from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet from aea.decision_maker.messages.transaction import TransactionMessage from aea.identity.base import Identity from aea.protocols.base import Message from aea.registries.base import Resources from aea.skills.base import Handler logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( level = logging . INFO ) FETCHAI_PRIVATE_KEY_FILE_1 = \"fet_private_key_1.txt\" FETCHAI_PRIVATE_KEY_FILE_2 = \"fet_private_key_2.txt\" INPUT_FILE = \"input.txt\" OUTPUT_FILE = \"output.txt\" Create the private keys Then, create the private key files. # Create a private keys _create_fetchai_private_key ( private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) _create_fetchai_private_key ( private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 ) Create the wallets Once we created the private keys we need to generate the wallets. # Set up the wallets wallet_1 = Wallet ({ FETCHAI : FETCHAI_PRIVATE_KEY_FILE_1 }) wallet_2 = Wallet ({ FETCHAI : FETCHAI_PRIVATE_KEY_FILE_2 }) Generate wealth Since we want to send funds from wallet_1 to wallet_2 , we need to generate some wealth for the wallet_1 . We can do this with the following code # Generate some wealth _try_generate_testnet_wealth ( FETCHAI , wallet_1 . addresses [ FETCHAI ]) Create LedgerApis We need to create the LedgerApis object to be able to interact with the Fetch.ai testnet # Set up the LedgerApis ledger_apis = LedgerApis ({ FETCHAI : { \"network\" : \"testnet\" }}, FETCHAI ) Create the aea To have access to the decision-maker, we need to create an AEA. An AEA constructor needs some variables to be passed AEA(Identity, Connection, Wallet, LedgerApis, Resources) So let's create these dependencies before we instantiate the AEA. tx_handler = TransactionHandler ( skill_context = \"skill_context\" , name = \"fake_skill\" ) resources = Resources () resources . handler_registry . register ( ( PublicId . from_str ( \"fetchai/fake_skill:0.1.0\" ), PublicId . from_str ( \"fetchai/internal:0.1.0\" ), ), tx_handler , ) stub_connection = StubConnection ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE ) We need to create an identity for our AEA and the counterparty since the only one who must have access to the wallet is the decision-maker. identity_1 = Identity ( name = \"my_aea\" , address = wallet_1 . addresses . get ( FETCHAI ), default_address_key = FETCHAI , ) identity_2 = Identity ( name = \"my_aea_2\" , address = wallet_2 . addresses . get ( FETCHAI ), default_address_key = FETCHAI , ) Finally create the AEA , and the ledger_api # create the AEA my_aea = AEA ( identity_1 , [ stub_connection ], wallet_1 , ledger_apis , resources ) ledger_api = ledger_apis . apis [ FETCHAI ] Create the transaction message Next, we are creating the transaction message and we send it to the decision-maker. tx_nonce = ledger_api . generate_tx_nonce ( identity_1 . addresses . get ( FETCHAI ), identity_2 . addresses . get ( FETCHAI ) ) tx_msg = TransactionMessage ( performative = TransactionMessage . Performative . PROPOSE_FOR_SETTLEMENT , skill_callback_ids = [ PublicId ( \"fetchai\" , \"fake_skill\" , \"0.1.0\" )], tx_id = \"transaction0\" , tx_sender_addr = identity_1 . addresses . get ( FETCHAI ), tx_counterparty_addr = identity_2 . addresses . get ( FETCHAI ), tx_amount_by_currency_id = { \"FET\" : - 1 }, tx_sender_fee = 1 , tx_counterparty_fee = 0 , tx_quantities_by_good_id = {}, ledger_id = FETCHAI , info = { \"some_info_key\" : \"some_info_value\" }, tx_nonce = tx_nonce , ) my_aea . context . decision_maker_message_queue . put_nowait ( tx_msg ) Run the agent Finally, we are running the agent and we expect the transaction digest to be printed in the terminal. # Set the AEA running in a different thread try : logger . info ( \"STARTING AEA NOW!\" ) t = Thread ( target = my_aea . start ) t . start () # Let it run long enough to interact with the weather station time . sleep ( 20 ) finally : # Shut down the AEA logger . info ( \"STOPPING AEA NOW!\" ) my_aea . stop () t . join () More details To be able to register a handler that reads the internal messages, we have to create a class at the end of the file with the name TransactionHandler class TransactionHandler ( Handler ): \"\"\"Implement the transaction handler.\"\"\" SUPPORTED_PROTOCOL = TransactionMessage . protocol_id # type: Optional[ProtocolId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" tx_msg_response = cast ( TransactionMessage , message ) logger . info ( tx_msg_response ) if ( tx_msg_response is not None and tx_msg_response . performative == TransactionMessage . Performative . SUCCESSFUL_SETTLEMENT ): logger . info ( \"Transaction was successful.\" ) logger . info ( tx_msg_response . tx_digest ) else : logger . info ( \"Transaction was not successful.\" ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass You can find the full code for this example below: Transaction via decision-maker full code import logging import time from threading import Thread from typing import Optional , cast from aea.aea import AEA from aea.configurations.base import ProtocolId , PublicId from aea.connections.stub.connection import StubConnection from aea.crypto.fetchai import FETCHAI from aea.crypto.helpers import _create_fetchai_private_key , _try_generate_testnet_wealth from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet from aea.decision_maker.messages.transaction import TransactionMessage from aea.identity.base import Identity from aea.protocols.base import Message from aea.registries.base import Resources from aea.skills.base import Handler logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( level = logging . INFO ) FETCHAI_PRIVATE_KEY_FILE_1 = \"fet_private_key_1.txt\" FETCHAI_PRIVATE_KEY_FILE_2 = \"fet_private_key_2.txt\" INPUT_FILE = \"input.txt\" OUTPUT_FILE = \"output.txt\" def run (): # Create a private keys _create_fetchai_private_key ( private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) _create_fetchai_private_key ( private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 ) # Set up the wallets wallet_1 = Wallet ({ FETCHAI : FETCHAI_PRIVATE_KEY_FILE_1 }) wallet_2 = Wallet ({ FETCHAI : FETCHAI_PRIVATE_KEY_FILE_2 }) # Generate some wealth _try_generate_testnet_wealth ( FETCHAI , wallet_1 . addresses [ FETCHAI ]) # Set up the LedgerApis ledger_apis = LedgerApis ({ FETCHAI : { \"network\" : \"testnet\" }}, FETCHAI ) tx_handler = TransactionHandler ( skill_context = \"skill_context\" , name = \"fake_skill\" ) resources = Resources () resources . handler_registry . register ( ( PublicId . from_str ( \"fetchai/fake_skill:0.1.0\" ), PublicId . from_str ( \"fetchai/internal:0.1.0\" ), ), tx_handler , ) stub_connection = StubConnection ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE ) identity_1 = Identity ( name = \"my_aea\" , address = wallet_1 . addresses . get ( FETCHAI ), default_address_key = FETCHAI , ) identity_2 = Identity ( name = \"my_aea_2\" , address = wallet_2 . addresses . get ( FETCHAI ), default_address_key = FETCHAI , ) # create the AEA my_aea = AEA ( identity_1 , [ stub_connection ], wallet_1 , ledger_apis , resources ) ledger_api = ledger_apis . apis [ FETCHAI ] tx_nonce = ledger_api . generate_tx_nonce ( identity_1 . addresses . get ( FETCHAI ), identity_2 . addresses . get ( FETCHAI ) ) tx_msg = TransactionMessage ( performative = TransactionMessage . Performative . PROPOSE_FOR_SETTLEMENT , skill_callback_ids = [ PublicId ( \"fetchai\" , \"fake_skill\" , \"0.1.0\" )], tx_id = \"transaction0\" , tx_sender_addr = identity_1 . addresses . get ( FETCHAI ), tx_counterparty_addr = identity_2 . addresses . get ( FETCHAI ), tx_amount_by_currency_id = { \"FET\" : - 1 }, tx_sender_fee = 1 , tx_counterparty_fee = 0 , tx_quantities_by_good_id = {}, ledger_id = FETCHAI , info = { \"some_info_key\" : \"some_info_value\" }, tx_nonce = tx_nonce , ) my_aea . context . decision_maker_message_queue . put_nowait ( tx_msg ) # Set the AEA running in a different thread try : logger . info ( \"STARTING AEA NOW!\" ) t = Thread ( target = my_aea . start ) t . start () # Let it run long enough to interact with the weather station time . sleep ( 20 ) finally : # Shut down the AEA logger . info ( \"STOPPING AEA NOW!\" ) my_aea . stop () t . join () class TransactionHandler ( Handler ): \"\"\"Implement the transaction handler.\"\"\" SUPPORTED_PROTOCOL = TransactionMessage . protocol_id # type: Optional[ProtocolId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" tx_msg_response = cast ( TransactionMessage , message ) logger . info ( tx_msg_response ) if ( tx_msg_response is not None and tx_msg_response . performative == TransactionMessage . Performative . SUCCESSFUL_SETTLEMENT ): logger . info ( \"Transaction was successful.\" ) logger . info ( tx_msg_response . tx_digest ) else : logger . info ( \"Transaction was not successful.\" ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass if __name__ == \"__main__\" : run ()","title":"Create decision-maker transaction"},{"location":"aea/decision-maker-transaction/#create-the-private-keys","text":"Then, create the private key files. # Create a private keys _create_fetchai_private_key ( private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) _create_fetchai_private_key ( private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 )","title":"Create the private keys"},{"location":"aea/decision-maker-transaction/#create-the-wallets","text":"Once we created the private keys we need to generate the wallets. # Set up the wallets wallet_1 = Wallet ({ FETCHAI : FETCHAI_PRIVATE_KEY_FILE_1 }) wallet_2 = Wallet ({ FETCHAI : FETCHAI_PRIVATE_KEY_FILE_2 })","title":"Create the wallets"},{"location":"aea/decision-maker-transaction/#generate-wealth","text":"Since we want to send funds from wallet_1 to wallet_2 , we need to generate some wealth for the wallet_1 . We can do this with the following code # Generate some wealth _try_generate_testnet_wealth ( FETCHAI , wallet_1 . addresses [ FETCHAI ])","title":"Generate wealth"},{"location":"aea/decision-maker-transaction/#create-ledgerapis","text":"We need to create the LedgerApis object to be able to interact with the Fetch.ai testnet # Set up the LedgerApis ledger_apis = LedgerApis ({ FETCHAI : { \"network\" : \"testnet\" }}, FETCHAI )","title":"Create LedgerApis"},{"location":"aea/decision-maker-transaction/#create-the-aea","text":"To have access to the decision-maker, we need to create an AEA. An AEA constructor needs some variables to be passed AEA(Identity, Connection, Wallet, LedgerApis, Resources) So let's create these dependencies before we instantiate the AEA. tx_handler = TransactionHandler ( skill_context = \"skill_context\" , name = \"fake_skill\" ) resources = Resources () resources . handler_registry . register ( ( PublicId . from_str ( \"fetchai/fake_skill:0.1.0\" ), PublicId . from_str ( \"fetchai/internal:0.1.0\" ), ), tx_handler , ) stub_connection = StubConnection ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE ) We need to create an identity for our AEA and the counterparty since the only one who must have access to the wallet is the decision-maker. identity_1 = Identity ( name = \"my_aea\" , address = wallet_1 . addresses . get ( FETCHAI ), default_address_key = FETCHAI , ) identity_2 = Identity ( name = \"my_aea_2\" , address = wallet_2 . addresses . get ( FETCHAI ), default_address_key = FETCHAI , ) Finally create the AEA , and the ledger_api # create the AEA my_aea = AEA ( identity_1 , [ stub_connection ], wallet_1 , ledger_apis , resources ) ledger_api = ledger_apis . apis [ FETCHAI ]","title":"Create the aea"},{"location":"aea/decision-maker-transaction/#create-the-transaction-message","text":"Next, we are creating the transaction message and we send it to the decision-maker. tx_nonce = ledger_api . generate_tx_nonce ( identity_1 . addresses . get ( FETCHAI ), identity_2 . addresses . get ( FETCHAI ) ) tx_msg = TransactionMessage ( performative = TransactionMessage . Performative . PROPOSE_FOR_SETTLEMENT , skill_callback_ids = [ PublicId ( \"fetchai\" , \"fake_skill\" , \"0.1.0\" )], tx_id = \"transaction0\" , tx_sender_addr = identity_1 . addresses . get ( FETCHAI ), tx_counterparty_addr = identity_2 . addresses . get ( FETCHAI ), tx_amount_by_currency_id = { \"FET\" : - 1 }, tx_sender_fee = 1 , tx_counterparty_fee = 0 , tx_quantities_by_good_id = {}, ledger_id = FETCHAI , info = { \"some_info_key\" : \"some_info_value\" }, tx_nonce = tx_nonce , ) my_aea . context . decision_maker_message_queue . put_nowait ( tx_msg )","title":"Create the transaction message"},{"location":"aea/decision-maker-transaction/#run-the-agent","text":"Finally, we are running the agent and we expect the transaction digest to be printed in the terminal. # Set the AEA running in a different thread try : logger . info ( \"STARTING AEA NOW!\" ) t = Thread ( target = my_aea . start ) t . start () # Let it run long enough to interact with the weather station time . sleep ( 20 ) finally : # Shut down the AEA logger . info ( \"STOPPING AEA NOW!\" ) my_aea . stop () t . join ()","title":"Run the agent"},{"location":"aea/decision-maker-transaction/#more-details","text":"To be able to register a handler that reads the internal messages, we have to create a class at the end of the file with the name TransactionHandler class TransactionHandler ( Handler ): \"\"\"Implement the transaction handler.\"\"\" SUPPORTED_PROTOCOL = TransactionMessage . protocol_id # type: Optional[ProtocolId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" tx_msg_response = cast ( TransactionMessage , message ) logger . info ( tx_msg_response ) if ( tx_msg_response is not None and tx_msg_response . performative == TransactionMessage . Performative . SUCCESSFUL_SETTLEMENT ): logger . info ( \"Transaction was successful.\" ) logger . info ( tx_msg_response . tx_digest ) else : logger . info ( \"Transaction was not successful.\" ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass You can find the full code for this example below: Transaction via decision-maker full code import logging import time from threading import Thread from typing import Optional , cast from aea.aea import AEA from aea.configurations.base import ProtocolId , PublicId from aea.connections.stub.connection import StubConnection from aea.crypto.fetchai import FETCHAI from aea.crypto.helpers import _create_fetchai_private_key , _try_generate_testnet_wealth from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet from aea.decision_maker.messages.transaction import TransactionMessage from aea.identity.base import Identity from aea.protocols.base import Message from aea.registries.base import Resources from aea.skills.base import Handler logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( level = logging . INFO ) FETCHAI_PRIVATE_KEY_FILE_1 = \"fet_private_key_1.txt\" FETCHAI_PRIVATE_KEY_FILE_2 = \"fet_private_key_2.txt\" INPUT_FILE = \"input.txt\" OUTPUT_FILE = \"output.txt\" def run (): # Create a private keys _create_fetchai_private_key ( private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) _create_fetchai_private_key ( private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 ) # Set up the wallets wallet_1 = Wallet ({ FETCHAI : FETCHAI_PRIVATE_KEY_FILE_1 }) wallet_2 = Wallet ({ FETCHAI : FETCHAI_PRIVATE_KEY_FILE_2 }) # Generate some wealth _try_generate_testnet_wealth ( FETCHAI , wallet_1 . addresses [ FETCHAI ]) # Set up the LedgerApis ledger_apis = LedgerApis ({ FETCHAI : { \"network\" : \"testnet\" }}, FETCHAI ) tx_handler = TransactionHandler ( skill_context = \"skill_context\" , name = \"fake_skill\" ) resources = Resources () resources . handler_registry . register ( ( PublicId . from_str ( \"fetchai/fake_skill:0.1.0\" ), PublicId . from_str ( \"fetchai/internal:0.1.0\" ), ), tx_handler , ) stub_connection = StubConnection ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE ) identity_1 = Identity ( name = \"my_aea\" , address = wallet_1 . addresses . get ( FETCHAI ), default_address_key = FETCHAI , ) identity_2 = Identity ( name = \"my_aea_2\" , address = wallet_2 . addresses . get ( FETCHAI ), default_address_key = FETCHAI , ) # create the AEA my_aea = AEA ( identity_1 , [ stub_connection ], wallet_1 , ledger_apis , resources ) ledger_api = ledger_apis . apis [ FETCHAI ] tx_nonce = ledger_api . generate_tx_nonce ( identity_1 . addresses . get ( FETCHAI ), identity_2 . addresses . get ( FETCHAI ) ) tx_msg = TransactionMessage ( performative = TransactionMessage . Performative . PROPOSE_FOR_SETTLEMENT , skill_callback_ids = [ PublicId ( \"fetchai\" , \"fake_skill\" , \"0.1.0\" )], tx_id = \"transaction0\" , tx_sender_addr = identity_1 . addresses . get ( FETCHAI ), tx_counterparty_addr = identity_2 . addresses . get ( FETCHAI ), tx_amount_by_currency_id = { \"FET\" : - 1 }, tx_sender_fee = 1 , tx_counterparty_fee = 0 , tx_quantities_by_good_id = {}, ledger_id = FETCHAI , info = { \"some_info_key\" : \"some_info_value\" }, tx_nonce = tx_nonce , ) my_aea . context . decision_maker_message_queue . put_nowait ( tx_msg ) # Set the AEA running in a different thread try : logger . info ( \"STARTING AEA NOW!\" ) t = Thread ( target = my_aea . start ) t . start () # Let it run long enough to interact with the weather station time . sleep ( 20 ) finally : # Shut down the AEA logger . info ( \"STOPPING AEA NOW!\" ) my_aea . stop () t . join () class TransactionHandler ( Handler ): \"\"\"Implement the transaction handler.\"\"\" SUPPORTED_PROTOCOL = TransactionMessage . protocol_id # type: Optional[ProtocolId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" tx_msg_response = cast ( TransactionMessage , message ) logger . info ( tx_msg_response ) if ( tx_msg_response is not None and tx_msg_response . performative == TransactionMessage . Performative . SUCCESSFUL_SETTLEMENT ): logger . info ( \"Transaction was successful.\" ) logger . info ( tx_msg_response . tx_digest ) else : logger . info ( \"Transaction was not successful.\" ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass if __name__ == \"__main__\" : run ()","title":"More details"},{"location":"aea/deployment/","text":"Note This section is incomplete and will soon be updated. The easiest way to run an AEA is using your development environment. If you would like to run an AEA from a browser you can use Google Colab . This gist can be opened in Colab and implements the quickstart .","title":"Deployment"},{"location":"aea/design-principles/","text":"Eight principles guide AEA framework development: Accessibility : ease of use. Modularity : encourages module creation, sharing and reuse. Openness : easily extensible with third-party libraries. Conciseness : conceptually simple. Value-driven : drives immediate value. Low entry barriers : leverages existing programming languages and web protocols. Safety : safe for the user (economically speaking). Goal-alignment : seamless facilitation of users' preferences and goals.","title":"Design principles"},{"location":"aea/diagram/","text":"Note Work in progress. The framework has two distinctive parts. A core that is developed by the Fetch.ai team as well as external contributors. Extensions (also known as packages ) developed by any developer which promotes a modular and scalable framework. Currently, the framework supports three types of packages which can be added to the core as modules: Skills Protocols Connections The following figure illustrates the framework's architecture: In most cases, as a developer in the AEA framework, it is sufficient to focus on skills development, utilising existing protocols and connections. The later doesn't try to discourage you though, from creating your own connections or protocols but you will need a better understanding of the framework than creating a skill. The agent operation breaks down into three parts: Setup: calls the setup() method of all registered resources Operation: Main loop (Thread 1 - Synchronous): react() : this function grabs all Envelopes waiting in the InBox queue and calls the handle() function on the Handler(s) responsible for them. act() : this function calls the act() function of all registered Behaviours. update() : this function enqueues scheduled tasks for execution with the TaskManager. Task loop (Thread 2- Synchronous): executes available tasks Decision maker loop (Thread 3- Synchronous): processes internal messages Multiplexer (Thread 4 - Asynchronous event loop): the multiplexer has an event loop which processes incoming and outgoing messages across several connections asynchronously. Teardown: calls the teardown() method of all registered resources","title":"Architectural diagram"},{"location":"aea/file-structure/","text":"The file structure of an AEA is fixed. The top level directory has the AEA's name. Below is a yaml configuration file, then directories containing the connections, protocols, and skills developed by the developer. The connections, protocols and skills from other authors are located in vendor and sorted by author. Finally, there are files containing the private keys of the AEA. The developer can create new directories where necessary but the core structure must remain the same. The CLI tool provides a way to scaffold new connections, protocols and skills in the required directory structure for AEAs. See the instructions for that here . aea_name/ aea-config.yaml YAML configuration of the AEA private_key.pem The private key file connections/ Directory containing all the own connections connection_1/ First connection ... ... connection_n/ nth connection protocols/ Directory containing all own protocols protocol_1/ First protocol ... ... protocol_m/ mth protocol skills/ Directory containing all the own skills skill_1/ First skill ... ... skill_k/ kth skill vendor/ Directory containing all the added resources authored by other developers author_1/ Directory containing all the resources added from author_1 connections/ Directory containing all the added connections from author_1 ... ... protocols/ Directory containing all the added protocols from author_1 ... ... skills/ Directory containing all the added skills from author_1 ... ...","title":"File structure"},{"location":"aea/generic-skills/","text":"The AEA generic buyer and seller skills demonstrate an interaction between two AEAs. The provider of a service in the form of data for sale. The buyer of a service. Discussion The scope of the specific demo is to demonstrate how to create an easy configurable AEA. The seller AEA will sell the service specified in the skill.yaml file and deliver it upon payment by the buyer. Adding a database or hardware sensor for loading the data is out of the scope of this demo. As a result, the AEA can provide data that are listed in the skill.yaml file. This demo does not utilize a smart contract. We interact with a ledger only to complete a transaction. Moreover, this example provides a way to customise the skill code and connect a database or sensor. You can modify the has_data_source variable in skill.yaml file of the generic_seller skill to True. Then you have to implement the method collect_from_data_source(self) inside the strategy.py file. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Launch an OEF search and communication node In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for all the following demos. Demo: Ledger payment A demo to run a scenario with a true ledger transaction on Fetch.ai testnet network or Ethereum ropsten network. This demo assumes the buyer trusts the seller AEA to send the data upon successful payment. Create the seller AEA (ledger version) Create the AEA that will provide data. aea create my_seller_aea cd my_seller_aea aea add connection fetchai/oef:0.1.0 aea add skill fetchai/generic_seller:0.1.0 aea install Create the buyer client (ledger version) In another terminal, create the AEA that will query the seller AEA. aea create my_buyer_aea cd my_buyer_aea aea add connection fetchai/oef:0.1.0 aea add skill fetchai/generic_buyer:0.1.0 aea install Additionally, create the private key for the buyer AEA based on the network you want to transact. To generate and add a key for Fetch.ai use: aea generate-key fetchai aea add-key fetchai fet_private_key.txt To generate and add a key for Ethereum use: aea generate-key ethereum aea add-key ethereum eth_private_key.txt Update the AEA configs Both in my_seller_aea/aea-config.yaml and my_buyer_aea/aea-config.yaml , replace ledger_apis: {} with the following based on the network you want to connect To connect to Fetchai: ledger_apis : fetchai : network : testnet To connect to Ethereum: ledger_apis : ethereum : address : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 gas_price : 50 Update the seller AEA skill configs In my_seller_aea/vendor/fetchai/skills/generi_seller/skill.yaml , replace the data_for_sale , search_schema , and search_data with your data: | ----------------------------------------------------------------------| | FETCHAI | ETHEREUM | | -----------------------------------|----------------------------------| |models : |models : | | strategy : | strategy : | | class_name : Strategy | class_name : Strategy | | args : | args : | | total_price : 10 | total_price : 10 | | seller_tx_fee : 0 | seller_tx_fee : 0 | | currency_id : 'FET' | currency_id : 'ETH' | | ledger_id : 'fetchai' | ledger_id : 'ethereum' | | is_ledger_tx : True | is_ledger_tx : True | | has_data_source : False | has_data_source : False | | data_for_sale : | data_for_sale : | | wind : 10 | wind : 10 | | pressure : 20 | pressure : 20 | | temperature : 26 | temperature : 26 | | search_schema : | search_schema : | | attribute_one : | attribute_one : | | name : country | name : country | | type : str | type : str | | is_required : True | is_required : True | | attribute_two : | attribute_two : | | name : city | name : city | | type : str | type : str | | is_required : True | is_required : True | | search_data : | search_data : | | country : UK | country : UK | | city : Cambridge | city : Cambridge | | ----------------------------------------------------------------------| The search_schema and the search_data are used to register the service in the OEF search node . and make your agent discoverable. The name of each attribute must be a key in the search_data dictionary. In the generic buyer skill config ( my_buyer_aea/vendor/fetchai/skills/generic_buyer/skill.yaml ) under strategy change the currency_id , ledger_id , and at the bottom of the file the ledgers . | ----------------------------------------------------------------------| | FETCHAI | ETHEREUM | | -----------------------------------|----------------------------------| |models : |models : | | strategy : | strategy : | | class_name : Strategy | class_name : Strategy | | args : | args : | | max_price : 4 | max_price : 40 | | max_buyer_tx_fee : 1 | max_buyer_tx_fee : 200000 | | currency_id : 'FET' | currency_id : 'ETH' | | ledger_id : 'fetchai' | ledger_id : 'ethereum' | | is_ledger_tx : True | is_ledger_tx : True | | search_query : | search_query : | | search_term : country | search_term : country | | search_value : UK | search_value : UK | | constraint_type : '==' | constraint_type : '==' | |ledgers : [ 'fetchai' ] |ledgers : [ 'ethereum' ] | | ----------------------------------------------------------------------| Fund the buyer AEA To create some wealth for your buyer AEA based on the network you want to transact with: On the Fetch.ai testnet network. aea generate-wealth fetchai On the Ethereum rospten network. aea generate-wealth ethereum Run the AEAs You can change the endpoint's address and port by modifying the connection's yaml file (my_seller_aea/connection/oef/connection.yaml) Under config locate : addr: ${ OEF_ADDR : 127.0.0.1 } and replace it with your ip (The ip of the machine that runs the oef image.) Run both AEAs from their respective terminals aea add connection fetchai/oef:0.1.0 aea install aea run --connections fetchai/oef:0.1.0 You will see that the AEAs negotiate and then transact using the Fetch.ai testnet. Delete the AEAs When you're done, go up a level and delete the AEAs. cd .. aea delete my_seller_aea aea delete my_buyer_aea Communication This diagram shows the communication between the various entities as data is successfully sold by the seller AEA to the buyer. sequenceDiagram participant Search participant Buyer_AEA participant Seller_AEA participant Blockchain activate Buyer_AEA activate Search activate Seller_AEA activate Blockchain Seller_AEA->>Search: register_service Buyer_AEA->>Search: search Search-->>Buyer_AEA: list_of_agents Buyer_AEA->>Seller_AEA: call_for_proposal Seller_AEA->>Buyer_AEA: propose Buyer_AEA->>Seller_AEA: accept Seller_AEA->>Buyer_AEA: match_accept Buyer_AEA->>Blockchain: transfer_funds Buyer_AEA->>Seller_AEA: send_transaction_hash Seller_AEA->>Blockchain: check_transaction_status Seller_AEA->>Buyer_AEA: send_data deactivate Buyer_AEA deactivate Search deactivate Seller_AEA deactivate Blockchain","title":"Generic skills"},{"location":"aea/generic-skills/#discussion","text":"The scope of the specific demo is to demonstrate how to create an easy configurable AEA. The seller AEA will sell the service specified in the skill.yaml file and deliver it upon payment by the buyer. Adding a database or hardware sensor for loading the data is out of the scope of this demo. As a result, the AEA can provide data that are listed in the skill.yaml file. This demo does not utilize a smart contract. We interact with a ledger only to complete a transaction. Moreover, this example provides a way to customise the skill code and connect a database or sensor. You can modify the has_data_source variable in skill.yaml file of the generic_seller skill to True. Then you have to implement the method collect_from_data_source(self) inside the strategy.py file.","title":"Discussion"},{"location":"aea/generic-skills/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/generic-skills/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/generic-skills/#launch-an-oef-search-and-communication-node","text":"In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for all the following demos.","title":"Launch an OEF search and communication node"},{"location":"aea/generic-skills/#demo-ledger-payment","text":"A demo to run a scenario with a true ledger transaction on Fetch.ai testnet network or Ethereum ropsten network. This demo assumes the buyer trusts the seller AEA to send the data upon successful payment.","title":"Demo: Ledger payment"},{"location":"aea/generic-skills/#create-the-seller-aea-ledger-version","text":"Create the AEA that will provide data. aea create my_seller_aea cd my_seller_aea aea add connection fetchai/oef:0.1.0 aea add skill fetchai/generic_seller:0.1.0 aea install","title":"Create the seller AEA (ledger version)"},{"location":"aea/generic-skills/#create-the-buyer-client-ledger-version","text":"In another terminal, create the AEA that will query the seller AEA. aea create my_buyer_aea cd my_buyer_aea aea add connection fetchai/oef:0.1.0 aea add skill fetchai/generic_buyer:0.1.0 aea install Additionally, create the private key for the buyer AEA based on the network you want to transact. To generate and add a key for Fetch.ai use: aea generate-key fetchai aea add-key fetchai fet_private_key.txt To generate and add a key for Ethereum use: aea generate-key ethereum aea add-key ethereum eth_private_key.txt","title":"Create the buyer client (ledger version)"},{"location":"aea/generic-skills/#update-the-aea-configs","text":"Both in my_seller_aea/aea-config.yaml and my_buyer_aea/aea-config.yaml , replace ledger_apis: {} with the following based on the network you want to connect To connect to Fetchai: ledger_apis : fetchai : network : testnet To connect to Ethereum: ledger_apis : ethereum : address : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 gas_price : 50","title":"Update the AEA configs"},{"location":"aea/generic-skills/#update-the-seller-aea-skill-configs","text":"In my_seller_aea/vendor/fetchai/skills/generi_seller/skill.yaml , replace the data_for_sale , search_schema , and search_data with your data: | ----------------------------------------------------------------------| | FETCHAI | ETHEREUM | | -----------------------------------|----------------------------------| |models : |models : | | strategy : | strategy : | | class_name : Strategy | class_name : Strategy | | args : | args : | | total_price : 10 | total_price : 10 | | seller_tx_fee : 0 | seller_tx_fee : 0 | | currency_id : 'FET' | currency_id : 'ETH' | | ledger_id : 'fetchai' | ledger_id : 'ethereum' | | is_ledger_tx : True | is_ledger_tx : True | | has_data_source : False | has_data_source : False | | data_for_sale : | data_for_sale : | | wind : 10 | wind : 10 | | pressure : 20 | pressure : 20 | | temperature : 26 | temperature : 26 | | search_schema : | search_schema : | | attribute_one : | attribute_one : | | name : country | name : country | | type : str | type : str | | is_required : True | is_required : True | | attribute_two : | attribute_two : | | name : city | name : city | | type : str | type : str | | is_required : True | is_required : True | | search_data : | search_data : | | country : UK | country : UK | | city : Cambridge | city : Cambridge | | ----------------------------------------------------------------------| The search_schema and the search_data are used to register the service in the OEF search node . and make your agent discoverable. The name of each attribute must be a key in the search_data dictionary. In the generic buyer skill config ( my_buyer_aea/vendor/fetchai/skills/generic_buyer/skill.yaml ) under strategy change the currency_id , ledger_id , and at the bottom of the file the ledgers . | ----------------------------------------------------------------------| | FETCHAI | ETHEREUM | | -----------------------------------|----------------------------------| |models : |models : | | strategy : | strategy : | | class_name : Strategy | class_name : Strategy | | args : | args : | | max_price : 4 | max_price : 40 | | max_buyer_tx_fee : 1 | max_buyer_tx_fee : 200000 | | currency_id : 'FET' | currency_id : 'ETH' | | ledger_id : 'fetchai' | ledger_id : 'ethereum' | | is_ledger_tx : True | is_ledger_tx : True | | search_query : | search_query : | | search_term : country | search_term : country | | search_value : UK | search_value : UK | | constraint_type : '==' | constraint_type : '==' | |ledgers : [ 'fetchai' ] |ledgers : [ 'ethereum' ] | | ----------------------------------------------------------------------|","title":"Update the seller AEA skill configs"},{"location":"aea/generic-skills/#fund-the-buyer-aea","text":"To create some wealth for your buyer AEA based on the network you want to transact with: On the Fetch.ai testnet network. aea generate-wealth fetchai On the Ethereum rospten network. aea generate-wealth ethereum","title":"Fund the buyer AEA"},{"location":"aea/generic-skills/#run-the-aeas","text":"You can change the endpoint's address and port by modifying the connection's yaml file (my_seller_aea/connection/oef/connection.yaml) Under config locate : addr: ${ OEF_ADDR : 127.0.0.1 } and replace it with your ip (The ip of the machine that runs the oef image.) Run both AEAs from their respective terminals aea add connection fetchai/oef:0.1.0 aea install aea run --connections fetchai/oef:0.1.0 You will see that the AEAs negotiate and then transact using the Fetch.ai testnet.","title":"Run the AEAs"},{"location":"aea/generic-skills/#delete-the-aeas","text":"When you're done, go up a level and delete the AEAs. cd .. aea delete my_seller_aea aea delete my_buyer_aea","title":"Delete the AEAs"},{"location":"aea/generic-skills/#communication","text":"This diagram shows the communication between the various entities as data is successfully sold by the seller AEA to the buyer. sequenceDiagram participant Search participant Buyer_AEA participant Seller_AEA participant Blockchain activate Buyer_AEA activate Search activate Seller_AEA activate Blockchain Seller_AEA->>Search: register_service Buyer_AEA->>Search: search Search-->>Buyer_AEA: list_of_agents Buyer_AEA->>Seller_AEA: call_for_proposal Seller_AEA->>Buyer_AEA: propose Buyer_AEA->>Seller_AEA: accept Seller_AEA->>Buyer_AEA: match_accept Buyer_AEA->>Blockchain: transfer_funds Buyer_AEA->>Seller_AEA: send_transaction_hash Seller_AEA->>Blockchain: check_transaction_status Seller_AEA->>Buyer_AEA: send_data deactivate Buyer_AEA deactivate Search deactivate Seller_AEA deactivate Blockchain","title":"Communication"},{"location":"aea/gym-example/","text":"The gym example demonstrates the AEA framework's flexibility with respect to Reinforcement Learning using OpenAI's gym framework. Discussion There is no immediate use case for this example as you can train an RL agent without the AEA proxy layer just fine (and faster). However, the example decouples the RL agent from the gym.Env allowing them to run in separate execution environments, potentially owned by different entities. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Install the gym and numpy library. pip install numpy gym Demo instructions Run the example python examples/gym_ex/train.py Notice the usual RL setup, i.e. the fit method of the RL agent has the typical signature and a familiar implementation. Note how train.py demonstrates how easy it is to use an AEA agent as a proxy layer between an OpenAI gym.Env and a standard RL agent. It is just one line of code to introduce the proxy agent and proxy environment! from gyms.env import BanditNArmedRandom from proxy.env import ProxyEnv from rl.agent import RLAgent if __name__ == \"__main__\" : NB_GOODS = 10 NB_PRICES_PER_GOOD = 100 NB_STEPS = 4000 # Use any gym.Env compatible environment: gym_env = BanditNArmedRandom ( nb_bandits = NB_GOODS , nb_prices_per_bandit = NB_PRICES_PER_GOOD ) # Pass the gym environment to a proxy environment: proxy_env = ProxyEnv ( gym_env ) # Use any RL agent compatible with the gym environment and call the fit method: rl_agent = RLAgent ( nb_goods = NB_GOODS ) rl_agent . fit ( env = proxy_env , nb_steps = NB_STEPS )","title":"Gym example"},{"location":"aea/gym-example/#discussion","text":"There is no immediate use case for this example as you can train an RL agent without the AEA proxy layer just fine (and faster). However, the example decouples the RL agent from the gym.Env allowing them to run in separate execution environments, potentially owned by different entities.","title":"Discussion"},{"location":"aea/gym-example/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/gym-example/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start. Install the gym and numpy library. pip install numpy gym","title":"Dependencies"},{"location":"aea/gym-example/#demo-instructions","text":"","title":"Demo instructions"},{"location":"aea/gym-example/#run-the-example","text":"python examples/gym_ex/train.py Notice the usual RL setup, i.e. the fit method of the RL agent has the typical signature and a familiar implementation. Note how train.py demonstrates how easy it is to use an AEA agent as a proxy layer between an OpenAI gym.Env and a standard RL agent. It is just one line of code to introduce the proxy agent and proxy environment! from gyms.env import BanditNArmedRandom from proxy.env import ProxyEnv from rl.agent import RLAgent if __name__ == \"__main__\" : NB_GOODS = 10 NB_PRICES_PER_GOOD = 100 NB_STEPS = 4000 # Use any gym.Env compatible environment: gym_env = BanditNArmedRandom ( nb_bandits = NB_GOODS , nb_prices_per_bandit = NB_PRICES_PER_GOOD ) # Pass the gym environment to a proxy environment: proxy_env = ProxyEnv ( gym_env ) # Use any RL agent compatible with the gym environment and call the fit method: rl_agent = RLAgent ( nb_goods = NB_GOODS ) rl_agent . fit ( env = proxy_env , nb_steps = NB_STEPS )","title":"Run the example"},{"location":"aea/gym-skill/","text":"The AEA gym skill demonstrates how a custom Reinforcement Learning agent, that uses OpenAI's gym library, may be embedded into an AEA skill and connection. Discussion The gym skills demonstrate how to wrap a Reinforcement Learning agent in a skill. The example decouples the RL agent from the gym.Env allowing them to run in separate execution environments, potentially owned by different entities. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Demo instructions Create the AEA In the root directory, create the gym AEA and enter the project. aea create my_gym_aea cd my_gym_aea Add the gym skill aea add skill fetchai/gym:0.1.0 Copy the gym environment to the AEA directory mkdir gyms cp -a ../examples/gym_ex/gyms/. gyms/ Add a gym connection aea add connection fetchai/gym:0.1.0 Update the connection config aea config set vendor.fetchai.connections.gym.config.env 'gyms.env.BanditNArmedRandom' Install the skill dependencies To install the gym package, a dependency of the gym skill, from Pypi run aea install Run the AEA with the gym connection aea run --connections fetchai/gym:0.1.0 You will see the gym training logs. Delete the AEA When you're done, you can go up a level and delete the AEA. cd .. aea delete my_gym_aea Communication This diagram shows the communication between the AEA and the gym environment sequenceDiagram participant AEA participant Environment activate AEA activate Environment AEA->>Environment: reset loop learn AEA->>Environment: act Environment->>AEA: percept end AEA->>Environment: close deactivate AEA deactivate Environment Skill Architecture The skill consists of two core components: GymHandler and GymTask . In the setup method of the GymHandler the GymTask is initialized, as well as its setup and execute methods called. The handler, which is registered against the GymMessage.protocol_id then filters for messages of that protocol with the performative GymMessage.Performative.PERCEPT . These messages are passed to the proxy_env_queue of the task. The GymTask is responsible for training the RL agent. In particular, MyRLAgent is initialized and trained against ProxyEnv . The ProxyEnv instantiates a gym.Env class and therefore implements its API. This means the proxy environment is compatible with any gym compatible RL agent. However, unlike other environments it only acts as a proxy and does not implement an environment of its own. It allows for the decoupling of the process environment of the gym.env from the process environment of the RL agent. The actual gym.env against which the agent is trained is wrapped by the gym connection. The proxy environment and gym connection communicate via a protocol, the gym protocol. Note, it would trivially be possible to implement the gym environment in another AEA; this way one AEA could provide gym environments as a service. Naturally, the overhead created by the introduction of the extra layers causes a higher latency when training the RL agent. In this particular skill, which chiefly serves for demonstration purposes, we implement a very basic RL agent. The agent trains a model of price of n goods: it aims to discover the most likely price of each good. To this end, the agent randomly selects one of the n goods on each training step and then chooses as an action the price which it deems is most likely accepted. Each good is represented by an id and the possible price range [1,100] divided into 100 integer bins. For each price bin, a PriceBandit is created which models the likelihood of this price. In particular, a price bandit maintains a beta distribution . The beta distribution is initialized to the uniform distribution. Each time the price associated with a given PriceBandit is accepted or rejected the distribution maintained by the PriceBandit is updated. For each good, the agent can therefore over time learn which price is most likely. The illustration shows how the RL agent only interacts with the proxy environment by sending it action (A) and receiving observation (O) , reward (R) , done (D) and info (I) .","title":"Gym skill"},{"location":"aea/gym-skill/#discussion","text":"The gym skills demonstrate how to wrap a Reinforcement Learning agent in a skill. The example decouples the RL agent from the gym.Env allowing them to run in separate execution environments, potentially owned by different entities.","title":"Discussion"},{"location":"aea/gym-skill/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/gym-skill/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/gym-skill/#demo-instructions","text":"","title":"Demo instructions"},{"location":"aea/gym-skill/#create-the-aea","text":"In the root directory, create the gym AEA and enter the project. aea create my_gym_aea cd my_gym_aea","title":"Create the AEA"},{"location":"aea/gym-skill/#add-the-gym-skill","text":"aea add skill fetchai/gym:0.1.0","title":"Add the gym skill"},{"location":"aea/gym-skill/#copy-the-gym-environment-to-the-aea-directory","text":"mkdir gyms cp -a ../examples/gym_ex/gyms/. gyms/","title":"Copy the gym environment to the AEA directory"},{"location":"aea/gym-skill/#add-a-gym-connection","text":"aea add connection fetchai/gym:0.1.0","title":"Add a gym connection"},{"location":"aea/gym-skill/#update-the-connection-config","text":"aea config set vendor.fetchai.connections.gym.config.env 'gyms.env.BanditNArmedRandom'","title":"Update the connection config"},{"location":"aea/gym-skill/#install-the-skill-dependencies","text":"To install the gym package, a dependency of the gym skill, from Pypi run aea install","title":"Install the skill dependencies"},{"location":"aea/gym-skill/#run-the-aea-with-the-gym-connection","text":"aea run --connections fetchai/gym:0.1.0 You will see the gym training logs.","title":"Run the AEA with the gym connection"},{"location":"aea/gym-skill/#delete-the-aea","text":"When you're done, you can go up a level and delete the AEA. cd .. aea delete my_gym_aea","title":"Delete the AEA"},{"location":"aea/gym-skill/#communication","text":"This diagram shows the communication between the AEA and the gym environment sequenceDiagram participant AEA participant Environment activate AEA activate Environment AEA->>Environment: reset loop learn AEA->>Environment: act Environment->>AEA: percept end AEA->>Environment: close deactivate AEA deactivate Environment","title":"Communication"},{"location":"aea/gym-skill/#skill-architecture","text":"The skill consists of two core components: GymHandler and GymTask . In the setup method of the GymHandler the GymTask is initialized, as well as its setup and execute methods called. The handler, which is registered against the GymMessage.protocol_id then filters for messages of that protocol with the performative GymMessage.Performative.PERCEPT . These messages are passed to the proxy_env_queue of the task. The GymTask is responsible for training the RL agent. In particular, MyRLAgent is initialized and trained against ProxyEnv . The ProxyEnv instantiates a gym.Env class and therefore implements its API. This means the proxy environment is compatible with any gym compatible RL agent. However, unlike other environments it only acts as a proxy and does not implement an environment of its own. It allows for the decoupling of the process environment of the gym.env from the process environment of the RL agent. The actual gym.env against which the agent is trained is wrapped by the gym connection. The proxy environment and gym connection communicate via a protocol, the gym protocol. Note, it would trivially be possible to implement the gym environment in another AEA; this way one AEA could provide gym environments as a service. Naturally, the overhead created by the introduction of the extra layers causes a higher latency when training the RL agent. In this particular skill, which chiefly serves for demonstration purposes, we implement a very basic RL agent. The agent trains a model of price of n goods: it aims to discover the most likely price of each good. To this end, the agent randomly selects one of the n goods on each training step and then chooses as an action the price which it deems is most likely accepted. Each good is represented by an id and the possible price range [1,100] divided into 100 integer bins. For each price bin, a PriceBandit is created which models the likelihood of this price. In particular, a price bandit maintains a beta distribution . The beta distribution is initialized to the uniform distribution. Each time the price associated with a given PriceBandit is accepted or rejected the distribution maintained by the PriceBandit is updated. For each good, the agent can therefore over time learn which price is most likely. The illustration shows how the RL agent only interacts with the proxy environment by sending it action (A) and receiving observation (O) , reward (R) , done (D) and info (I) .","title":"Skill Architecture"},{"location":"aea/http-connection-and-skill/","text":"Description The HTTP connection allows you to run a server inside a connection which accepts requests from clients. The HTTP connection validates requests it receives against the provided OpenAPI file. It translates each valid request into an envelope, sends the envelope to the agent and if it receives, within a timeout window, a valid response envelope, serves the response to the client. Steps Create a new AEA: aea create my_aea Add the http connection package aea add connection fetchai/http:0.1.0 Modify the api_spec_path : aea config set vendor.fetchai.connections.http.config.api_spec_path \"examples/http_ex/petstore.yaml\" Install the dependencies: aea install Write and add your skill: aea scaffold skill http_echo We leave it to you to implement a simple http echo skill (modelled after the standard echo skill) which prints out the content of received envelopes.","title":"HTTP Connection"},{"location":"aea/http-connection-and-skill/#description","text":"The HTTP connection allows you to run a server inside a connection which accepts requests from clients. The HTTP connection validates requests it receives against the provided OpenAPI file. It translates each valid request into an envelope, sends the envelope to the agent and if it receives, within a timeout window, a valid response envelope, serves the response to the client.","title":"Description"},{"location":"aea/http-connection-and-skill/#steps","text":"Create a new AEA: aea create my_aea Add the http connection package aea add connection fetchai/http:0.1.0 Modify the api_spec_path : aea config set vendor.fetchai.connections.http.config.api_spec_path \"examples/http_ex/petstore.yaml\" Install the dependencies: aea install Write and add your skill: aea scaffold skill http_echo We leave it to you to implement a simple http echo skill (modelled after the standard echo skill) which prints out the content of received envelopes.","title":"Steps"},{"location":"aea/identity/","text":"Note This section is incomplete and will soon be updated. The AEAs currently use the addresses associated with their private-public key pairs to identify themselves. To learn how to generate a private-public key pair check out this section . To learn more about public-key cryptography check out wikipedia","title":"Identity"},{"location":"aea/integration/","text":"In this section, we show you how to integrate the AEA with the Fetch.ai and third-party ledgers. The framework currently natively supports two ledgers: Fetch.ai Ethereum To this end, the framework wraps APIs to interact with the two ledgers and exposes them in the LedgerApis class. The framework also wraps the account APIs to create identities on both ledgers and exposes them in the Wallet . The Wallet holds instantiation of the abstract Crypto base class, in particular FetchaiCrypto and EthereumCrypto . The LedgerApis holds instantiation of the abstract LedgerApi base class, in particular FetchaiLedgerApi and EthereumLedgerApi . You can think the concrete implementations of the base class LedgerApi as wrappers of the blockchain specific python SDK. Abstract class LedgerApi Each LedgerApi must implement all the methods based on the abstract class. class LedgerApi ( ABC ): \"\"\"Interface for ledger APIs.\"\"\" identifier = \"base\" # type: str @property @abstractmethod def api ( self ) -> Any : \"\"\" Get the underlying API object. If there is no such object, return None. \"\"\" The api property can be used for low-level operation with the concrete ledger APIs. @abstractmethod def get_balance ( self , address : AddressLike ) -> int : \"\"\" Get the balance of a given account. This usually takes the form of a web request to be waited synchronously. :param address: the address. :return: the balance. \"\"\" The get_balance method returns the amount of tokens we hold for a specific address. @abstractmethod def send_transaction ( self , crypto : Crypto , destination_address : AddressLike , amount : int , tx_fee : int , tx_nonce : str , ** kwargs ) -> Optional [ str ]: \"\"\" Submit a transaction to the ledger. If the mandatory arguments are not enough for specifying a transaction in the concrete ledger API, use keyword arguments for the additional parameters. :param tx_nonce: verifies the authenticity of the tx :param crypto: the crypto object associated to the payer. :param destination_address: the destination address of the payee. :param amount: the amount of wealth to be transferred. :param tx_fee: the transaction fee. :return: tx digest if successful, otherwise None \"\"\" The send_transaction is where we must implement the logic for sending a transaction to the ledger. @abstractmethod def is_transaction_settled ( self , tx_digest : str ) -> bool : \"\"\" Check whether a transaction is settled or not. :param tx_digest: the digest associated to the transaction. :return: True if the transaction has been settled, False o/w. \"\"\" @abstractmethod def validate_transaction ( self , tx_digest : str , seller : Address , client : Address , tx_nonce : str , amount : int , ) -> bool : \"\"\" Check whether a transaction is valid or not. :param seller: the address of the seller. :param client: the address of the client. :param tx_nonce: the transaction nonce. :param amount: the amount we expect to get from the transaction. :param tx_digest: the transaction digest. :return: True if the transaction referenced by the tx_digest matches the terms. \"\"\" The is_transaction_settled and validate_transaction are two functions that helps us to verify a transaction digest. @abstractmethod def generate_tx_nonce ( self , seller : Address , client : Address ) -> str : \"\"\" Generate a random str message. :param seller: the address of the seller. :param client: the address of the client. :return: return the hash in hex. \"\"\" Lastly, we implemented a support function that generates a random hash to help us with verifying the uniqueness of transactions. The sender of the funds must include this hash in the transaction as extra data for the transaction to be considered valid. Next, we are going to discuss the different implementation of send_transaction and validate_transacaction for the two natively supported ledgers of the framework. Fetch.ai Ledger def send_transaction ( self , crypto : Crypto , destination_address : AddressLike , amount : int , tx_fee : int , tx_nonce : str , ** kwargs ) -> Optional [ str ]: \"\"\"Submit a transaction to the ledger.\"\"\" tx_digest = self . _api . tokens . transfer ( crypto . entity , destination_address , amount , tx_fee ) self . _api . sync ( tx_digest ) return tx_digest As you can see, the implementation for sending a transcation to the Fetch.ai ledger is relatively trivial. Note We cannot use the tx_nonce yet in the Fetch.ai ledger. def is_transaction_settled ( self , tx_digest : str ) -> bool : \"\"\"Check whether a transaction is settled or not.\"\"\" tx_status = cast ( TxStatus , self . _api . tx . status ( tx_digest )) is_successful = False if tx_status . status in SUCCESSFUL_TERMINAL_STATES : is_successful = True return is_successful def validate_transaction ( self , tx_digest : str , seller : Address , client : Address , tx_nonce : str , amount : int , ) -> bool : \"\"\" Check whether a transaction is valid or not. :param seller: the address of the seller. :param client: the address of the client. :param tx_nonce: the transaction nonce. :param amount: the amount we expect to get from the transaction. :param tx_digest: the transaction digest. :return: True if the random_message is equals to tx['input'] \"\"\" tx_contents = cast ( TxContents , self . _api . tx . contents ( tx_digest )) transfers = tx_contents . transfers seller_address = Address ( seller ) is_valid = ( str ( tx_contents . from_address ) == client and amount == transfers [ seller_address ] ) is_settled = self . is_transaction_settled ( tx_digest = tx_digest ) result = is_valid and is_settled return result Inside the validate_transcation we request the contents of the transaction based on the tx_digest we received. We are checking that the address of the client is the same as the one that is inside the from field of the transaction. Lastly, we are checking that the transaction is settled. If both of these checks return True we consider the transaction as valid. Ethereum Ledger def send_transaction ( self , crypto : Crypto , destination_address : AddressLike , amount : int , tx_fee : int , tx_nonce : str , chain_id : int = 3 , ** kwargs ) -> Optional [ str ]: \"\"\" Submit a transaction to the ledger. :param tx_nonce: verifies the authenticity of the tx :param crypto: the crypto object associated to the payer. :param destination_address: the destination address of the payee. :param amount: the amount of wealth to be transferred. :param tx_fee: the transaction fee. :param chain_id: the Chain ID of the Ethereum transaction. Default is 1 (i.e. mainnet). :return: the transaction digest, or None if not available. \"\"\" nonce = self . _api . eth . getTransactionCount ( self . _api . toChecksumAddress ( crypto . address ) ) transaction = { \"nonce\" : nonce , \"chainId\" : chain_id , \"to\" : destination_address , \"value\" : amount , \"gas\" : tx_fee , \"gasPrice\" : self . _api . toWei ( self . _gas_price , GAS_ID ), \"data\" : tx_nonce , } gas_estimation = self . _api . eth . estimateGas ( transaction = transaction ) assert ( tx_fee >= gas_estimation ), \"Need to increase tx_fee in the configs to cover the gas consumption of the transaction. Estimated gas consumption is: {} .\" . format ( gas_estimation ) signed = self . _api . eth . account . signTransaction ( transaction , crypto . entity . key ) hex_value = self . _api . eth . sendRawTransaction ( signed . rawTransaction ) logger . info ( \"TX Hash: {} \" . format ( str ( hex_value . hex ()))) while True : try : self . _api . eth . getTransactionReceipt ( hex_value ) logger . info ( \"transaction validated - exiting\" ) tx_digest = hex_value . hex () break except web3 . exceptions . TransactionNotFound : # pragma: no cover logger . info ( \"transaction not found - sleeping for 3.0 seconds\" ) time . sleep ( 3.0 ) return tx_digest On contrary to the Fetch.ai implementation of the send_transaction function, the Ethereum implementation is more complicated. This happens because we must create the transaction dictionary and send a raw transaction. The nonce is a counter for the transaction we are sending. This is an auto-increment int based on how many transactions we are sending from the specific account. The chain_id specifies if we are trying to reach the mainnet or another testnet . The to field is the address we want to send the funds. The value is the number of tokens we want to transfer. The gas is the price we are paying to be able to send the transaction. The gasPrice is the price of the gas we want to pay. The data in the field that enables to send custom data (originally is used to send data to a smart contract). Once we filled the transaction dictionary. We are checking that the transaction fee is more than the estimated gas for the transaction otherwise we will not be able to complete the transfer. Then we are signing and we are sending the transaction. Once we get the transaction receipt we consider the transaction completed and we return the transaction digest. def is_transaction_settled ( self , tx_digest : str ) -> bool : \"\"\"Check whether a transaction is settled or not.\"\"\" tx_status = self . _api . eth . getTransactionReceipt ( tx_digest ) is_successful = False if tx_status is not None : is_successful = True return is_successful def validate_transaction ( self , tx_digest : str , seller : Address , client : Address , tx_nonce : str , amount : int , ) -> bool : \"\"\" Check whether a transaction is valid or not. :param seller: the address of the seller. :param client: the address of the client. :param tx_nonce: the transaction nonce. :param amount: the amount we expect to get from the transaction. :param tx_digest: the transaction digest. :return: True if the random_message is equals to tx['input'] \"\"\" tx = self . _api . eth . getTransaction ( tx_digest ) is_valid = ( tx . get ( \"input\" ) == tx_nonce and tx . get ( \"value\" ) == amount and tx . get ( \"from\" ) == client and tx . get ( \"to\" ) == seller ) return is_valid The validate_transaction and is_transaction_settled functions help us to check if a transaction digest is valid and is settled. In the Ethereum API, we can pass the tx_nonce , so we can check that it's the same. If it is different, we consider that transaction as no valid. The same happens if any of amount , client address or the seller address is different. Lastly, the generate_tx_nonce function is the same for both LedgerApi implementations but we use different hashing functions. Both use the timestamp as a random factor alongside the seller and client addresses. Fetch.ai implementation def generate_tx_nonce ( self , seller : Address , client : Address ) -> str : \"\"\" Generate a random str message. :param seller: the address of the seller. :param client: the address of the client. :return: return the hash in hex. \"\"\" time_stamp = int ( time . time ()) seller = cast ( str , seller ) client = cast ( str , client ) aggregate_hash = sha256_hash ( b \"\" . join ([ seller . encode (), client . encode (), time_stamp . to_bytes ( 32 , \"big\" )]) ) return aggregate_hash . hex () Ethereum implementation def generate_tx_nonce ( self , seller : Address , client : Address ) -> str : \"\"\" Generate a unique hash to distinguish txs with the same terms. :param seller: the address of the seller. :param client: the address of the client. :return: return the hash in hex. \"\"\" time_stamp = int ( time . time ()) aggregate_hash = Web3 . keccak ( b \"\" . join ([ seller . encode (), client . encode (), time_stamp . to_bytes ( 32 , \"big\" )]) ) return aggregate_hash . hex ()","title":"Using public ledgers"},{"location":"aea/integration/#abstract-class-ledgerapi","text":"Each LedgerApi must implement all the methods based on the abstract class. class LedgerApi ( ABC ): \"\"\"Interface for ledger APIs.\"\"\" identifier = \"base\" # type: str @property @abstractmethod def api ( self ) -> Any : \"\"\" Get the underlying API object. If there is no such object, return None. \"\"\" The api property can be used for low-level operation with the concrete ledger APIs. @abstractmethod def get_balance ( self , address : AddressLike ) -> int : \"\"\" Get the balance of a given account. This usually takes the form of a web request to be waited synchronously. :param address: the address. :return: the balance. \"\"\" The get_balance method returns the amount of tokens we hold for a specific address. @abstractmethod def send_transaction ( self , crypto : Crypto , destination_address : AddressLike , amount : int , tx_fee : int , tx_nonce : str , ** kwargs ) -> Optional [ str ]: \"\"\" Submit a transaction to the ledger. If the mandatory arguments are not enough for specifying a transaction in the concrete ledger API, use keyword arguments for the additional parameters. :param tx_nonce: verifies the authenticity of the tx :param crypto: the crypto object associated to the payer. :param destination_address: the destination address of the payee. :param amount: the amount of wealth to be transferred. :param tx_fee: the transaction fee. :return: tx digest if successful, otherwise None \"\"\" The send_transaction is where we must implement the logic for sending a transaction to the ledger. @abstractmethod def is_transaction_settled ( self , tx_digest : str ) -> bool : \"\"\" Check whether a transaction is settled or not. :param tx_digest: the digest associated to the transaction. :return: True if the transaction has been settled, False o/w. \"\"\" @abstractmethod def validate_transaction ( self , tx_digest : str , seller : Address , client : Address , tx_nonce : str , amount : int , ) -> bool : \"\"\" Check whether a transaction is valid or not. :param seller: the address of the seller. :param client: the address of the client. :param tx_nonce: the transaction nonce. :param amount: the amount we expect to get from the transaction. :param tx_digest: the transaction digest. :return: True if the transaction referenced by the tx_digest matches the terms. \"\"\" The is_transaction_settled and validate_transaction are two functions that helps us to verify a transaction digest. @abstractmethod def generate_tx_nonce ( self , seller : Address , client : Address ) -> str : \"\"\" Generate a random str message. :param seller: the address of the seller. :param client: the address of the client. :return: return the hash in hex. \"\"\" Lastly, we implemented a support function that generates a random hash to help us with verifying the uniqueness of transactions. The sender of the funds must include this hash in the transaction as extra data for the transaction to be considered valid. Next, we are going to discuss the different implementation of send_transaction and validate_transacaction for the two natively supported ledgers of the framework.","title":"Abstract class LedgerApi"},{"location":"aea/integration/#fetchai-ledger","text":"def send_transaction ( self , crypto : Crypto , destination_address : AddressLike , amount : int , tx_fee : int , tx_nonce : str , ** kwargs ) -> Optional [ str ]: \"\"\"Submit a transaction to the ledger.\"\"\" tx_digest = self . _api . tokens . transfer ( crypto . entity , destination_address , amount , tx_fee ) self . _api . sync ( tx_digest ) return tx_digest As you can see, the implementation for sending a transcation to the Fetch.ai ledger is relatively trivial. Note We cannot use the tx_nonce yet in the Fetch.ai ledger. def is_transaction_settled ( self , tx_digest : str ) -> bool : \"\"\"Check whether a transaction is settled or not.\"\"\" tx_status = cast ( TxStatus , self . _api . tx . status ( tx_digest )) is_successful = False if tx_status . status in SUCCESSFUL_TERMINAL_STATES : is_successful = True return is_successful def validate_transaction ( self , tx_digest : str , seller : Address , client : Address , tx_nonce : str , amount : int , ) -> bool : \"\"\" Check whether a transaction is valid or not. :param seller: the address of the seller. :param client: the address of the client. :param tx_nonce: the transaction nonce. :param amount: the amount we expect to get from the transaction. :param tx_digest: the transaction digest. :return: True if the random_message is equals to tx['input'] \"\"\" tx_contents = cast ( TxContents , self . _api . tx . contents ( tx_digest )) transfers = tx_contents . transfers seller_address = Address ( seller ) is_valid = ( str ( tx_contents . from_address ) == client and amount == transfers [ seller_address ] ) is_settled = self . is_transaction_settled ( tx_digest = tx_digest ) result = is_valid and is_settled return result Inside the validate_transcation we request the contents of the transaction based on the tx_digest we received. We are checking that the address of the client is the same as the one that is inside the from field of the transaction. Lastly, we are checking that the transaction is settled. If both of these checks return True we consider the transaction as valid.","title":"Fetch.ai Ledger"},{"location":"aea/integration/#ethereum-ledger","text":"def send_transaction ( self , crypto : Crypto , destination_address : AddressLike , amount : int , tx_fee : int , tx_nonce : str , chain_id : int = 3 , ** kwargs ) -> Optional [ str ]: \"\"\" Submit a transaction to the ledger. :param tx_nonce: verifies the authenticity of the tx :param crypto: the crypto object associated to the payer. :param destination_address: the destination address of the payee. :param amount: the amount of wealth to be transferred. :param tx_fee: the transaction fee. :param chain_id: the Chain ID of the Ethereum transaction. Default is 1 (i.e. mainnet). :return: the transaction digest, or None if not available. \"\"\" nonce = self . _api . eth . getTransactionCount ( self . _api . toChecksumAddress ( crypto . address ) ) transaction = { \"nonce\" : nonce , \"chainId\" : chain_id , \"to\" : destination_address , \"value\" : amount , \"gas\" : tx_fee , \"gasPrice\" : self . _api . toWei ( self . _gas_price , GAS_ID ), \"data\" : tx_nonce , } gas_estimation = self . _api . eth . estimateGas ( transaction = transaction ) assert ( tx_fee >= gas_estimation ), \"Need to increase tx_fee in the configs to cover the gas consumption of the transaction. Estimated gas consumption is: {} .\" . format ( gas_estimation ) signed = self . _api . eth . account . signTransaction ( transaction , crypto . entity . key ) hex_value = self . _api . eth . sendRawTransaction ( signed . rawTransaction ) logger . info ( \"TX Hash: {} \" . format ( str ( hex_value . hex ()))) while True : try : self . _api . eth . getTransactionReceipt ( hex_value ) logger . info ( \"transaction validated - exiting\" ) tx_digest = hex_value . hex () break except web3 . exceptions . TransactionNotFound : # pragma: no cover logger . info ( \"transaction not found - sleeping for 3.0 seconds\" ) time . sleep ( 3.0 ) return tx_digest On contrary to the Fetch.ai implementation of the send_transaction function, the Ethereum implementation is more complicated. This happens because we must create the transaction dictionary and send a raw transaction. The nonce is a counter for the transaction we are sending. This is an auto-increment int based on how many transactions we are sending from the specific account. The chain_id specifies if we are trying to reach the mainnet or another testnet . The to field is the address we want to send the funds. The value is the number of tokens we want to transfer. The gas is the price we are paying to be able to send the transaction. The gasPrice is the price of the gas we want to pay. The data in the field that enables to send custom data (originally is used to send data to a smart contract). Once we filled the transaction dictionary. We are checking that the transaction fee is more than the estimated gas for the transaction otherwise we will not be able to complete the transfer. Then we are signing and we are sending the transaction. Once we get the transaction receipt we consider the transaction completed and we return the transaction digest. def is_transaction_settled ( self , tx_digest : str ) -> bool : \"\"\"Check whether a transaction is settled or not.\"\"\" tx_status = self . _api . eth . getTransactionReceipt ( tx_digest ) is_successful = False if tx_status is not None : is_successful = True return is_successful def validate_transaction ( self , tx_digest : str , seller : Address , client : Address , tx_nonce : str , amount : int , ) -> bool : \"\"\" Check whether a transaction is valid or not. :param seller: the address of the seller. :param client: the address of the client. :param tx_nonce: the transaction nonce. :param amount: the amount we expect to get from the transaction. :param tx_digest: the transaction digest. :return: True if the random_message is equals to tx['input'] \"\"\" tx = self . _api . eth . getTransaction ( tx_digest ) is_valid = ( tx . get ( \"input\" ) == tx_nonce and tx . get ( \"value\" ) == amount and tx . get ( \"from\" ) == client and tx . get ( \"to\" ) == seller ) return is_valid The validate_transaction and is_transaction_settled functions help us to check if a transaction digest is valid and is settled. In the Ethereum API, we can pass the tx_nonce , so we can check that it's the same. If it is different, we consider that transaction as no valid. The same happens if any of amount , client address or the seller address is different. Lastly, the generate_tx_nonce function is the same for both LedgerApi implementations but we use different hashing functions. Both use the timestamp as a random factor alongside the seller and client addresses.","title":"Ethereum Ledger"},{"location":"aea/integration/#fetchai-implementation","text":"def generate_tx_nonce ( self , seller : Address , client : Address ) -> str : \"\"\" Generate a random str message. :param seller: the address of the seller. :param client: the address of the client. :return: return the hash in hex. \"\"\" time_stamp = int ( time . time ()) seller = cast ( str , seller ) client = cast ( str , client ) aggregate_hash = sha256_hash ( b \"\" . join ([ seller . encode (), client . encode (), time_stamp . to_bytes ( 32 , \"big\" )]) ) return aggregate_hash . hex ()","title":"Fetch.ai implementation"},{"location":"aea/integration/#ethereum-implementation","text":"def generate_tx_nonce ( self , seller : Address , client : Address ) -> str : \"\"\" Generate a unique hash to distinguish txs with the same terms. :param seller: the address of the seller. :param client: the address of the client. :return: return the hash in hex. \"\"\" time_stamp = int ( time . time ()) aggregate_hash = Web3 . keccak ( b \"\" . join ([ seller . encode (), client . encode (), time_stamp . to_bytes ( 32 , \"big\" )]) ) return aggregate_hash . hex ()","title":"Ethereum implementation"},{"location":"aea/logging/","text":"The AEA framework supports flexible logging capabilities with the standard Python logging library . In this tutorial, we configure logging for an AEA. First of all, create your AEA. aea create my_aea cd my_aea The aea-config.yaml file should look like this. aea_version : 0.2.4 agent_name : my_aea author : '' connections : - fetchai/stub:0.1.0 default_connection : fetchai/stub:0.1.0 default_ledger : fetchai description : '' fingerprint : '' ledger_apis : {} license : '' logging_config : disable_existing_loggers : false version : 1 private_key_paths : {} protocols : - fetchai/default:0.1.0 registry_path : ../packages skills : - fetchai/error:0.1.0 version : 0.1.0 By updating the logging_config section, you can configure the loggers of your application. The format of this section is specified in the logging.config module. At this section you'll find the definition of the configuration dictionary schema. Below is an example of the logging_config value. logging_config : version : 1 disable_existing_loggers : False formatters : standard : format : '%(asctime)s [%(levelname)s] %(name)s: %(message)s' handlers : logfile : class : logging.FileHandler formatter : standard level : DEBUG filename : logconfig.log console : class : logging.StreamHandler formatter : standard level : DEBUG loggers : aea : handlers : - logfile - console level : DEBUG propagate : False This configuration will set up a logger with name aea . It prints both on console and on file with a format specified by the standard formatter.","title":"Logging"},{"location":"aea/ml-skills/","text":"The AEA ML (machine learning) skills demonstrate an interaction between two AEAs trading data. There are two types of AEAs: The ml_data_provider which sells training data. The ml_model_trainer which trains a model Discussion The scope of the specific demo is to demonstrate how to create a simple AEA with integration of machine learning, and the usage of the AEA framework. The ml_data_provider AEA will provide some sample data and will deliver to the client upon payment. Once the client gets the data, it will train the model. The process can be found in the tasks.py file. This demo does not utilize a smart contract. As a result, we interact with a ledger only to complete a transaction. Since the AEA framework enables us to use third-party libraries hosted on PyPI we can directly reference the external dependencies. The aea install command will install each dependency that the specific AEA needs and is listed in the skill's YAML file. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Launch an OEF search and communication node In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for all the following demos. Demo instructions 1 - no ledger payment: Create the data provider AEA Create the AEA that will provide the data. aea create ml_data_provider cd ml_data_provider aea add connection fetchai/oef:0.1.0 aea add skill fetchai/ml_data_provider:0.1.0 aea install Alternatively, install the AEA directly In the root directory, fetch the data provider AEA and enter the project. aea fetch fetchai/ml_data_provider:0.1.0 cd ml_data_provider The aea fetch command creates the entire AEA, including its dependencies for you. Install the dependencies The ml data provider uses tensorflow and numpy . aea install Run the data provider AEA aea run --connections fetchai/oef:0.1.0 Create the model trainer AEA In a separate terminal, in the root directory, create the model trainer AEA. aea create ml_model_trainer cd ml_model_trainer aea add connection fetchai/oef:0.1.0 aea add skill fetchai/ml_train:0.1.0 aea install Alternatively, install the AEA directly In the root directory, fetch the data provider AEA and enter the project. aea fetch fetchai/ml_model_trainer:0.1.0 cd ml_model_trainer Install the dependencies The ml data provider uses tensorflow and numpy . aea install Run the model trainer AEA aea run --connections fetchai/oef:0.1.0 After some time, you should see the AEAs transact and the model trainer train its model. Demo instructions - Ledger payment: We will now run the same demo but with a real ledger transaction on Fetch.ai or Ethereum ropsten network. This demo assumes the buyer trusts the seller AEA to send the data upon successful payment. Create the data provider AEA Create the AEA that will provide the data. aea create ml_data_provider cd ml_data_provider aea add connection fetchai/oef:0.1.0 aea add skill fetchai/ml_data_provider:0.1.0 aea install Create the model trainer AEA In a separate terminal, in the root directory, create the model trainer AEA. aea create ml_model_trainer cd ml_model_trainer aea add connection fetchai/oef:0.1.0 aea add skill fetchai/ml_train:0.1.0 aea install Additionally, create the private key for the model trainer AEA based on the network you want to transact. To generate and add a key for Fetch.ai use: aea generate-key fetchai aea add-key fetchai fet_private_key.txt To generate and add a key for Ethereum use: aea generate-key ethereum aea add-key ethereum eth_private_key.txt Update the AEA configs Both in ml_model_trainer/aea-config.yaml and ml_data_provider/aea-config.yaml , replace ledger_apis: {} with the following based on the network you want to connect. To connect to Fetchai: ledger_apis : fetchai : network : testnet To connect to Ethereum: ledger_apis : ethereum : address : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 gas_price : 50 Fund the ml model trainer AEA Create some wealth for your ml model trainer based on the network you want to transact with: On the Fetch.ai testnet network. aea generate-wealth fetchai On the Ethereum ropsten . (It takes a while). aea generate-wealth ethereum Update the skill configs In the ml data provider skill config ( ml_data_provider/skills/ml_data_provider/skill.yaml ) under strategy, amend the currency_id and ledger_id as follows. | ----------------------------------------------------------------------| | FETCHAI | ETHEREUM | | -----------------------------------|----------------------------------| |models : |models : | | strategy : | strategy : | | class_name : Strategy | class_name : Strategy | | args : | args : | | price_per_data_batch : 100 | price_per_data_batch : 100 | | batch_size : 2 | batch_size : 2 | | seller_tx_fee : 0 | seller_tx_fee : 0 | | buyer_tx_fee : 10 | buyer_tx_fee : 10 | | dataset_id : 'fmnist' | dataset_id : 'fmnist' | | currency_id : 'FET' | currency_id : 'ETH' | | ledger_id : 'fetchai' | ledger_id : 'ethereum' | | is_ledger_tx : True | is_ledger_tx : True | | ----------------------------------------------------------------------| Another way to update the skill config is via the aea config get/set command. aea config set vendor.fetchai.skills.ml_data_provider.models.strategy.args.currency_id ETH aea config set vendor.fetchai.skills.ml_data_provider.models.strategy.args.ledger_id ethereum In the ml model trainer skill config ( ml_model_trainer/skills/ml_train/skill.yaml ) under strategy, amend the currency_id and ledger_id as follows. | ----------------------------------------------------------------------| | FETCHAI | ETHEREUM | | -----------------------------------|----------------------------------| |models : |models : | | strategy : | strategy : | | class_name : Strategy | class_name : Strategy | | args : | args : | | dataset_id : 'fmnist' | dataset_id : 'fmnist' | | max_unit_price : 70 | max_unit_price : 70 | | max_buyer_tx_fee : 20 | max_buyer_tx_fee : 20 | | currency_id : 'FET' | currency_id : 'ETH' | | ledger_id : 'fetchai' | ledger_id : 'ethereum' | | is_ledger_tx : True | is_ledger_tx : True | | ----------------------------------------------------------------------| Another way to update the skill config is via the aea config get/set command. aea config set vendor.fetchai.skills.ml_train.models.strategy.args.max_buyer_tx_fee 10000 --type int aea config set vendor.fetchai.skills.ml_train.models.strategy.args.currency_id ETH aea config set vendor.fetchai.skills.ml_train.models.strategy.args.ledger_id ethereum Run both AEAs From their respective directories, run both AEAs aea run --connections fetchai/oef:0.1.0 Clean up cd .. aea delete ml_data_provider aea delete ml_model_trainer Communication This diagram shows the communication between the two AEAs. sequenceDiagram participant ml_model_trainer participant ml_data_provider participant Search participant Ledger activate ml_model_trainer activate ml_data_provider activate Search activate Ledger ml_data_provider->>Search: register_service ml_model_trainer->>Search: search Search-->>ml_model_trainer: list_of_agents ml_model_trainer->>ml_data_provider: call_for_terms ml_data_provider->>ml_model_trainer: terms ml_model_trainer->>Ledger: request_transaction ml_model_trainer->>ml_data_provider: accept (incl transaction_hash) ml_data_provider->>Ledger: check_transaction_status ml_data_provider->>ml_model_trainer: data loop train ml_model_trainer->>ml_model_trainer: tran_model end deactivate ml_model_trainer deactivate ml_data_provider deactivate Search deactivate Ledger","title":"ML skills"},{"location":"aea/ml-skills/#discussion","text":"The scope of the specific demo is to demonstrate how to create a simple AEA with integration of machine learning, and the usage of the AEA framework. The ml_data_provider AEA will provide some sample data and will deliver to the client upon payment. Once the client gets the data, it will train the model. The process can be found in the tasks.py file. This demo does not utilize a smart contract. As a result, we interact with a ledger only to complete a transaction. Since the AEA framework enables us to use third-party libraries hosted on PyPI we can directly reference the external dependencies. The aea install command will install each dependency that the specific AEA needs and is listed in the skill's YAML file.","title":"Discussion"},{"location":"aea/ml-skills/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/ml-skills/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/ml-skills/#launch-an-oef-search-and-communication-node","text":"In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for all the following demos.","title":"Launch an OEF search and communication node"},{"location":"aea/ml-skills/#demo-instructions-1-no-ledger-payment","text":"","title":"Demo instructions 1 - no ledger payment:"},{"location":"aea/ml-skills/#create-the-data-provider-aea","text":"Create the AEA that will provide the data. aea create ml_data_provider cd ml_data_provider aea add connection fetchai/oef:0.1.0 aea add skill fetchai/ml_data_provider:0.1.0 aea install","title":"Create the data provider AEA"},{"location":"aea/ml-skills/#alternatively-install-the-aea-directly","text":"In the root directory, fetch the data provider AEA and enter the project. aea fetch fetchai/ml_data_provider:0.1.0 cd ml_data_provider The aea fetch command creates the entire AEA, including its dependencies for you.","title":"Alternatively, install the AEA directly"},{"location":"aea/ml-skills/#install-the-dependencies","text":"The ml data provider uses tensorflow and numpy . aea install","title":"Install the dependencies"},{"location":"aea/ml-skills/#run-the-data-provider-aea","text":"aea run --connections fetchai/oef:0.1.0","title":"Run the data provider AEA"},{"location":"aea/ml-skills/#create-the-model-trainer-aea","text":"In a separate terminal, in the root directory, create the model trainer AEA. aea create ml_model_trainer cd ml_model_trainer aea add connection fetchai/oef:0.1.0 aea add skill fetchai/ml_train:0.1.0 aea install","title":"Create the model trainer AEA"},{"location":"aea/ml-skills/#alternatively-install-the-aea-directly_1","text":"In the root directory, fetch the data provider AEA and enter the project. aea fetch fetchai/ml_model_trainer:0.1.0 cd ml_model_trainer","title":"Alternatively, install the AEA directly"},{"location":"aea/ml-skills/#install-the-dependencies_1","text":"The ml data provider uses tensorflow and numpy . aea install","title":"Install the dependencies"},{"location":"aea/ml-skills/#run-the-model-trainer-aea","text":"aea run --connections fetchai/oef:0.1.0 After some time, you should see the AEAs transact and the model trainer train its model.","title":"Run the model trainer AEA"},{"location":"aea/ml-skills/#demo-instructions-ledger-payment","text":"We will now run the same demo but with a real ledger transaction on Fetch.ai or Ethereum ropsten network. This demo assumes the buyer trusts the seller AEA to send the data upon successful payment.","title":"Demo instructions - Ledger payment:"},{"location":"aea/ml-skills/#create-the-data-provider-aea_1","text":"Create the AEA that will provide the data. aea create ml_data_provider cd ml_data_provider aea add connection fetchai/oef:0.1.0 aea add skill fetchai/ml_data_provider:0.1.0 aea install","title":"Create the data provider AEA"},{"location":"aea/ml-skills/#create-the-model-trainer-aea_1","text":"In a separate terminal, in the root directory, create the model trainer AEA. aea create ml_model_trainer cd ml_model_trainer aea add connection fetchai/oef:0.1.0 aea add skill fetchai/ml_train:0.1.0 aea install Additionally, create the private key for the model trainer AEA based on the network you want to transact. To generate and add a key for Fetch.ai use: aea generate-key fetchai aea add-key fetchai fet_private_key.txt To generate and add a key for Ethereum use: aea generate-key ethereum aea add-key ethereum eth_private_key.txt","title":"Create the model trainer AEA"},{"location":"aea/ml-skills/#update-the-aea-configs","text":"Both in ml_model_trainer/aea-config.yaml and ml_data_provider/aea-config.yaml , replace ledger_apis: {} with the following based on the network you want to connect. To connect to Fetchai: ledger_apis : fetchai : network : testnet To connect to Ethereum: ledger_apis : ethereum : address : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 gas_price : 50","title":"Update the AEA configs"},{"location":"aea/ml-skills/#fund-the-ml-model-trainer-aea","text":"Create some wealth for your ml model trainer based on the network you want to transact with: On the Fetch.ai testnet network. aea generate-wealth fetchai On the Ethereum ropsten . (It takes a while). aea generate-wealth ethereum","title":"Fund the ml model trainer AEA"},{"location":"aea/ml-skills/#update-the-skill-configs","text":"In the ml data provider skill config ( ml_data_provider/skills/ml_data_provider/skill.yaml ) under strategy, amend the currency_id and ledger_id as follows. | ----------------------------------------------------------------------| | FETCHAI | ETHEREUM | | -----------------------------------|----------------------------------| |models : |models : | | strategy : | strategy : | | class_name : Strategy | class_name : Strategy | | args : | args : | | price_per_data_batch : 100 | price_per_data_batch : 100 | | batch_size : 2 | batch_size : 2 | | seller_tx_fee : 0 | seller_tx_fee : 0 | | buyer_tx_fee : 10 | buyer_tx_fee : 10 | | dataset_id : 'fmnist' | dataset_id : 'fmnist' | | currency_id : 'FET' | currency_id : 'ETH' | | ledger_id : 'fetchai' | ledger_id : 'ethereum' | | is_ledger_tx : True | is_ledger_tx : True | | ----------------------------------------------------------------------| Another way to update the skill config is via the aea config get/set command. aea config set vendor.fetchai.skills.ml_data_provider.models.strategy.args.currency_id ETH aea config set vendor.fetchai.skills.ml_data_provider.models.strategy.args.ledger_id ethereum In the ml model trainer skill config ( ml_model_trainer/skills/ml_train/skill.yaml ) under strategy, amend the currency_id and ledger_id as follows. | ----------------------------------------------------------------------| | FETCHAI | ETHEREUM | | -----------------------------------|----------------------------------| |models : |models : | | strategy : | strategy : | | class_name : Strategy | class_name : Strategy | | args : | args : | | dataset_id : 'fmnist' | dataset_id : 'fmnist' | | max_unit_price : 70 | max_unit_price : 70 | | max_buyer_tx_fee : 20 | max_buyer_tx_fee : 20 | | currency_id : 'FET' | currency_id : 'ETH' | | ledger_id : 'fetchai' | ledger_id : 'ethereum' | | is_ledger_tx : True | is_ledger_tx : True | | ----------------------------------------------------------------------| Another way to update the skill config is via the aea config get/set command. aea config set vendor.fetchai.skills.ml_train.models.strategy.args.max_buyer_tx_fee 10000 --type int aea config set vendor.fetchai.skills.ml_train.models.strategy.args.currency_id ETH aea config set vendor.fetchai.skills.ml_train.models.strategy.args.ledger_id ethereum","title":"Update the skill configs"},{"location":"aea/ml-skills/#run-both-aeas","text":"From their respective directories, run both AEAs aea run --connections fetchai/oef:0.1.0","title":"Run both AEAs"},{"location":"aea/ml-skills/#clean-up","text":"cd .. aea delete ml_data_provider aea delete ml_model_trainer","title":"Clean up"},{"location":"aea/ml-skills/#communication","text":"This diagram shows the communication between the two AEAs. sequenceDiagram participant ml_model_trainer participant ml_data_provider participant Search participant Ledger activate ml_model_trainer activate ml_data_provider activate Search activate Ledger ml_data_provider->>Search: register_service ml_model_trainer->>Search: search Search-->>ml_model_trainer: list_of_agents ml_model_trainer->>ml_data_provider: call_for_terms ml_data_provider->>ml_model_trainer: terms ml_model_trainer->>Ledger: request_transaction ml_model_trainer->>ml_data_provider: accept (incl transaction_hash) ml_data_provider->>Ledger: check_transaction_status ml_data_provider->>ml_model_trainer: data loop train ml_model_trainer->>ml_model_trainer: tran_model end deactivate ml_model_trainer deactivate ml_data_provider deactivate Search deactivate Ledger","title":"Communication"},{"location":"aea/multiplexer-standalone/","text":"The Multiplexer can be used stand-alone. This way a developer can utilise the protocols and connections indendent of the Agent or AEA classes. First, import the python and application specific libraries and set the static variables. import os import time from copy import copy from threading import Thread from typing import Optional from aea.connections.stub.connection import StubConnection from aea.mail.base import Envelope , Multiplexer INPUT_FILE = \"input.txt\" OUTPUT_FILE = \"output.txt\" Instantiate a Multiplexer A Multiplexer only needs a list of connections. The StubConnection is a simple connection which reads from and writes to file. # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # create the connection and multiplexer objects stub_connection = StubConnection ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE ) multiplexer = Multiplexer ([ stub_connection ]) Start the Multiplexer We can run a multiplexer by calling, connect() which starts the receive and sending loops. We run the multiplexer from a different thread so that we can still use the main thread to pass it messages. try : # Set the multiplexer running in a different thread t = Thread ( target = multiplexer . connect ) t . start () # Wait for everything to start up time . sleep ( 3 ) Send and receive an envelope We use the input and output text files to send an envelope to our agent and receive a response # Create a message inside an envelope and get the stub connection to pass it into the multiplexer message_text = ( \"multiplexer,some_agent,fetchai/default:0.1.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : f . write ( message_text ) # Wait for the envelope to get processed time . sleep ( 2 ) # get the envelope envelope = multiplexer . get () # type: Optional[Envelope] assert envelope is not None # Inspect its contents print ( \"Envelope received by Multiplexer: sender= {} , to= {} , protocol_id= {} , message= {} \" . format ( envelope . sender , envelope . to , envelope . protocol_id , envelope . message ) ) # Create a mirrored response envelope response_envelope = copy ( envelope ) response_envelope . to = envelope . sender response_envelope . sender = envelope . to # Send the envelope back multiplexer . put ( response_envelope ) # Read the output envelope generated by the multiplexer with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"Envelope received from Multiplexer: \" + f . readline ()) Shutdown Finally stop our multiplexer and wait for it to finish finally : # Shut down the multiplexer multiplexer . disconnect () t . join () Your turn Now it is your turn to develop a simple usecase which utilises the Multiplexer to send and receive Envelopes. Entire code listing If you just want to copy and paste the entire script in you can find it here: Click here to see full listing import os import time from copy import copy from threading import Thread from typing import Optional from aea.connections.stub.connection import StubConnection from aea.mail.base import Envelope , Multiplexer INPUT_FILE = \"input.txt\" OUTPUT_FILE = \"output.txt\" def run (): # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # create the connection and multiplexer objects stub_connection = StubConnection ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE ) multiplexer = Multiplexer ([ stub_connection ]) try : # Set the multiplexer running in a different thread t = Thread ( target = multiplexer . connect ) t . start () # Wait for everything to start up time . sleep ( 3 ) # Create a message inside an envelope and get the stub connection to pass it into the multiplexer message_text = ( \"multiplexer,some_agent,fetchai/default:0.1.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : f . write ( message_text ) # Wait for the envelope to get processed time . sleep ( 2 ) # get the envelope envelope = multiplexer . get () # type: Optional[Envelope] assert envelope is not None # Inspect its contents print ( \"Envelope received by Multiplexer: sender= {} , to= {} , protocol_id= {} , message= {} \" . format ( envelope . sender , envelope . to , envelope . protocol_id , envelope . message ) ) # Create a mirrored response envelope response_envelope = copy ( envelope ) response_envelope . to = envelope . sender response_envelope . sender = envelope . to # Send the envelope back multiplexer . put ( response_envelope ) # Read the output envelope generated by the multiplexer with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"Envelope received from Multiplexer: \" + f . readline ()) finally : # Shut down the multiplexer multiplexer . disconnect () t . join () if __name__ == \"__main__\" : run ()","title":"Use multiplexer stand-alone"},{"location":"aea/multiplexer-standalone/#instantiate-a-multiplexer","text":"A Multiplexer only needs a list of connections. The StubConnection is a simple connection which reads from and writes to file. # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # create the connection and multiplexer objects stub_connection = StubConnection ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE ) multiplexer = Multiplexer ([ stub_connection ])","title":"Instantiate a Multiplexer"},{"location":"aea/multiplexer-standalone/#start-the-multiplexer","text":"We can run a multiplexer by calling, connect() which starts the receive and sending loops. We run the multiplexer from a different thread so that we can still use the main thread to pass it messages. try : # Set the multiplexer running in a different thread t = Thread ( target = multiplexer . connect ) t . start () # Wait for everything to start up time . sleep ( 3 )","title":"Start the Multiplexer"},{"location":"aea/multiplexer-standalone/#send-and-receive-an-envelope","text":"We use the input and output text files to send an envelope to our agent and receive a response # Create a message inside an envelope and get the stub connection to pass it into the multiplexer message_text = ( \"multiplexer,some_agent,fetchai/default:0.1.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : f . write ( message_text ) # Wait for the envelope to get processed time . sleep ( 2 ) # get the envelope envelope = multiplexer . get () # type: Optional[Envelope] assert envelope is not None # Inspect its contents print ( \"Envelope received by Multiplexer: sender= {} , to= {} , protocol_id= {} , message= {} \" . format ( envelope . sender , envelope . to , envelope . protocol_id , envelope . message ) ) # Create a mirrored response envelope response_envelope = copy ( envelope ) response_envelope . to = envelope . sender response_envelope . sender = envelope . to # Send the envelope back multiplexer . put ( response_envelope ) # Read the output envelope generated by the multiplexer with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"Envelope received from Multiplexer: \" + f . readline ())","title":"Send and receive an envelope"},{"location":"aea/multiplexer-standalone/#shutdown","text":"Finally stop our multiplexer and wait for it to finish finally : # Shut down the multiplexer multiplexer . disconnect () t . join ()","title":"Shutdown"},{"location":"aea/multiplexer-standalone/#your-turn","text":"Now it is your turn to develop a simple usecase which utilises the Multiplexer to send and receive Envelopes.","title":"Your turn"},{"location":"aea/multiplexer-standalone/#entire-code-listing","text":"If you just want to copy and paste the entire script in you can find it here: Click here to see full listing import os import time from copy import copy from threading import Thread from typing import Optional from aea.connections.stub.connection import StubConnection from aea.mail.base import Envelope , Multiplexer INPUT_FILE = \"input.txt\" OUTPUT_FILE = \"output.txt\" def run (): # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # create the connection and multiplexer objects stub_connection = StubConnection ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE ) multiplexer = Multiplexer ([ stub_connection ]) try : # Set the multiplexer running in a different thread t = Thread ( target = multiplexer . connect ) t . start () # Wait for everything to start up time . sleep ( 3 ) # Create a message inside an envelope and get the stub connection to pass it into the multiplexer message_text = ( \"multiplexer,some_agent,fetchai/default:0.1.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : f . write ( message_text ) # Wait for the envelope to get processed time . sleep ( 2 ) # get the envelope envelope = multiplexer . get () # type: Optional[Envelope] assert envelope is not None # Inspect its contents print ( \"Envelope received by Multiplexer: sender= {} , to= {} , protocol_id= {} , message= {} \" . format ( envelope . sender , envelope . to , envelope . protocol_id , envelope . message ) ) # Create a mirrored response envelope response_envelope = copy ( envelope ) response_envelope . to = envelope . sender response_envelope . sender = envelope . to # Send the envelope back multiplexer . put ( response_envelope ) # Read the output envelope generated by the multiplexer with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"Envelope received from Multiplexer: \" + f . readline ()) finally : # Shut down the multiplexer multiplexer . disconnect () t . join () if __name__ == \"__main__\" : run ()","title":"Entire code listing"},{"location":"aea/oef-ledger/","text":"The Open Economic Framework and the Ledgers allow AEAs to create value through their interaction with other AEAs. The following diagram illustrates the relation of AEAs to the OEF and Ledgers. Open Economic Framework (OEF) The 'Open Economic Framework' (OEF) consists of protocols, languages and market mechanisms agents use to search and find each other, communicate with as well as trade with each other. Note The OEF is under development. Expect frequent changes. What follows is a description of the current implementation. At present, the OEF services are fulfilled by an OEF search and communication node . This node consists of two parts. A search node part enables agents to register their services and search and discover other agents' services. A communication node part enables agents to communicate with each other. For two agents to be able to find each other, at least one must register as a service and the other must query the OEF search node for this service. For an example of such an interaction see this guide . Agents can receive messages from other agents if they are both connected to the same OEF communication node . Currently, you need to run your own OEF search and communication node for local development and testing. To start an OEF search and communication node follow the Preliminaries sections from the AEA quick start. Then run: python scripts/oef/launch.py -c ./scripts/oef/launch_config.json When it is live you will see the sentence 'A thing of beauty is a joy forever...'. To view the OEF search and communication node logs for debugging, navigate to data/oef-logs . To connect to an OEF search and communication node an AEA uses the OEFConnection connection package ( fetchai/oef:0.1.0 ). Note In the current implementation agents act as clients to the `OEF search and communication node`. We are working on a fully decentralized peer-to-peer implementation which will remove the need for a central entity. Ledgers Ledgers enable the AEAs to complete a transaction, which can involve the transfer of funds to each other or the execution of smart contracts. Whilst a ledger can, in principle, also be used to store structured data - for instance, training data in a machine learning model - in most use cases the resulting costs and privacy implications do not make this a relevant use of the ledger. Instead, usually only references to the structured data - often in the form of hashes - are stored on the ledger and the actual data is stored off-chain.","title":"Relation to OEF and Ledger"},{"location":"aea/oef-ledger/#open-economic-framework-oef","text":"The 'Open Economic Framework' (OEF) consists of protocols, languages and market mechanisms agents use to search and find each other, communicate with as well as trade with each other. Note The OEF is under development. Expect frequent changes. What follows is a description of the current implementation. At present, the OEF services are fulfilled by an OEF search and communication node . This node consists of two parts. A search node part enables agents to register their services and search and discover other agents' services. A communication node part enables agents to communicate with each other. For two agents to be able to find each other, at least one must register as a service and the other must query the OEF search node for this service. For an example of such an interaction see this guide . Agents can receive messages from other agents if they are both connected to the same OEF communication node . Currently, you need to run your own OEF search and communication node for local development and testing. To start an OEF search and communication node follow the Preliminaries sections from the AEA quick start. Then run: python scripts/oef/launch.py -c ./scripts/oef/launch_config.json When it is live you will see the sentence 'A thing of beauty is a joy forever...'. To view the OEF search and communication node logs for debugging, navigate to data/oef-logs . To connect to an OEF search and communication node an AEA uses the OEFConnection connection package ( fetchai/oef:0.1.0 ). Note In the current implementation agents act as clients to the `OEF search and communication node`. We are working on a fully decentralized peer-to-peer implementation which will remove the need for a central entity.","title":"Open Economic Framework (OEF)"},{"location":"aea/oef-ledger/#ledgers","text":"Ledgers enable the AEAs to complete a transaction, which can involve the transfer of funds to each other or the execution of smart contracts. Whilst a ledger can, in principle, also be used to store structured data - for instance, training data in a machine learning model - in most use cases the resulting costs and privacy implications do not make this a relevant use of the ledger. Instead, usually only references to the structured data - often in the form of hashes - are stored on the ledger and the actual data is stored off-chain.","title":"Ledgers"},{"location":"aea/orm-integration-to-generic/","text":"The AEA generic seller with ORM integration demonstrate how to interact with a database using python-sql objects. The provider of a service in the form of data retrieved from a database. The buyer of a service. Discussion Object-relational-mapping is the idea of being able to write SQL queries, using the object-oriented paradigm of your preferred programming language. The scope of the specific demo is to demonstrate how to create an easy configurable AEA that reads data from a database using ORMs. This demo will not use any smart contract, because these would be out of the scope of the tutorial. We assume, that you followed the guide for the generic-skills. We assume, that we have a database genericdb.db with table name data . This table contains the following columns timestamp and thermometer We assume, that we have a hardware thermometer sensor that adds the readings in the genericdb database Since the AEA framework enables us to use third-party libraries hosted on PyPI we can directly reference the external dependencies. The aea install command will install each dependency that the specific AEA needs and is listed in the skill's YAML file. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Launch an OEF search and communication node In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for all the following demos. Demo: Ledger payment A demo to run a scenario with a true ledger transaction on Fetch.ai testnet network or Ethereum ropsten network. This demo assumes the buyer trusts the seller AEA to send the data upon successful payment. Create the seller AEA (ledger version) Create the AEA that will provide data. aea create my_seller_aea cd my_seller_aea aea add connection fetchai/oef:0.1.0 aea add skill fetchai/generic_seller:0.1.0 Create the buyer client (ledger version) In another terminal, create the AEA that will query the seller AEA. aea create my_buyer_aea cd my_buyer_aea aea add connection fetchai/oef:0.1.0 aea add skill fetchai/generic_buyer:0.1.0 Additionally, create the private key for the buyer AEA based on the network you want to transact. To generate and add a key for Fetch.ai use: aea generate-key fetchai aea add-key fetchai fet_private_key.txt To generate and add a key for Ethereum use: aea generate-key ethereum aea add-key ethereum eth_private_key.txt Update the AEA configs Both in my_seller_aea/aea-config.yaml and my_buyer_aea/aea-config.yaml , replace ledger_apis: {} with the following based on the network you want to connect To connect to Fetchai: ledger_apis : fetchai : network : testnet To connect to Ethereum: ledger_apis : ethereum : address : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 gas_price : 50 Update the seller AEA skill configs In my_seller_aea/vendor/fetchai/generi_seller/skill.yaml , replace the data_for_sale , search_schema , and search_data with your data: | ----------------------------------------------------------------------| | FETCHAI | ETHEREUM | | -----------------------------------|----------------------------------| |models : |models : | | strategy : | strategy : | | class_name : Strategy | class_name : Strategy | | args : | args : | | total_price : 10 | total_price : 10 | | seller_tx_fee : 0 | seller_tx_fee : 0 | | currency_id : 'FET' | currency_id : 'ETH' | | ledger_id : 'fetchai' | ledger_id : 'ethereum' | | is_ledger_tx : True | is_ledger_tx : True | | has_data_source : True | has_data_source : True | | data_for_sale : {} | data_for_sale : {} | | search_schema : | search_schema : | | attribute_one : | attribute_one : | | name : country | name : country | | type : str | type : str | | is_required : True | is_required : True | | attribute_two : | attribute_two : | | name : city | name : city | | type : str | type : str | | is_required : True | is_required : True | | search_data : | search_data : | | country : UK | country : UK | | city : Cambridge | city : Cambridge | |dependencies |dependencies : | | SQLAlchemy : {} | SQLAlchemy : {} | | ----------------------------------------------------------------------| The search_schema and the search_data are used to register the service in the OEF search node and make your agent discoverable. The name of each attribute must be a key in the search_data dictionary. In the generic buyer skill config ( my_buyer_aea/skills/generic_buyer/skill.yaml ) under strategy change the currency_id , ledger_id , and at the bottom of the file the ledgers . | ----------------------------------------------------------------------| | FETCHAI | ETHEREUM | | -----------------------------------|----------------------------------| |models : |models : | | strategy : | strategy : | | class_name : Strategy | class_name : Strategy | | args : | args : | | max_price : 40 | max_price : 40 | | max_buyer_tx_fee : 100 | max_buyer_tx_fee : 200000 | | currency_id : 'FET' | currency_id : 'ETH' | | ledger_id : 'fetchai' | ledger_id : 'ethereum' | | is_ledger_tx : True | is_ledger_tx : True | | search_query : | search_query : | | search_term : country | search_term : country | | search_value : UK | search_value : UK | | constraint_type : '==' | constraint_type : '==' | |ledgers : [ 'fetchai' ] |ledgers : [ 'ethereum' ] | | ----------------------------------------------------------------------| After changing the skill config files you should run the following command for both agents to install each dependency: aea install Modify the seller's strategy Open the strategy.py with your IDE and modify the following. Import the newly installed library to your strategy. import sqlalchemy as db Then modify your strategy's __init__ function to match the following code: def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize the strategy of the agent. :param register_as: determines whether the agent registers as seller, buyer or both :param search_for: determines whether the agent searches for sellers, buyers or both :return: None \"\"\" self . _seller_tx_fee = kwargs . pop ( \"seller_tx_fee\" , DEFAULT_SELLER_TX_FEE ) self . _currency_id = kwargs . pop ( \"currency_id\" , DEFAULT_CURRENCY_PBK ) self . _ledger_id = kwargs . pop ( \"ledger_id\" , DEFAULT_LEDGER_ID ) self . is_ledger_tx = kwargs . pop ( \"is_ledger_tx\" , DEFAULT_IS_LEDGER_TX ) self . _total_price = kwargs . pop ( \"total_price\" , DEFAULT_TOTAL_PRICE ) self . _has_data_source = kwargs . pop ( \"has_data_source\" , DEFAULT_HAS_DATA_SOURCE ) self . _db_engine = db . create_engine ( 'sqlite:///genericdb.db' ) self . _tbl = self . create_database_and_table () self . insert_data () # Read the data from the sensor if the bool is set to True. # Enables us to let the user implement his data collection logic without major changes. if self . _has_data_source : self . _data_for_sale = self . collect_from_data_source () else : self . _data_for_sale = kwargs . pop ( \"data_for_sale\" , DEFAULT_DATA_FOR_SALE ) super () . __init__ ( ** kwargs ) self . _oef_msg_id = 0 self . _scheme = kwargs . pop ( \"search_data\" ) self . _datamodel = kwargs . pop ( \"search_schema\" ) At the end of the file modify the collect_from_data_source function : def collect_from_data_source ( self ) -> Dict [ str , Any ]: connection = self . _db_engine . connect () query = db . select ([ self . _tbl ]) result_proxy = connection . execute ( query ) return { \"data\" : result_proxy . fetchall ()} Also, create two new functions, one that will create a connection with the database, and another one will populate the database with some fake data: def create_database_and_table ( self ): \"\"\"Creates a database and a table to store the data if not exists.\"\"\" metadata = db . MetaData () tbl = db . Table ( 'data' , metadata , db . Column ( 'timestamp' , db . Integer ()), db . Column ( 'temprature' , db . String ( 255 ), nullable = False ), ) metadata . create_all ( self . _db_engine ) return tbl def insert_data ( self ): \"\"\"Insert data in the database.\"\"\" connection = self . _db_engine . connect () logger . info ( \"Populating the database....\" ) for counter in range ( 10 ): query = db . insert ( self . _tbl ) . values ( timestamp = time . time (), temprature = str ( random . randrange ( 10 , 25 ))) connection . execute ( query ) Fund the buyer AEA To create some wealth for your buyer AEA based on the network you want to transact with: On the Fetch.ai testnet network. aea generate-wealth fetchai On the Ethereum rospten network. aea generate-wealth ethereum Run the AEAs You can change the endpoint's address and port by modifying the connection's yaml file (my_seller_aea/connection/oef/connection.yaml) Under config locate : addr: ${ OEF_ADDR : 127.0.0.1 } and replace it with your ip (The ip of the machine that runs the oef image.) Run both AEAs from their respective terminals aea add connection fetchai/oef:0.1.0 aea install aea run --connections fetchai/oef:0.1.0 You will see that the AEAs negotiate and then transact using the Fetch.ai testnet. Delete the AEAs When you're done, go up a level and delete the AEAs. cd .. aea delete my_seller_aea aea delete my_buyer_aea Communication This diagram shows the communication between the various entities as data is successfully sold by the seller AEA to the buyer. sequenceDiagram participant Search participant Buyer_AEA participant Seller_AEA participant Blockchain activate Buyer_AEA activate Search activate Seller_AEA activate Blockchain Seller_AEA->>Search: register_service Buyer_AEA->>Search: search Search-->>Buyer_AEA: list_of_agents Buyer_AEA->>Seller_AEA: call_for_proposal Seller_AEA->>Buyer_AEA: propose Buyer_AEA->>Seller_AEA: accept Seller_AEA->>Buyer_AEA: match_accept Buyer_AEA->>Blockchain: transfer_funds Buyer_AEA->>Seller_AEA: send_transaction_hash Seller_AEA->>Blockchain: check_transaction_status Seller_AEA->>Buyer_AEA: send_data deactivate Buyer_AEA deactivate Search deactivate Seller_AEA deactivate Blockchain","title":"ORM integration"},{"location":"aea/orm-integration-to-generic/#discussion","text":"Object-relational-mapping is the idea of being able to write SQL queries, using the object-oriented paradigm of your preferred programming language. The scope of the specific demo is to demonstrate how to create an easy configurable AEA that reads data from a database using ORMs. This demo will not use any smart contract, because these would be out of the scope of the tutorial. We assume, that you followed the guide for the generic-skills. We assume, that we have a database genericdb.db with table name data . This table contains the following columns timestamp and thermometer We assume, that we have a hardware thermometer sensor that adds the readings in the genericdb database Since the AEA framework enables us to use third-party libraries hosted on PyPI we can directly reference the external dependencies. The aea install command will install each dependency that the specific AEA needs and is listed in the skill's YAML file.","title":"Discussion"},{"location":"aea/orm-integration-to-generic/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/orm-integration-to-generic/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/orm-integration-to-generic/#launch-an-oef-search-and-communication-node","text":"In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for all the following demos.","title":"Launch an OEF search and communication node"},{"location":"aea/orm-integration-to-generic/#demo-ledger-payment","text":"A demo to run a scenario with a true ledger transaction on Fetch.ai testnet network or Ethereum ropsten network. This demo assumes the buyer trusts the seller AEA to send the data upon successful payment.","title":"Demo: Ledger payment"},{"location":"aea/orm-integration-to-generic/#create-the-seller-aea-ledger-version","text":"Create the AEA that will provide data. aea create my_seller_aea cd my_seller_aea aea add connection fetchai/oef:0.1.0 aea add skill fetchai/generic_seller:0.1.0","title":"Create the seller AEA (ledger version)"},{"location":"aea/orm-integration-to-generic/#create-the-buyer-client-ledger-version","text":"In another terminal, create the AEA that will query the seller AEA. aea create my_buyer_aea cd my_buyer_aea aea add connection fetchai/oef:0.1.0 aea add skill fetchai/generic_buyer:0.1.0 Additionally, create the private key for the buyer AEA based on the network you want to transact. To generate and add a key for Fetch.ai use: aea generate-key fetchai aea add-key fetchai fet_private_key.txt To generate and add a key for Ethereum use: aea generate-key ethereum aea add-key ethereum eth_private_key.txt","title":"Create the buyer client (ledger version)"},{"location":"aea/orm-integration-to-generic/#update-the-aea-configs","text":"Both in my_seller_aea/aea-config.yaml and my_buyer_aea/aea-config.yaml , replace ledger_apis: {} with the following based on the network you want to connect To connect to Fetchai: ledger_apis : fetchai : network : testnet To connect to Ethereum: ledger_apis : ethereum : address : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 gas_price : 50","title":"Update the AEA configs"},{"location":"aea/orm-integration-to-generic/#update-the-seller-aea-skill-configs","text":"In my_seller_aea/vendor/fetchai/generi_seller/skill.yaml , replace the data_for_sale , search_schema , and search_data with your data: | ----------------------------------------------------------------------| | FETCHAI | ETHEREUM | | -----------------------------------|----------------------------------| |models : |models : | | strategy : | strategy : | | class_name : Strategy | class_name : Strategy | | args : | args : | | total_price : 10 | total_price : 10 | | seller_tx_fee : 0 | seller_tx_fee : 0 | | currency_id : 'FET' | currency_id : 'ETH' | | ledger_id : 'fetchai' | ledger_id : 'ethereum' | | is_ledger_tx : True | is_ledger_tx : True | | has_data_source : True | has_data_source : True | | data_for_sale : {} | data_for_sale : {} | | search_schema : | search_schema : | | attribute_one : | attribute_one : | | name : country | name : country | | type : str | type : str | | is_required : True | is_required : True | | attribute_two : | attribute_two : | | name : city | name : city | | type : str | type : str | | is_required : True | is_required : True | | search_data : | search_data : | | country : UK | country : UK | | city : Cambridge | city : Cambridge | |dependencies |dependencies : | | SQLAlchemy : {} | SQLAlchemy : {} | | ----------------------------------------------------------------------| The search_schema and the search_data are used to register the service in the OEF search node and make your agent discoverable. The name of each attribute must be a key in the search_data dictionary. In the generic buyer skill config ( my_buyer_aea/skills/generic_buyer/skill.yaml ) under strategy change the currency_id , ledger_id , and at the bottom of the file the ledgers . | ----------------------------------------------------------------------| | FETCHAI | ETHEREUM | | -----------------------------------|----------------------------------| |models : |models : | | strategy : | strategy : | | class_name : Strategy | class_name : Strategy | | args : | args : | | max_price : 40 | max_price : 40 | | max_buyer_tx_fee : 100 | max_buyer_tx_fee : 200000 | | currency_id : 'FET' | currency_id : 'ETH' | | ledger_id : 'fetchai' | ledger_id : 'ethereum' | | is_ledger_tx : True | is_ledger_tx : True | | search_query : | search_query : | | search_term : country | search_term : country | | search_value : UK | search_value : UK | | constraint_type : '==' | constraint_type : '==' | |ledgers : [ 'fetchai' ] |ledgers : [ 'ethereum' ] | | ----------------------------------------------------------------------| After changing the skill config files you should run the following command for both agents to install each dependency: aea install","title":"Update the seller AEA skill configs"},{"location":"aea/orm-integration-to-generic/#modify-the-sellers-strategy","text":"Open the strategy.py with your IDE and modify the following. Import the newly installed library to your strategy. import sqlalchemy as db Then modify your strategy's __init__ function to match the following code: def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize the strategy of the agent. :param register_as: determines whether the agent registers as seller, buyer or both :param search_for: determines whether the agent searches for sellers, buyers or both :return: None \"\"\" self . _seller_tx_fee = kwargs . pop ( \"seller_tx_fee\" , DEFAULT_SELLER_TX_FEE ) self . _currency_id = kwargs . pop ( \"currency_id\" , DEFAULT_CURRENCY_PBK ) self . _ledger_id = kwargs . pop ( \"ledger_id\" , DEFAULT_LEDGER_ID ) self . is_ledger_tx = kwargs . pop ( \"is_ledger_tx\" , DEFAULT_IS_LEDGER_TX ) self . _total_price = kwargs . pop ( \"total_price\" , DEFAULT_TOTAL_PRICE ) self . _has_data_source = kwargs . pop ( \"has_data_source\" , DEFAULT_HAS_DATA_SOURCE ) self . _db_engine = db . create_engine ( 'sqlite:///genericdb.db' ) self . _tbl = self . create_database_and_table () self . insert_data () # Read the data from the sensor if the bool is set to True. # Enables us to let the user implement his data collection logic without major changes. if self . _has_data_source : self . _data_for_sale = self . collect_from_data_source () else : self . _data_for_sale = kwargs . pop ( \"data_for_sale\" , DEFAULT_DATA_FOR_SALE ) super () . __init__ ( ** kwargs ) self . _oef_msg_id = 0 self . _scheme = kwargs . pop ( \"search_data\" ) self . _datamodel = kwargs . pop ( \"search_schema\" ) At the end of the file modify the collect_from_data_source function : def collect_from_data_source ( self ) -> Dict [ str , Any ]: connection = self . _db_engine . connect () query = db . select ([ self . _tbl ]) result_proxy = connection . execute ( query ) return { \"data\" : result_proxy . fetchall ()} Also, create two new functions, one that will create a connection with the database, and another one will populate the database with some fake data: def create_database_and_table ( self ): \"\"\"Creates a database and a table to store the data if not exists.\"\"\" metadata = db . MetaData () tbl = db . Table ( 'data' , metadata , db . Column ( 'timestamp' , db . Integer ()), db . Column ( 'temprature' , db . String ( 255 ), nullable = False ), ) metadata . create_all ( self . _db_engine ) return tbl def insert_data ( self ): \"\"\"Insert data in the database.\"\"\" connection = self . _db_engine . connect () logger . info ( \"Populating the database....\" ) for counter in range ( 10 ): query = db . insert ( self . _tbl ) . values ( timestamp = time . time (), temprature = str ( random . randrange ( 10 , 25 ))) connection . execute ( query )","title":"Modify the seller's strategy"},{"location":"aea/orm-integration-to-generic/#fund-the-buyer-aea","text":"To create some wealth for your buyer AEA based on the network you want to transact with: On the Fetch.ai testnet network. aea generate-wealth fetchai On the Ethereum rospten network. aea generate-wealth ethereum","title":"Fund the buyer AEA"},{"location":"aea/orm-integration-to-generic/#run-the-aeas","text":"You can change the endpoint's address and port by modifying the connection's yaml file (my_seller_aea/connection/oef/connection.yaml) Under config locate : addr: ${ OEF_ADDR : 127.0.0.1 } and replace it with your ip (The ip of the machine that runs the oef image.) Run both AEAs from their respective terminals aea add connection fetchai/oef:0.1.0 aea install aea run --connections fetchai/oef:0.1.0 You will see that the AEAs negotiate and then transact using the Fetch.ai testnet.","title":"Run the AEAs"},{"location":"aea/orm-integration-to-generic/#delete-the-aeas","text":"When you're done, go up a level and delete the AEAs. cd .. aea delete my_seller_aea aea delete my_buyer_aea","title":"Delete the AEAs"},{"location":"aea/orm-integration-to-generic/#communication","text":"This diagram shows the communication between the various entities as data is successfully sold by the seller AEA to the buyer. sequenceDiagram participant Search participant Buyer_AEA participant Seller_AEA participant Blockchain activate Buyer_AEA activate Search activate Seller_AEA activate Blockchain Seller_AEA->>Search: register_service Buyer_AEA->>Search: search Search-->>Buyer_AEA: list_of_agents Buyer_AEA->>Seller_AEA: call_for_proposal Seller_AEA->>Buyer_AEA: propose Buyer_AEA->>Seller_AEA: accept Seller_AEA->>Buyer_AEA: match_accept Buyer_AEA->>Blockchain: transfer_funds Buyer_AEA->>Seller_AEA: send_transaction_hash Seller_AEA->>Blockchain: check_transaction_status Seller_AEA->>Buyer_AEA: send_data deactivate Buyer_AEA deactivate Search deactivate Seller_AEA deactivate Blockchain","title":"Communication"},{"location":"aea/package-imports/","text":"An agent that is generated from the AEA framework is a modular system with different skills, connections, and protocols. When we create a new agent with the command aea create my_aea we create the file structure that looks like the following : - connections - protocols - skills - vendor - aea-config.yaml The vendor folder contains the packages from the registry which have been developed by other authors or ourselves and are namespaced by author name. The packages we developed as part of the given AEA project are in the respective connections, protocols, and skills folders. To use a package, the public_id for the package must be listed in the aea-config.yaml file. connections : - fetchai/stub:0.1.0 The above shows a part of the aea-config.yaml . If you see the connections, you will see that we follow a pattern of author/name_package:version to identify each package. The author that we are using is the author of the package and not the author that shows the aea-config.yaml file. This indicates, that we are using a package that is made by Fetch.ai and is located inside the vendor/fetchai/connections folder. The way we import packages inside the agent is in the form of packages.author.package_type.package_name.module_name . So for the above example, the import path is packages.fetchai.connections.stub.module_name . The framework loads the modules from the local agent project and adds them to Python's sys.modules under the respective path. Create a package If you want to create a package, you can use aea scaffold connection/skill/protocol name and this will create the package and put it inside the respective folder based on the command for example if we scaffold skill with the name my_skill it will be located inside the folder skills in the root directory of the agent ( my_aea/skills/my_skill ). On the other hand, if you use a package from the registry or the packages folder that comes along with the AEA framework, you will be able to locate the package under the folder vendor . To sum up, the packages you have developed in the context of the given AEA project should be in the root folders and all the other packages under the vendor folder. Difference of vendor and own packages The main difference of the packages that are located under the vendor folder and your own is that these packages are located under the vendor folder based on the author. For example, all the packages that we are using are under the folder vendor/fetchai Your packages exist in the root directory of your aea . Name and author When you create a package, you must change the author name in the package to match your author handle. You can find these inside the .yaml file of your newly created package.","title":"Package structure"},{"location":"aea/package-imports/#create-a-package","text":"If you want to create a package, you can use aea scaffold connection/skill/protocol name and this will create the package and put it inside the respective folder based on the command for example if we scaffold skill with the name my_skill it will be located inside the folder skills in the root directory of the agent ( my_aea/skills/my_skill ). On the other hand, if you use a package from the registry or the packages folder that comes along with the AEA framework, you will be able to locate the package under the folder vendor . To sum up, the packages you have developed in the context of the given AEA project should be in the root folders and all the other packages under the vendor folder.","title":"Create a package"},{"location":"aea/package-imports/#difference-of-vendor-and-own-packages","text":"The main difference of the packages that are located under the vendor folder and your own is that these packages are located under the vendor folder based on the author. For example, all the packages that we are using are under the folder vendor/fetchai Your packages exist in the root directory of your aea .","title":"Difference of vendor and own packages"},{"location":"aea/package-imports/#name-and-author","text":"When you create a package, you must change the author name in the package to match your author handle. You can find these inside the .yaml file of your newly created package.","title":"Name and author"},{"location":"aea/protocol-generator/","text":"Note This is currently an experimental feature. To try it follow this guide. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. How to run First make sure you are inside your AEA's folder (see here on how to create a new agent). Then run aea generate protocol <path-to-protocol-specification> where <path-to-protocol-specification> is the relative path to a protocol specification file. If there are no errors, this command will generate the protocol and place it in your AEA project. The name of the protocol's directory will match the protocol name given in the specification. Protocol Specification A protocol can be described in a yaml file. As such, it needs to follow the yaml format . The following is an example protocol specification: name : two_party_negotiation author : fetchai version : 0.1.0 license : Apache-2.0 description : 'A protocol for negotiation over a fixed set of resources involving two parties.' speech_acts : cfp : query : ct:DataModel propose : query : ct:DataModel price : pt:float accept : {} decline : {} match_accept : {} Each protocol specification yaml file contains some basic information about the protocol. The allowed fields and what they represent are: name : The name of the protocol (written in snake_case ) authors : List of authors version : The current version of the protocol license : Licensing information description : A short description of the protocol Each field is a key/value pair, where both the key and the value are yaml strings. Every field is mandatory. In addition to the above basic information, a protocol specification must describe the syntax of valid messages according to this protocol. Therefore, there is another mandatory field: speech-acts , which defines the set of performatives valid under this protocol, and a set of contents (i.e. parameters) for each performative. The format of the speech-act is as follows: speech-act is a dictionary, where each key is a unique performative (yaml string), and the value is a content dictionary. If a performative does not have any content, then its content dictionary is empty, e.g. accept , decline and match_accept in the above protocol specification. Each content dictionary is composed of key/value pairs, where each key is the name of a content (yaml string) and the value is its type (yaml string). For example, the query performative has one content whose name is query and whose type is ct:DataModel . Types The specific types which could be assigned to contents in a protocol specification are described in the table below. Types are either user defined (i.e. custom types) or primitive: Custom types are prepended with ct: and their format is described using regular expression in the table below. Primitive types are prepended with pt: . There are different categories of primitive types, e.g. <PT> such as integers and booleans, <PCT> such as sets and lists, and so on. Primitive types are compositional: For example, consider pt:set under <PCT>, i.e. an unordered collection of elements without duplicates. A pt:set describes the type of its elements (called \"sub-type\") in square brackets. The sub-type of a pt:set could either be a <PT> (e.g. pt:int , pt:bool ) or <CT> (i.e. a custom type). In describing the format of types, / between two sub-types should be treated as \"or\". For example, the sub-type of a pt:set is either a <PT> or a <CT>. A multi type denotes an \"or\" separated set of sub-types, e.g. pt:union[pt:str, pt:int] as the type of a content c means c is either a pt:int or a pt:float . An optional type for a content denotes that the content's existence is optional, but if it is present, its type must match pt:optional 's sub-type. Type Code Format Example In Python Custom types <CT> ct:RegExp(^[A-Z][a-zA-Z0-9]*$) ct:DataModel Custom Class Primitive types <PT> pt:bytes pt:bytes bytes pt:int pt:int int pt:float pt:float float pt:bool pt:bool bool pt:str pt:str str Primitive collection types <PCT> pt:set[<PT>/<CT>] pt:set[ct:DataModel] FrozenSet[DataModel] pt:list[<PT>/<CT>] pt:list[pt:int] Tuple[int, ...] * Primitive mapping types <PMT> pt:dict[<PT>/<CT>, <PT>/<CT>] pt:dict[pt:bool, ct:DataModel] Dict[bool, DataModel] Multi types <MT> pt:union[<PT>/<CT>/<PCT>/<PMT>, ..., <PT>/<CT>/<PCT>/<PMT>] pt:union[pt:str, pt:set[ct:DataModel]] Union[str, int] Optional types <O> pt:optional[<MT>/<PMT>/<PCT>/<PT>/<CT>] pt:optional[pt:bool] Optional[bool] * This is how variable length tuples containing elements of the same type are declared in Python; see here Demo instructions First, create a new AEA project: aea create my_aea cd my_aea Second, run the generator on the sample specification: aea generate protocol ../examples/protocol_specification_ex/sample.yaml This will generate the protocol and place it in your AEA project. Third, try generating other protocols by first defining a specification, then running the generator.","title":"Generating protocols"},{"location":"aea/protocol-generator/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/protocol-generator/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/protocol-generator/#how-to-run","text":"First make sure you are inside your AEA's folder (see here on how to create a new agent). Then run aea generate protocol <path-to-protocol-specification> where <path-to-protocol-specification> is the relative path to a protocol specification file. If there are no errors, this command will generate the protocol and place it in your AEA project. The name of the protocol's directory will match the protocol name given in the specification.","title":"How to run"},{"location":"aea/protocol-generator/#protocol-specification","text":"A protocol can be described in a yaml file. As such, it needs to follow the yaml format . The following is an example protocol specification: name : two_party_negotiation author : fetchai version : 0.1.0 license : Apache-2.0 description : 'A protocol for negotiation over a fixed set of resources involving two parties.' speech_acts : cfp : query : ct:DataModel propose : query : ct:DataModel price : pt:float accept : {} decline : {} match_accept : {} Each protocol specification yaml file contains some basic information about the protocol. The allowed fields and what they represent are: name : The name of the protocol (written in snake_case ) authors : List of authors version : The current version of the protocol license : Licensing information description : A short description of the protocol Each field is a key/value pair, where both the key and the value are yaml strings. Every field is mandatory. In addition to the above basic information, a protocol specification must describe the syntax of valid messages according to this protocol. Therefore, there is another mandatory field: speech-acts , which defines the set of performatives valid under this protocol, and a set of contents (i.e. parameters) for each performative. The format of the speech-act is as follows: speech-act is a dictionary, where each key is a unique performative (yaml string), and the value is a content dictionary. If a performative does not have any content, then its content dictionary is empty, e.g. accept , decline and match_accept in the above protocol specification. Each content dictionary is composed of key/value pairs, where each key is the name of a content (yaml string) and the value is its type (yaml string). For example, the query performative has one content whose name is query and whose type is ct:DataModel .","title":"Protocol Specification"},{"location":"aea/protocol-generator/#types","text":"The specific types which could be assigned to contents in a protocol specification are described in the table below. Types are either user defined (i.e. custom types) or primitive: Custom types are prepended with ct: and their format is described using regular expression in the table below. Primitive types are prepended with pt: . There are different categories of primitive types, e.g. <PT> such as integers and booleans, <PCT> such as sets and lists, and so on. Primitive types are compositional: For example, consider pt:set under <PCT>, i.e. an unordered collection of elements without duplicates. A pt:set describes the type of its elements (called \"sub-type\") in square brackets. The sub-type of a pt:set could either be a <PT> (e.g. pt:int , pt:bool ) or <CT> (i.e. a custom type). In describing the format of types, / between two sub-types should be treated as \"or\". For example, the sub-type of a pt:set is either a <PT> or a <CT>. A multi type denotes an \"or\" separated set of sub-types, e.g. pt:union[pt:str, pt:int] as the type of a content c means c is either a pt:int or a pt:float . An optional type for a content denotes that the content's existence is optional, but if it is present, its type must match pt:optional 's sub-type. Type Code Format Example In Python Custom types <CT> ct:RegExp(^[A-Z][a-zA-Z0-9]*$) ct:DataModel Custom Class Primitive types <PT> pt:bytes pt:bytes bytes pt:int pt:int int pt:float pt:float float pt:bool pt:bool bool pt:str pt:str str Primitive collection types <PCT> pt:set[<PT>/<CT>] pt:set[ct:DataModel] FrozenSet[DataModel] pt:list[<PT>/<CT>] pt:list[pt:int] Tuple[int, ...] * Primitive mapping types <PMT> pt:dict[<PT>/<CT>, <PT>/<CT>] pt:dict[pt:bool, ct:DataModel] Dict[bool, DataModel] Multi types <MT> pt:union[<PT>/<CT>/<PCT>/<PMT>, ..., <PT>/<CT>/<PCT>/<PMT>] pt:union[pt:str, pt:set[ct:DataModel]] Union[str, int] Optional types <O> pt:optional[<MT>/<PMT>/<PCT>/<PT>/<CT>] pt:optional[pt:bool] Optional[bool] * This is how variable length tuples containing elements of the same type are declared in Python; see here","title":"Types"},{"location":"aea/protocol-generator/#demo-instructions","text":"First, create a new AEA project: aea create my_aea cd my_aea Second, run the generator on the sample specification: aea generate protocol ../examples/protocol_specification_ex/sample.yaml This will generate the protocol and place it in your AEA project. Third, try generating other protocols by first defining a specification, then running the generator.","title":"Demo instructions"},{"location":"aea/protocol/","text":"A Protocol manages message representation (syntax, message.py ), optionally rules of the message exchange (semantics, dialogues.py ), as well as encoding, and decoding ( serialization.py ). All protocols are for point to point interaction between two agents. Agents can be AEAs or other types of agent-like services. Metadata Each Message in an interaction protocol has a set of default metadata, this includes: dialogue_reference: Tuple[str, str] , a reference of the dialogue the message is part of. The first part of the tuple is the reference assigned to by the dialogue initiator, the second part of the tuple is the reference assigned to by the dialogue responder. The default value is (\"\", \"\") . message_id: int , the id of the message. The default value is 1 . target: int , the id of the message which is referenced by this message. The default value is 0 . By default, dialogue_reference , message_id and target are set, however, most interactions involve more than one message being sent as part of the interaction and potentially multiple simultaneous interactions utilising the same protocol. In those cases, the dialogue_reference allows different interactions to be identified as such. The message_id and target are used to keep reference to the preceding messages in a dialogue for a given interaction. For instance, following receipt of a message with target=0 and message_id=1 the responding AEA should respond with a message_id=2 and target=1 . In particular, target holds the id of the message being referenced. This can be the preceding message, it can also be an older message. Hence, 0 < target < message_id for message_id > 1 and target=0 if message_id = 1 . Custom protocol The developer can generate custom protocols with the protocol generator . fetchai/default:0.1.0 protocol The fetchai/default:0.1.0 protocol is a protocol which each AEA is meant to implement. It serves AEA to AEA interaction and includes two message performatives: class Performative ( Enum ): \"\"\"Performatives for the default protocol.\"\"\" BYTES = \"bytes\" ERROR = \"error\" def __str__ ( self ): \"\"\"Get the string representation.\"\"\" return self . value The DefaultMessage of performative DefaultMessage.Performative.BYTES is used to send payloads of byte strings to other AEAs. An example is: msg = DefaultMessage ( performative = DefaultMessage . Performative . BYTES , content = b \"This is a bytes payload\" , ) The DefaultMessage of performative DefaultMessage.Performative.ERROR is used to notify other AEAs of errors in an interaction, including errors with other protocols, by including an error_code in the payload: class ErrorCode ( Enum ): \"\"\"This class represents an instance of ErrorCode.\"\"\" UNSUPPORTED_PROTOCOL = 0 DECODING_ERROR = 1 INVALID_MESSAGE = 2 UNSUPPORTED_SKILL = 3 INVALID_DIALOGUE = 4 An example is: msg = DefaultMessage ( performative = DefaultMessage . Performative . ERROR , error_code = DefaultMessage . ErrorCode . UNSUPPORTED_PROTOCOL , error_msg = \"This protocol is not supported by this AEA.\" , error_data = { \"unsupported_msg\" : b \"serialized unsupported protocol message\" }, ) Each AEA's fetchai/error:0.1.0 skill utilises the fetchai/default:0.1.0 protocol for error handling. fetchai/oef_search:0.1.0 protocol The fetchai/oef_search:0.1.0 protocol is used by AEAs to interact with an OEF search node to register and unregister their own services and search for services registered by other agents. The fetchai/oef_search:0.1.0 protocol definition includes an OefSearchMessage with the following message types: class Performative ( Enum ): \"\"\"Performatives for the oef_search protocol.\"\"\" REGISTER_SERVICE = \"register_service\" UNREGISTER_SERVICE = \"unregister_service\" SEARCH_SERVICES = \"search_services\" OEF_ERROR = \"oef_error\" SEARCH_RESULT = \"search_result\" def __str__ ( self ): \"\"\"Get string representation.\"\"\" return self . value We show some example messages below: To register a service, we require a reference to the dialogue in string form (used to keep different dialogues apart), for instance my_dialogue_reference = \"a_unique_register_service_dialogue_reference\" and a description of the service we would like to register, for instance my_service_data = { \"country\" : \"UK\" , \"city\" : \"Cambridge\" } my_service_description = Description ( my_service_data , data_model = my_data_model , ) where we use, for instance from aea.helpers.search.generic import GenericDataModel data_model_name = \"location\" data_model = { \"attribute_one\" : { \"name\" : \"country\" , \"type\" : \"str\" , \"is_required\" : \"True\" , }, \"attribute_two\" : { \"name\" : \"city\" , \"type\" : \"str\" , \"is_required\" : \"True\" , }, } my_data_model = GenericDataModel ( data_model_name , data_model ) We can then create the message to register this service: msg = OefSearchMessage ( performative = OefSearchMessage . Performative . REGISTER_SERVICE , dialogue_reference = ( my_dialogue_reference , \"\" ), service_description = my_service_description , ) To unregister a service, we require a reference to the dialogue in string form, for instance my_dialogue_reference = \"a_unique_unregister_service_dialogue_reference\" the description of the service we would like to unregister, say my_service_description from above and construct the message: msg = OefSearchMessage ( performative = OefSearchMessage . Performative . UNREGISTER_SERVICE , dialogue_reference = ( my_dialogue_reference , \"\" ), service_description = my_service_description , ) To search a service, we require a reference to the dialogue in string form, for instance my_dialogue_reference = \"a_unique_search_dialogue_reference\" and a query we would like the search node to evaluate, for instance from aea.helpers.search.models import Constraint , ConstraintType , Query query_data = { \"search_term\" : \"country\" , \"search_value\" : \"UK\" , \"constraint_type\" : \"==\" , } query = Query ( [ Constraint ( query_data [ \"search_term\" ], ConstraintType ( query_data [ \"constraint_type\" ], query_data [ \"search_value\" ], ), ) ], model = None , ) We can then create the message to search these services: oef_msg = OefSearchMessage ( performative = OefSearchMessage . Performative . SEARCH_SERVICES , dialogue_reference = ( my_dialogue_reference , \"\" ), query = query , ) The OEF search node will respond with a message, say msg of type OefSearchMessage , of performative OefSearchMessage.Performative.SEARCH_RESULT . To access the tuple of agents which match the query, simply use msg.agents . In particular, this will return the agent addresses matching the query. The agent address can then be used to send a message to the agent utilising the OEF communication node and any protocol other than fetchai/oef_search:0.1.0 . If the OEF search node encounters any errors with the messages you send, it will return an OefSearchMessage of performative OefSearchMessage.Performative.OEF_ERROR and indicate the error operation encountered: class OefErrorOperation ( Enum ): \"\"\"This class represents an instance of OefErrorOperation.\"\"\" REGISTER_SERVICE = 0 UNREGISTER_SERVICE = 1 SEARCH_SERVICES = 2 SEND_MESSAGE = 3 OTHER = 10000 fetchai/fipa:0.1.0 protocol The fetchai/fipa:0.1.0 protocol definition includes a FipaMessage with the following performatives: class Performative ( Enum ): \"\"\"Performatives for the fipa protocol.\"\"\" ACCEPT = \"accept\" ACCEPT_W_INFORM = \"accept_w_inform\" CFP = \"cfp\" DECLINE = \"decline\" INFORM = \"inform\" MATCH_ACCEPT = \"match_accept\" MATCH_ACCEPT_W_INFORM = \"match_accept_w_inform\" PROPOSE = \"propose\" def __str__ ( self ): \"\"\"Get string representation.\"\"\" return self . value FipaMessages are constructed with a performative , dialogue_reference , message_id , and target as well as the kwargs specific to each message performative. def __init__ ( self , performative : Performative , dialogue_reference : Tuple [ str , str ] = ( \"\" , \"\" ), message_id : int = 1 , target : int = 0 , ** kwargs , ) For examples of the usage of the fetchai/fipa:0.1.0 protocol check out the thermometer skill step by step guide .","title":"Protocol"},{"location":"aea/protocol/#metadata","text":"Each Message in an interaction protocol has a set of default metadata, this includes: dialogue_reference: Tuple[str, str] , a reference of the dialogue the message is part of. The first part of the tuple is the reference assigned to by the dialogue initiator, the second part of the tuple is the reference assigned to by the dialogue responder. The default value is (\"\", \"\") . message_id: int , the id of the message. The default value is 1 . target: int , the id of the message which is referenced by this message. The default value is 0 . By default, dialogue_reference , message_id and target are set, however, most interactions involve more than one message being sent as part of the interaction and potentially multiple simultaneous interactions utilising the same protocol. In those cases, the dialogue_reference allows different interactions to be identified as such. The message_id and target are used to keep reference to the preceding messages in a dialogue for a given interaction. For instance, following receipt of a message with target=0 and message_id=1 the responding AEA should respond with a message_id=2 and target=1 . In particular, target holds the id of the message being referenced. This can be the preceding message, it can also be an older message. Hence, 0 < target < message_id for message_id > 1 and target=0 if message_id = 1 .","title":"Metadata"},{"location":"aea/protocol/#custom-protocol","text":"The developer can generate custom protocols with the protocol generator .","title":"Custom protocol"},{"location":"aea/protocol/#fetchaidefault010-protocol","text":"The fetchai/default:0.1.0 protocol is a protocol which each AEA is meant to implement. It serves AEA to AEA interaction and includes two message performatives: class Performative ( Enum ): \"\"\"Performatives for the default protocol.\"\"\" BYTES = \"bytes\" ERROR = \"error\" def __str__ ( self ): \"\"\"Get the string representation.\"\"\" return self . value The DefaultMessage of performative DefaultMessage.Performative.BYTES is used to send payloads of byte strings to other AEAs. An example is: msg = DefaultMessage ( performative = DefaultMessage . Performative . BYTES , content = b \"This is a bytes payload\" , ) The DefaultMessage of performative DefaultMessage.Performative.ERROR is used to notify other AEAs of errors in an interaction, including errors with other protocols, by including an error_code in the payload: class ErrorCode ( Enum ): \"\"\"This class represents an instance of ErrorCode.\"\"\" UNSUPPORTED_PROTOCOL = 0 DECODING_ERROR = 1 INVALID_MESSAGE = 2 UNSUPPORTED_SKILL = 3 INVALID_DIALOGUE = 4 An example is: msg = DefaultMessage ( performative = DefaultMessage . Performative . ERROR , error_code = DefaultMessage . ErrorCode . UNSUPPORTED_PROTOCOL , error_msg = \"This protocol is not supported by this AEA.\" , error_data = { \"unsupported_msg\" : b \"serialized unsupported protocol message\" }, ) Each AEA's fetchai/error:0.1.0 skill utilises the fetchai/default:0.1.0 protocol for error handling.","title":"fetchai/default:0.1.0 protocol"},{"location":"aea/protocol/#fetchaioef_search010-protocol","text":"The fetchai/oef_search:0.1.0 protocol is used by AEAs to interact with an OEF search node to register and unregister their own services and search for services registered by other agents. The fetchai/oef_search:0.1.0 protocol definition includes an OefSearchMessage with the following message types: class Performative ( Enum ): \"\"\"Performatives for the oef_search protocol.\"\"\" REGISTER_SERVICE = \"register_service\" UNREGISTER_SERVICE = \"unregister_service\" SEARCH_SERVICES = \"search_services\" OEF_ERROR = \"oef_error\" SEARCH_RESULT = \"search_result\" def __str__ ( self ): \"\"\"Get string representation.\"\"\" return self . value We show some example messages below: To register a service, we require a reference to the dialogue in string form (used to keep different dialogues apart), for instance my_dialogue_reference = \"a_unique_register_service_dialogue_reference\" and a description of the service we would like to register, for instance my_service_data = { \"country\" : \"UK\" , \"city\" : \"Cambridge\" } my_service_description = Description ( my_service_data , data_model = my_data_model , ) where we use, for instance from aea.helpers.search.generic import GenericDataModel data_model_name = \"location\" data_model = { \"attribute_one\" : { \"name\" : \"country\" , \"type\" : \"str\" , \"is_required\" : \"True\" , }, \"attribute_two\" : { \"name\" : \"city\" , \"type\" : \"str\" , \"is_required\" : \"True\" , }, } my_data_model = GenericDataModel ( data_model_name , data_model ) We can then create the message to register this service: msg = OefSearchMessage ( performative = OefSearchMessage . Performative . REGISTER_SERVICE , dialogue_reference = ( my_dialogue_reference , \"\" ), service_description = my_service_description , ) To unregister a service, we require a reference to the dialogue in string form, for instance my_dialogue_reference = \"a_unique_unregister_service_dialogue_reference\" the description of the service we would like to unregister, say my_service_description from above and construct the message: msg = OefSearchMessage ( performative = OefSearchMessage . Performative . UNREGISTER_SERVICE , dialogue_reference = ( my_dialogue_reference , \"\" ), service_description = my_service_description , ) To search a service, we require a reference to the dialogue in string form, for instance my_dialogue_reference = \"a_unique_search_dialogue_reference\" and a query we would like the search node to evaluate, for instance from aea.helpers.search.models import Constraint , ConstraintType , Query query_data = { \"search_term\" : \"country\" , \"search_value\" : \"UK\" , \"constraint_type\" : \"==\" , } query = Query ( [ Constraint ( query_data [ \"search_term\" ], ConstraintType ( query_data [ \"constraint_type\" ], query_data [ \"search_value\" ], ), ) ], model = None , ) We can then create the message to search these services: oef_msg = OefSearchMessage ( performative = OefSearchMessage . Performative . SEARCH_SERVICES , dialogue_reference = ( my_dialogue_reference , \"\" ), query = query , ) The OEF search node will respond with a message, say msg of type OefSearchMessage , of performative OefSearchMessage.Performative.SEARCH_RESULT . To access the tuple of agents which match the query, simply use msg.agents . In particular, this will return the agent addresses matching the query. The agent address can then be used to send a message to the agent utilising the OEF communication node and any protocol other than fetchai/oef_search:0.1.0 . If the OEF search node encounters any errors with the messages you send, it will return an OefSearchMessage of performative OefSearchMessage.Performative.OEF_ERROR and indicate the error operation encountered: class OefErrorOperation ( Enum ): \"\"\"This class represents an instance of OefErrorOperation.\"\"\" REGISTER_SERVICE = 0 UNREGISTER_SERVICE = 1 SEARCH_SERVICES = 2 SEND_MESSAGE = 3 OTHER = 10000","title":"fetchai/oef_search:0.1.0 protocol"},{"location":"aea/protocol/#fetchaifipa010-protocol","text":"The fetchai/fipa:0.1.0 protocol definition includes a FipaMessage with the following performatives: class Performative ( Enum ): \"\"\"Performatives for the fipa protocol.\"\"\" ACCEPT = \"accept\" ACCEPT_W_INFORM = \"accept_w_inform\" CFP = \"cfp\" DECLINE = \"decline\" INFORM = \"inform\" MATCH_ACCEPT = \"match_accept\" MATCH_ACCEPT_W_INFORM = \"match_accept_w_inform\" PROPOSE = \"propose\" def __str__ ( self ): \"\"\"Get string representation.\"\"\" return self . value FipaMessages are constructed with a performative , dialogue_reference , message_id , and target as well as the kwargs specific to each message performative. def __init__ ( self , performative : Performative , dialogue_reference : Tuple [ str , str ] = ( \"\" , \"\" ), message_id : int = 1 , target : int = 0 , ** kwargs , ) For examples of the usage of the fetchai/fipa:0.1.0 protocol check out the thermometer skill step by step guide .","title":"fetchai/fipa:0.1.0 protocol"},{"location":"aea/questions-and-answers/","text":"What is the Open Economic Framework (OEF)? The 'Open Economic Framework' (OEF) is a node that enables search, discovery and communicate with possible clients or services. You can read more about the ledgers and the OEF here What is the AEA? AEA is short for Autonomous Economic Agents. AEAs act independently of constant user input and autonomously execute actions to achieve their objective. Their goal is to create economic value for you, their owner. You can read more about the AEAs here How do agents talk to others when they don't know each other? For the Autonomous Economic Agents (AEAs) to be able to talk to others, firstly they need to find them, and then, implement the same protocols in order to be able to deserialize the envelops they receive. You can read more about the Search and Discovery here and more about envelops and protocols here How does an AEA use blockchain? The AEA framework enables the agents to interact with public blockchains to complete transactions. Currently, the framework supports two different networks natively: the `Fetch.ai` network and the `Ethereum` network. You can read more about the intergration of ledger here How does one install third party libraries? The framework supports the use of third-party libraries hosted on PyPI we can directly reference the external dependencies. The `aea install` command will install each dependency that the specific AEA needs and is listed in the skill's YAML file. How does one connect to a database? You have two options to connect to a database: - Creating a wrapper that communicates with the database and imports a Model. You can find an example implementation in the `weather_station` package - Using an ORM (object-relational mapping) library, and implementing the logic inside a class that inherits from the Model abstract class. For a detailed example of how to use an ORM follow the ORM use case How does one connect to a live-stream of data? You can create a wrapper class that communicates with the source and import this class in your skill, or you can use a third-party library by listing the dependency in the skill's `.yaml` file. Then you can import this library in a strategy class that inherits from the Model abstract class. You can find example of this implementation in the thermometer step by step guide How does one connect a frontend? There are two options that one could connect a frontend. The first option would be to create an HTTP connection and then create an app that will communicate with this connections. The other option is to create a frontend client that will communicate with the agent via the [OEF communication network](../oef-ledger). You can find a more detailed approach here Is the AEA framework ideal for agent-based modeling? The goal of agent-based modeling is to search for explanatory insight into the collective behavior of agents obeying simple rules, typically in natural systems rather than in designing agents or solving specific practical or engineering problems. Although it would be potentially possible, it would be inefficient to use the AEA framework for that kind of problem. You can find more details here Can you manage multiple AEA projects at once with the CLI? Individual CLI calls are currently scoped to a single project. You can have multiple AEA projects in a given root directory but you will have to use the CLI for each project independently. We are looking to add support for interacting with multiple AEA projects via a single CLI call in the future. You can find more details about the CLI commands here When a new AEA is created, is the `vendor` folder populated with some default packages? All AEA projects by default hold the `stub` connection, the `default` protocol and the `error` skill. These (as all other packages installed from the registry) are placed in the vendor's folder. You can find more details about the file structure here Is there a standardization for private key files? Currently, the private keys are stored in `.txt` files. This is temporary and will be improved soon. How to use the same protocol in different skills? By default, envelopes of a given protocol get routed to all skills which have a handler supporting that protocol. The `URI` in the `EnvelopeContext` can be used to route envelopes of a given protocol to a specific skill. The `URI` path needs to be set to the skill's `public_id.to_uri_path`.","title":"Q&A"},{"location":"aea/quickstart/","text":"If you want to create Autonomous Economic Agents (AEAs) that can act independently of constant user input and autonomously execute actions to achieve their objective, you can use the Fetch.ai AEA framework. This example will take you through the simplest AEA in order to make you familiar with the framework. Preliminaries Create and enter into a new working directory. mkdir my_aea_projects/ cd my_aea_projects/ We highly recommend using a virtual environment to ensure consistency across dependencies. Check that you have pipenv . which pipenv If you don't have it, install it. Instructions are here . Once installed, create a new environment and open it (here we use Python 3.7 but the AEA framework supports any Python >= 3.6). touch Pipfile && pipenv --python 3 .7 && pipenv shell Installing docker At some point, you will need Docker installed on your machine (e.g. to run an OEF search and communication node ). Note For the purpose of the quickstart only, you can skip installation of docker. Download the scripts and packages directories Download folders containing examples, scripts and packages: svn export https://github.com/fetchai/agents-aea.git/trunk/examples svn export https://github.com/fetchai/agents-aea.git/trunk/scripts svn export https://github.com/fetchai/agents-aea.git/trunk/packages You can install the svn command with ( brew install subversion or sudo apt-get install subversion ). Note We will soon make packages available on our agent registry. For now you still have to download them manually. Installation The following installs the entire AEA package which also includes a command-line interface (CLI). pip install aea [ all ] If you are using zsh rather than bash type pip install 'aea[all]' Known issues If the installation steps fail, it might be a dependency issue. The following hints can help: Ubuntu/Debian systems only: install Python 3.7 headers. sudo apt-get install python3.7-dev Windows users: install tools for Visual Studio . Setup Author name You can now setup your author name: aea init You should see a similar output: Please enter the author handle you would like to use: fetchai _ _____ _ / \\ | ____ | / \\ / _ \\ | _ | / _ \\ / ___ \\ | | ___ / ___ \\ /_/ \\_\\| _____ | /_/ \\_\\ v0.2.4 AEA configurations successfully initialized: { 'author' : 'fetchai' } Note Once our agent registry becomes available you will have a unique author name in the Fetch.ai ecosystem. Echo skill demo The echo skill is a simple demo that introduces you to the main business logic components of an AEA. The fastest way to create your first AEA is to fetch it! If you want to follow a step by step guide we show you how to do it at the end of the file. aea fetch fetchai/my_first_aea:0.1.0 cd my_first_aea Usage of the stub connection AEAs use envelopes containing messages for communication. We use a stub connection to send envelopes to and receive envelopes from the AEA. The stub connection is already added to the AEA by default. A stub connection provides an I/O reader and writer. It uses two files for communication: one for incoming envelopes and the other for outgoing envelopes. The AEA waits for a new envelope posted to the file my_first_aea/input_file , and adds a response to the file my_first_aea/output_file . The format of each envelope is the following: TO,SENDER,PROTOCOL_ID,ENCODED_MESSAGE, For example: recipient_aea,sender_aea,fetchai/default:0.1.0, \\x 08 \\x 01 * \\x 07 \\n\\x 05hello, Run the AEA Run the AEA with the default stub connection. aea run or aea run --connections fetchai/stub:0.1.0 You will see the echo skill running in the terminal window. _ _____ _ / \\ | ____ | / \\ / _ \\ | _ | / _ \\ / ___ \\ | | ___ / ___ \\ /_/ \\_\\| _____ | /_/ \\_\\ v0.2.4 my_first_aea starting ... info: EchoHandler.__init__: arguments: { 'foo' : 'bar' , 'skill_context' : ..., 'name' : 'echo' } info: EchoBehaviour.__init__: arguments: { 'tick_interval' : 1 .0, 'skill_context' : ..., 'name' : 'echo' } info: Echo Handler: setup method called. info: Echo Behaviour: setup method called. info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. ... The framework first calls the setup method on the Handler , and Behaviour code in that order; after which it repeatedly calls the Behaviour method act. This is the main agent loop in action. Let's look at the Handler in more depth. Add a message to the input file From a different terminal and same directory, we send the AEA a message wrapped in an envelope via the input file. echo 'my_first_aea,sender_aea,fetchai/default:0.1.0,\\x08\\x01*\\x07\\n\\x05hello,' >> input_file You will see the Echo Handler dealing with the envelope and responding with the same message to the output_file , and also decoding the Base64 encrypted message in this case. info: Echo Behaviour: act method called. info: Echo Handler: message = Message ( dialogue_reference =( '' , '' ) message_id = 1 target = 0 performative = bytes content = b 'hello' ) , sender = sender_aea info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. Stop the AEA Stop the AEA by pressing CTRL C Delete the AEA Delete the AEA from the parent directory ( cd .. to go to the parent directory). aea delete my_first_aea For more detailed analysis of the core components of the framework, please check the following: Core components For more demos, use cases or step by step guides, please check the following: Generic skill use case Weather skill demo Thermometer step by step guide Step by step install Create a new AEA First, create a new AEA project and enter it. aea create my_first_aea cd my_first_aea Add the echo skill Second, add the echo skill to the project. aea add skill fetchai/echo:0.1.0 This copies the `echo` skill code containing the \"behaviours\", and \"handlers\" into the skill, ready to run. The identifier of the skill `fetchai/echo:0.1.0` consists of the name of the author of the skill, followed by the skill name and its version.","title":"AEA quick start"},{"location":"aea/quickstart/#preliminaries","text":"Create and enter into a new working directory. mkdir my_aea_projects/ cd my_aea_projects/ We highly recommend using a virtual environment to ensure consistency across dependencies. Check that you have pipenv . which pipenv If you don't have it, install it. Instructions are here . Once installed, create a new environment and open it (here we use Python 3.7 but the AEA framework supports any Python >= 3.6). touch Pipfile && pipenv --python 3 .7 && pipenv shell","title":"Preliminaries"},{"location":"aea/quickstart/#installing-docker","text":"At some point, you will need Docker installed on your machine (e.g. to run an OEF search and communication node ). Note For the purpose of the quickstart only, you can skip installation of docker.","title":"Installing docker"},{"location":"aea/quickstart/#download-the-scripts-and-packages-directories","text":"Download folders containing examples, scripts and packages: svn export https://github.com/fetchai/agents-aea.git/trunk/examples svn export https://github.com/fetchai/agents-aea.git/trunk/scripts svn export https://github.com/fetchai/agents-aea.git/trunk/packages You can install the svn command with ( brew install subversion or sudo apt-get install subversion ). Note We will soon make packages available on our agent registry. For now you still have to download them manually.","title":"Download the scripts and packages directories"},{"location":"aea/quickstart/#installation","text":"The following installs the entire AEA package which also includes a command-line interface (CLI). pip install aea [ all ] If you are using zsh rather than bash type pip install 'aea[all]'","title":"Installation"},{"location":"aea/quickstart/#known-issues","text":"If the installation steps fail, it might be a dependency issue. The following hints can help: Ubuntu/Debian systems only: install Python 3.7 headers. sudo apt-get install python3.7-dev Windows users: install tools for Visual Studio .","title":"Known issues"},{"location":"aea/quickstart/#setup-author-name","text":"You can now setup your author name: aea init You should see a similar output: Please enter the author handle you would like to use: fetchai _ _____ _ / \\ | ____ | / \\ / _ \\ | _ | / _ \\ / ___ \\ | | ___ / ___ \\ /_/ \\_\\| _____ | /_/ \\_\\ v0.2.4 AEA configurations successfully initialized: { 'author' : 'fetchai' } Note Once our agent registry becomes available you will have a unique author name in the Fetch.ai ecosystem.","title":"Setup Author name"},{"location":"aea/quickstart/#echo-skill-demo","text":"The echo skill is a simple demo that introduces you to the main business logic components of an AEA. The fastest way to create your first AEA is to fetch it! If you want to follow a step by step guide we show you how to do it at the end of the file. aea fetch fetchai/my_first_aea:0.1.0 cd my_first_aea","title":"Echo skill demo"},{"location":"aea/quickstart/#usage-of-the-stub-connection","text":"AEAs use envelopes containing messages for communication. We use a stub connection to send envelopes to and receive envelopes from the AEA. The stub connection is already added to the AEA by default. A stub connection provides an I/O reader and writer. It uses two files for communication: one for incoming envelopes and the other for outgoing envelopes. The AEA waits for a new envelope posted to the file my_first_aea/input_file , and adds a response to the file my_first_aea/output_file . The format of each envelope is the following: TO,SENDER,PROTOCOL_ID,ENCODED_MESSAGE, For example: recipient_aea,sender_aea,fetchai/default:0.1.0, \\x 08 \\x 01 * \\x 07 \\n\\x 05hello,","title":"Usage of the stub connection"},{"location":"aea/quickstart/#run-the-aea","text":"Run the AEA with the default stub connection. aea run or aea run --connections fetchai/stub:0.1.0 You will see the echo skill running in the terminal window. _ _____ _ / \\ | ____ | / \\ / _ \\ | _ | / _ \\ / ___ \\ | | ___ / ___ \\ /_/ \\_\\| _____ | /_/ \\_\\ v0.2.4 my_first_aea starting ... info: EchoHandler.__init__: arguments: { 'foo' : 'bar' , 'skill_context' : ..., 'name' : 'echo' } info: EchoBehaviour.__init__: arguments: { 'tick_interval' : 1 .0, 'skill_context' : ..., 'name' : 'echo' } info: Echo Handler: setup method called. info: Echo Behaviour: setup method called. info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. ... The framework first calls the setup method on the Handler , and Behaviour code in that order; after which it repeatedly calls the Behaviour method act. This is the main agent loop in action. Let's look at the Handler in more depth.","title":"Run the AEA"},{"location":"aea/quickstart/#add-a-message-to-the-input-file","text":"From a different terminal and same directory, we send the AEA a message wrapped in an envelope via the input file. echo 'my_first_aea,sender_aea,fetchai/default:0.1.0,\\x08\\x01*\\x07\\n\\x05hello,' >> input_file You will see the Echo Handler dealing with the envelope and responding with the same message to the output_file , and also decoding the Base64 encrypted message in this case. info: Echo Behaviour: act method called. info: Echo Handler: message = Message ( dialogue_reference =( '' , '' ) message_id = 1 target = 0 performative = bytes content = b 'hello' ) , sender = sender_aea info: Echo Behaviour: act method called. info: Echo Behaviour: act method called.","title":"Add a message to the input file"},{"location":"aea/quickstart/#stop-the-aea","text":"Stop the AEA by pressing CTRL C","title":"Stop the AEA"},{"location":"aea/quickstart/#delete-the-aea","text":"Delete the AEA from the parent directory ( cd .. to go to the parent directory). aea delete my_first_aea For more detailed analysis of the core components of the framework, please check the following: Core components For more demos, use cases or step by step guides, please check the following: Generic skill use case Weather skill demo Thermometer step by step guide Step by step install Create a new AEA First, create a new AEA project and enter it. aea create my_first_aea cd my_first_aea Add the echo skill Second, add the echo skill to the project. aea add skill fetchai/echo:0.1.0 This copies the `echo` skill code containing the \"behaviours\", and \"handlers\" into the skill, ready to run. The identifier of the skill `fetchai/echo:0.1.0` consists of the name of the author of the skill, followed by the skill name and its version.","title":"Delete the AEA"},{"location":"aea/raspberry-set-up/","text":"Prerequisites Raspberry Pi 4 link (You can also use Raspberry Pi3 b or Raspberry Pi3 b+) I use a wireless network because, once your Raspberry Pi is set up, you want as few wires going to it as possible. Preparing the Raspberry Pi If you have got a brand-new Raspberry Pi, you can simply insert the SD card, connect the power and boot up. If you do not have a new Rasperry Pi SD card, you will need to make one. To do this follow the NOOBS instructions below. NOOBS NOOBS is a way to get an SD card like it was when you got your Raspberry Pi new from the shop. Go to the following link https://www.raspberrypi.org/downloads/ to download noobs. You can follow this guide to set up your sd card : https://projects.raspberrypi.org/en/projects/raspberry-pi-setting-up Once you have set up your SD card, plug it into your Raspberry Pi, connect the power and watch it boot up. When prompted, select the Raspbian operating system and click on Install. Booting up and updating the OS When you first boot your Raspberry Pi, you will be prompted to enter a password for the Raspberry PI and your wifi password so the Raspberry Pi has access to the internet. You may also be given the option to update the operating system and software. Let the system update and when it has finished you will be prompted to restart. Do this. I recommend having these instructions easily accessible on your Raspberry Pi so you can copy and paste lines into the terminal. You will also be restarting your Raspberry Pi a few times during this process. Even if your Raspberry Pi updated itself, I recommend making sure it is completely up to date using the terminal. Open a Terminal window and type: sudo apt update -y sudo apt-get update sudo apt-get dist-upgrade Install a virtual environment You will need to install pipenv. This is a virtual environment for python. Open a terminal and write the following command: sudo apt-get install pipenv Create and launch a virtual environment pipenv --python 3 .7 && pipenv shell Installing the AEA-framework Install the package from source: pip install aea [ all ]","title":"Build an AEA on a Raspberry Pi"},{"location":"aea/raspberry-set-up/#prerequisites","text":"Raspberry Pi 4 link (You can also use Raspberry Pi3 b or Raspberry Pi3 b+) I use a wireless network because, once your Raspberry Pi is set up, you want as few wires going to it as possible.","title":"Prerequisites"},{"location":"aea/raspberry-set-up/#preparing-the-raspberry-pi","text":"If you have got a brand-new Raspberry Pi, you can simply insert the SD card, connect the power and boot up. If you do not have a new Rasperry Pi SD card, you will need to make one. To do this follow the NOOBS instructions below.","title":"Preparing the Raspberry Pi"},{"location":"aea/raspberry-set-up/#noobs","text":"NOOBS is a way to get an SD card like it was when you got your Raspberry Pi new from the shop. Go to the following link https://www.raspberrypi.org/downloads/ to download noobs. You can follow this guide to set up your sd card : https://projects.raspberrypi.org/en/projects/raspberry-pi-setting-up Once you have set up your SD card, plug it into your Raspberry Pi, connect the power and watch it boot up. When prompted, select the Raspbian operating system and click on Install. Booting up and updating the OS When you first boot your Raspberry Pi, you will be prompted to enter a password for the Raspberry PI and your wifi password so the Raspberry Pi has access to the internet. You may also be given the option to update the operating system and software. Let the system update and when it has finished you will be prompted to restart. Do this. I recommend having these instructions easily accessible on your Raspberry Pi so you can copy and paste lines into the terminal. You will also be restarting your Raspberry Pi a few times during this process. Even if your Raspberry Pi updated itself, I recommend making sure it is completely up to date using the terminal. Open a Terminal window and type: sudo apt update -y sudo apt-get update sudo apt-get dist-upgrade","title":"NOOBS"},{"location":"aea/raspberry-set-up/#install-a-virtual-environment","text":"You will need to install pipenv. This is a virtual environment for python. Open a terminal and write the following command: sudo apt-get install pipenv","title":"Install a virtual environment"},{"location":"aea/raspberry-set-up/#create-and-launch-a-virtual-environment","text":"pipenv --python 3 .7 && pipenv shell","title":"Create and launch a virtual environment"},{"location":"aea/raspberry-set-up/#installing-the-aea-framework","text":"Install the package from source: pip install aea [ all ]","title":"Installing the AEA-framework"},{"location":"aea/scaffolding/","text":"Scaffold generator The scaffold generator builds out the directory structure required when adding new skills, protocols, and connections to the AEA. For example, create a new AEA project (add the author flag using your own author handle if this is your first project using the aea package). aea create my_aea --author \"fetchai\" cd my_aea Then, cd into your project directory and scaffold your project skill, protocol, or connection. Scaffold a skill aea scaffold skill my_skill Scaffold a protocol aea scaffold protocol my_protocol Scaffold a connection aea scaffold connection my_connection After running the above commands, you are ready to develop your own skill, protocol and connection.","title":"Scaffolding packages"},{"location":"aea/scaffolding/#scaffold-generator","text":"The scaffold generator builds out the directory structure required when adding new skills, protocols, and connections to the AEA. For example, create a new AEA project (add the author flag using your own author handle if this is your first project using the aea package). aea create my_aea --author \"fetchai\" cd my_aea Then, cd into your project directory and scaffold your project skill, protocol, or connection.","title":"Scaffold generator"},{"location":"aea/scaffolding/#scaffold-a-skill","text":"aea scaffold skill my_skill","title":"Scaffold a skill"},{"location":"aea/scaffolding/#scaffold-a-protocol","text":"aea scaffold protocol my_protocol","title":"Scaffold a protocol"},{"location":"aea/scaffolding/#scaffold-a-connection","text":"aea scaffold connection my_connection After running the above commands, you are ready to develop your own skill, protocol and connection.","title":"Scaffold a connection"},{"location":"aea/skill-guide/","text":"Note Before developing your first skill, please read the skill guide . Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Step 1: Setup We will first create an AEA and add a scaffold skill, which we call my_search . aea create my_aea && cd my_aea aea scaffold skill my_search In the following steps, we replace the scaffolded Behaviour and Handler in my_aea/skills/my_search with our implementation. We will build a simple skill which lets the AEA send a search query to the OEF search node and process the resulting response. Step 2: Develop a Behaviour A Behaviour class contains the business logic specific to initial actions initiated by the AEA rather than reactions to other events. In this example, we implement a simple search behaviour. Each time, act() gets called by the main agent loop, we will send a search request to the OEF search node via the OEF communication network . from aea.helpers.search.models import Constraint , ConstraintType , Query from aea.skills.behaviours import TickerBehaviour from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.protocols.oef_search.serialization import OefSearchSerializer class MySearchBehaviour ( TickerBehaviour ): \"\"\"This class provides a simple search behaviour.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialize the search behaviour.\"\"\" super () . __init__ ( ** kwargs ) self . sent_search_count = 0 def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" self . context . logger . info ( \"[ {} ]: setting up MySearchBehaviour\" . format ( self . context . agent_name ) ) def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" self . sent_search_count += 1 search_constraints = [ Constraint ( \"country\" , ConstraintType ( \"==\" , \"UK\" ))] search_query_w_empty_model = Query ( search_constraints , model = None ) search_request = OefSearchMessage ( performative = OefSearchMessage . Performative . SEARCH_SERVICES , dialogue_reference = ( str ( self . sent_search_count ), \"\" ), query = search_query_w_empty_model , ) self . context . logger . info ( \"[ {} ]: sending search request to OEF search node, search_count= {} \" . format ( self . context . agent_name , self . sent_search_count ) ) self . context . outbox . put_message ( to = self . context . search_service_address , sender = self . context . agent_address , protocol_id = OefSearchMessage . protocol_id , message = OefSearchSerializer () . encode ( search_request ), ) def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" self . context . logger . info ( \"[ {} ]: tearing down MySearchBehaviour\" . format ( self . context . agent_name ) ) Searches are proactive and, as such, well placed in a Behaviour . Specifically, we subclass the TickerBehaviour as it allows us to repeatedly search at a defined tick interval. We place this code in my_aea/skills/my_search/behaviours.py . Step 3: Develop a Handler So far, we have tasked the AEA with sending search requests to the OEF search node . However, we have no way of handling the responses sent to the AEA by the OEF search node at the moment. The AEA would simply respond to the OEF search node via the default error skill which sends all unrecognised envelopes back to the sender. Let us now implement a handler to deal with the incoming search responses. from aea.skills.base import Handler from packages.fetchai.protocols.oef_search.message import OefSearchMessage class MySearchHandler ( Handler ): \"\"\"This class provides a simple search handler.\"\"\" SUPPORTED_PROTOCOL = OefSearchMessage . protocol_id def __init__ ( self , ** kwargs ): \"\"\"Initialize the handler.\"\"\" super () . __init__ ( ** kwargs ) self . received_search_count = 0 def setup ( self ) -> None : \"\"\"Set up the handler.\"\"\" self . context . logger . info ( \"[ {} ]: setting up MySearchHandler\" . format ( self . context . agent_name )) def handle ( self , message : OefSearchMessage ) -> None : \"\"\" Handle the message. :param message: the message. :return: None \"\"\" msg_type = OefSearchMessage . Performative ( message . performative ) if msg_type is OefSearchMessage . Performative . SEARCH_RESULT : self . received_search_count += 1 nb_agents_found = len ( message . get ( \"agents\" )) self . context . logger . info ( \"[ {} ]: found number of agents= {} , received search count= {} \" . format ( self . context . agent_name , nb_agents_found , self . received_search_count ) ) self . context . logger . info ( \"[ {} ]: number of search requests sent= {} vs. number of search responses received= {} \" . format ( self . context . agent_name , self . context . behaviours . my_search_behaviour . sent_search_count , self . received_search_count , ) ) def teardown ( self ) -> None : \"\"\" Teardown the handler. :return: None \"\"\" self . context . logger . info ( \"[ {} ]: tearing down MySearchHandler\" . format ( self . context . agent_name ) ) We create a handler which is registered for the oef_search protocol. Whenever it receives a search result, we log the number of agents returned in the search - the agents matching the search query - and update the counter of received searches. We also implement a trivial check on the difference between the amount of search requests sent and responses received. Note, how the handler simply reacts to incoming events (i.e. messages). It could initiate further actions, however, they are still reactions to the upstream search event. Also note, how we have access to other objects in the skill via self.context . We place this code in my_aea/skills/my_search/handlers.py . Step 4: Remove unused Task and Model We have implemented a behaviour and a handler. We could also implement a task and a model , but instead we delete these files in this case, to keep it simple. We remove the files my_aea/skills/my_search/tasks.py and my_aea/skills/my_search/my_model.py . Step 5: Create the config file Based on our skill components above, we create the following config file. name : my_search author : fetchai version : 0.1.0 license : Apache-2.0 description : 'A simple search skill utilising the OEF search and communication node.' fingerprint : '' behaviours : my_search_behaviour : class_name : MySearchBehaviour args : tick_interval : 5 handlers : my_search_handler : class_name : MySearchHandler args : {} models : {} protocols : [ 'fetchai/oef_search:0.1.0' ] dependencies : {} Ensure, you replace the author field with your author name! (Run aea init to set or check the author name.) Importantly, the keys my_search_behaviour and my_search_handler are used in the above handler to access these skill components at runtime via the context. We also set the tick_interval of the TickerBehaviour to 5 seconds. We place this code in my_aea/skills/my_search/skill.yaml . Step 6: Add the oef protocol and connection Our AEA does not have the oef protocol yet so let's add it. aea add protocol fetchai/oef_search:0.1.0 This adds the protocol to our AEA and makes it available on the path packages.fetchai.protocols... . We also need to add the oef connection and install its dependencies: aea add connection fetchai/oef:0.1.0 aea install Step 7: Run a service provider AEA We first start a local OEF search and communication node in a separate terminal window. python scripts/oef/launch.py -c ./scripts/oef/launch_config.json In order to be able to find another AEA when searching, from a different terminal window, we fetch and run another finished AEA: aea fetch fetchai/simple_service_registration:0.1.0 && cd simple_service_registration aea run This AEA will simply register a location service on the OEF search node so we can search for it. Click here to see full code We use a ticker behaviour to update the service registration at regular intervals. The following code is placed in `behaviours.py`. from typing import Optional , cast from aea.helpers.search.models import Description from aea.skills.behaviours import TickerBehaviour from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.protocols.oef_search.serialization import OefSearchSerializer from packages.fetchai.skills.simple_service_registration.strategy import Strategy DEFAULT_SERVICES_INTERVAL = 30.0 class ServiceRegistrationBehaviour ( TickerBehaviour ): \"\"\"This class implements a behaviour.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialise the behaviour.\"\"\" services_interval = kwargs . pop ( \"services_interval\" , DEFAULT_SERVICES_INTERVAL ) # type: int super () . __init__ ( tick_interval = services_interval , ** kwargs ) self . _registered_service_description = None # type: Optional[Description] def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" self . _register_service () def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" self . _unregister_service () self . _register_service () def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" self . _unregister_service () def _register_service ( self ) -> None : \"\"\" Register to the OEF search node's service directory. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) desc = strategy . get_service_description () self . _registered_service_description = desc oef_msg_id = strategy . get_next_oef_msg_id () msg = OefSearchMessage ( performative = OefSearchMessage . Performative . REGISTER_SERVICE , dialogue_reference = ( str ( oef_msg_id ), \"\" ), service_description = desc , ) self . context . outbox . put_message ( to = self . context . search_service_address , sender = self . context . agent_address , protocol_id = OefSearchMessage . protocol_id , message = OefSearchSerializer () . encode ( msg ), ) self . context . logger . info ( \"[ {} ]: updating services on OEF search node's service directory.\" . format ( self . context . agent_name ) ) def _unregister_service ( self ) -> None : \"\"\" Unregister service from OEF search node's service directory. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) oef_msg_id = strategy . get_next_oef_msg_id () msg = OefSearchMessage ( performative = OefSearchMessage . Performative . UNREGISTER_SERVICE , dialogue_reference = ( str ( oef_msg_id ), \"\" ), service_description = self . _registered_service_description , ) self . context . outbox . put_message ( to = self . context . search_service_address , sender = self . context . agent_address , protocol_id = OefSearchMessage . protocol_id , message = OefSearchSerializer () . encode ( msg ), ) self . context . logger . info ( \"[ {} ]: unregistering services from search OEF node's service directory.\" . format ( self . context . agent_name ) ) self . _registered_service_description = None We create a generic data model to register the service. The following code is placed in `data_model.py`. from typing import Any , Dict , List from aea.helpers.search.models import Attribute , DataModel SUPPORTED_TYPES = { \"str\" : str , \"int\" : int , \"float\" : float , \"bool\" : bool } class GenericDataModel ( DataModel ): \"\"\"Data model for the service.\"\"\" def __init__ ( self , datamodel_name : str , data_model_attributes : Dict [ str , Any ]): \"\"\"Initialise the data model.\"\"\" self . attributes = [] # type: List[Attribute] for values in data_model_attributes . values (): assert ( values [ \"type\" ] in SUPPORTED_TYPES . keys () ), \"Type is not supported. Use str, int, float or bool\" assert isinstance ( values [ \"name\" ], ( SUPPORTED_TYPES [ values [ \"type\" ]],) ), \"The datamodel values are of wrong type!\" assert isinstance ( values [ \"is_required\" ], bool ), \"Wrong type!! is_required must be bool\" self . attributes . append ( Attribute ( name = values [ \"name\" ], # type: ignore type = SUPPORTED_TYPES [ values [ \"type\" ]], is_required = values [ \"is_required\" ], ) ) super () . __init__ ( datamodel_name , self . attributes ) We create a `model` type strategy class and place it in `strategy.py`. from typing import Any , Dict , Optional from aea.helpers.search.models import Description from aea.skills.base import Model from packages.fetchai.skills.simple_service_registration.data_model import ( GenericDataModel , ) DEFAULT_DATA_MODEL_NAME = \"location\" DEFAULT_DATA_MODEL = { \"attribute_one\" : { \"name\" : \"country\" , \"type\" : \"str\" , \"is_required\" : \"True\" }, \"attribute_two\" : { \"name\" : \"city\" , \"type\" : \"str\" , \"is_required\" : \"True\" }, } # type: Optional[Dict[str, Any]] DEFAULT_SERVICE_DATA = { \"country\" : \"UK\" , \"city\" : \"Cambridge\" } class Strategy ( Model ): \"\"\"This class defines a strategy for the agent.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize the strategy of the agent. :return: None \"\"\" super () . __init__ ( ** kwargs ) self . _oef_msg_id = 0 self . _data_model_name = kwargs . pop ( \"data_model_name\" , DEFAULT_DATA_MODEL_NAME ) self . _data_model = kwargs . pop ( \"data_model\" , DEFAULT_DATA_MODEL ) self . _service_data = kwargs . pop ( \"service_data\" , DEFAULT_SERVICE_DATA ) def get_next_oef_msg_id ( self ) -> int : \"\"\" Get the next oef msg id. :return: the next oef msg id \"\"\" self . _oef_msg_id += 1 return self . _oef_msg_id def get_service_description ( self ) -> Description : \"\"\" Get the service description. :return: a description of the offered services \"\"\" desc = Description ( self . _service_data , data_model = GenericDataModel ( self . _data_model_name , self . _data_model ), ) return desc The associated `skill.yaml` is: name : simple_service_registration author : fetchai version : 0.1.0 license : Apache-2.0 description : The scaffold skill is a scaffold for your own skill implementation. fingerprint : '' behaviours : service : args : services_interval : 30 class_name : ServiceRegistrationBehaviour handlers : {} models : strategy : class_name : Strategy args : data_model_name : location data_model : attribute_one : name : country type : str is_required : True attribute_two : name : city type : str is_required : True service_data : country : UK city : Cambridge protocols : [ 'fetchai/oef_search:0.1.0' ] dependencies : {} Step 8: Run the Search AEA We can then launch our AEA. aea run --connections fetchai/oef:0.1.0 We can see that the AEA sends search requests to the OEF search node and receives search responses from the OEF search node . Since our AEA is only searching on the OEF search node - and not registered on the OEF search node - the search response returns a single agent (the service provider). We stop the AEA with CTRL + C . Now it's your turn We hope this step by step introduction has helped you develop your own skill. We are excited to see what you will build.","title":"Build a skill for an AEA"},{"location":"aea/skill-guide/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/skill-guide/#step-1-setup","text":"We will first create an AEA and add a scaffold skill, which we call my_search . aea create my_aea && cd my_aea aea scaffold skill my_search In the following steps, we replace the scaffolded Behaviour and Handler in my_aea/skills/my_search with our implementation. We will build a simple skill which lets the AEA send a search query to the OEF search node and process the resulting response.","title":"Step 1: Setup"},{"location":"aea/skill-guide/#step-2-develop-a-behaviour","text":"A Behaviour class contains the business logic specific to initial actions initiated by the AEA rather than reactions to other events. In this example, we implement a simple search behaviour. Each time, act() gets called by the main agent loop, we will send a search request to the OEF search node via the OEF communication network . from aea.helpers.search.models import Constraint , ConstraintType , Query from aea.skills.behaviours import TickerBehaviour from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.protocols.oef_search.serialization import OefSearchSerializer class MySearchBehaviour ( TickerBehaviour ): \"\"\"This class provides a simple search behaviour.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialize the search behaviour.\"\"\" super () . __init__ ( ** kwargs ) self . sent_search_count = 0 def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" self . context . logger . info ( \"[ {} ]: setting up MySearchBehaviour\" . format ( self . context . agent_name ) ) def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" self . sent_search_count += 1 search_constraints = [ Constraint ( \"country\" , ConstraintType ( \"==\" , \"UK\" ))] search_query_w_empty_model = Query ( search_constraints , model = None ) search_request = OefSearchMessage ( performative = OefSearchMessage . Performative . SEARCH_SERVICES , dialogue_reference = ( str ( self . sent_search_count ), \"\" ), query = search_query_w_empty_model , ) self . context . logger . info ( \"[ {} ]: sending search request to OEF search node, search_count= {} \" . format ( self . context . agent_name , self . sent_search_count ) ) self . context . outbox . put_message ( to = self . context . search_service_address , sender = self . context . agent_address , protocol_id = OefSearchMessage . protocol_id , message = OefSearchSerializer () . encode ( search_request ), ) def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" self . context . logger . info ( \"[ {} ]: tearing down MySearchBehaviour\" . format ( self . context . agent_name ) ) Searches are proactive and, as such, well placed in a Behaviour . Specifically, we subclass the TickerBehaviour as it allows us to repeatedly search at a defined tick interval. We place this code in my_aea/skills/my_search/behaviours.py .","title":"Step 2: Develop a Behaviour"},{"location":"aea/skill-guide/#step-3-develop-a-handler","text":"So far, we have tasked the AEA with sending search requests to the OEF search node . However, we have no way of handling the responses sent to the AEA by the OEF search node at the moment. The AEA would simply respond to the OEF search node via the default error skill which sends all unrecognised envelopes back to the sender. Let us now implement a handler to deal with the incoming search responses. from aea.skills.base import Handler from packages.fetchai.protocols.oef_search.message import OefSearchMessage class MySearchHandler ( Handler ): \"\"\"This class provides a simple search handler.\"\"\" SUPPORTED_PROTOCOL = OefSearchMessage . protocol_id def __init__ ( self , ** kwargs ): \"\"\"Initialize the handler.\"\"\" super () . __init__ ( ** kwargs ) self . received_search_count = 0 def setup ( self ) -> None : \"\"\"Set up the handler.\"\"\" self . context . logger . info ( \"[ {} ]: setting up MySearchHandler\" . format ( self . context . agent_name )) def handle ( self , message : OefSearchMessage ) -> None : \"\"\" Handle the message. :param message: the message. :return: None \"\"\" msg_type = OefSearchMessage . Performative ( message . performative ) if msg_type is OefSearchMessage . Performative . SEARCH_RESULT : self . received_search_count += 1 nb_agents_found = len ( message . get ( \"agents\" )) self . context . logger . info ( \"[ {} ]: found number of agents= {} , received search count= {} \" . format ( self . context . agent_name , nb_agents_found , self . received_search_count ) ) self . context . logger . info ( \"[ {} ]: number of search requests sent= {} vs. number of search responses received= {} \" . format ( self . context . agent_name , self . context . behaviours . my_search_behaviour . sent_search_count , self . received_search_count , ) ) def teardown ( self ) -> None : \"\"\" Teardown the handler. :return: None \"\"\" self . context . logger . info ( \"[ {} ]: tearing down MySearchHandler\" . format ( self . context . agent_name ) ) We create a handler which is registered for the oef_search protocol. Whenever it receives a search result, we log the number of agents returned in the search - the agents matching the search query - and update the counter of received searches. We also implement a trivial check on the difference between the amount of search requests sent and responses received. Note, how the handler simply reacts to incoming events (i.e. messages). It could initiate further actions, however, they are still reactions to the upstream search event. Also note, how we have access to other objects in the skill via self.context . We place this code in my_aea/skills/my_search/handlers.py .","title":"Step 3: Develop a Handler"},{"location":"aea/skill-guide/#step-4-remove-unused-task-and-model","text":"We have implemented a behaviour and a handler. We could also implement a task and a model , but instead we delete these files in this case, to keep it simple. We remove the files my_aea/skills/my_search/tasks.py and my_aea/skills/my_search/my_model.py .","title":"Step 4: Remove unused Task and Model"},{"location":"aea/skill-guide/#step-5-create-the-config-file","text":"Based on our skill components above, we create the following config file. name : my_search author : fetchai version : 0.1.0 license : Apache-2.0 description : 'A simple search skill utilising the OEF search and communication node.' fingerprint : '' behaviours : my_search_behaviour : class_name : MySearchBehaviour args : tick_interval : 5 handlers : my_search_handler : class_name : MySearchHandler args : {} models : {} protocols : [ 'fetchai/oef_search:0.1.0' ] dependencies : {} Ensure, you replace the author field with your author name! (Run aea init to set or check the author name.) Importantly, the keys my_search_behaviour and my_search_handler are used in the above handler to access these skill components at runtime via the context. We also set the tick_interval of the TickerBehaviour to 5 seconds. We place this code in my_aea/skills/my_search/skill.yaml .","title":"Step 5: Create the config file"},{"location":"aea/skill-guide/#step-6-add-the-oef-protocol-and-connection","text":"Our AEA does not have the oef protocol yet so let's add it. aea add protocol fetchai/oef_search:0.1.0 This adds the protocol to our AEA and makes it available on the path packages.fetchai.protocols... . We also need to add the oef connection and install its dependencies: aea add connection fetchai/oef:0.1.0 aea install","title":"Step 6: Add the oef protocol and connection"},{"location":"aea/skill-guide/#step-7-run-a-service-provider-aea","text":"We first start a local OEF search and communication node in a separate terminal window. python scripts/oef/launch.py -c ./scripts/oef/launch_config.json In order to be able to find another AEA when searching, from a different terminal window, we fetch and run another finished AEA: aea fetch fetchai/simple_service_registration:0.1.0 && cd simple_service_registration aea run This AEA will simply register a location service on the OEF search node so we can search for it. Click here to see full code We use a ticker behaviour to update the service registration at regular intervals. The following code is placed in `behaviours.py`. from typing import Optional , cast from aea.helpers.search.models import Description from aea.skills.behaviours import TickerBehaviour from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.protocols.oef_search.serialization import OefSearchSerializer from packages.fetchai.skills.simple_service_registration.strategy import Strategy DEFAULT_SERVICES_INTERVAL = 30.0 class ServiceRegistrationBehaviour ( TickerBehaviour ): \"\"\"This class implements a behaviour.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialise the behaviour.\"\"\" services_interval = kwargs . pop ( \"services_interval\" , DEFAULT_SERVICES_INTERVAL ) # type: int super () . __init__ ( tick_interval = services_interval , ** kwargs ) self . _registered_service_description = None # type: Optional[Description] def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" self . _register_service () def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" self . _unregister_service () self . _register_service () def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" self . _unregister_service () def _register_service ( self ) -> None : \"\"\" Register to the OEF search node's service directory. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) desc = strategy . get_service_description () self . _registered_service_description = desc oef_msg_id = strategy . get_next_oef_msg_id () msg = OefSearchMessage ( performative = OefSearchMessage . Performative . REGISTER_SERVICE , dialogue_reference = ( str ( oef_msg_id ), \"\" ), service_description = desc , ) self . context . outbox . put_message ( to = self . context . search_service_address , sender = self . context . agent_address , protocol_id = OefSearchMessage . protocol_id , message = OefSearchSerializer () . encode ( msg ), ) self . context . logger . info ( \"[ {} ]: updating services on OEF search node's service directory.\" . format ( self . context . agent_name ) ) def _unregister_service ( self ) -> None : \"\"\" Unregister service from OEF search node's service directory. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) oef_msg_id = strategy . get_next_oef_msg_id () msg = OefSearchMessage ( performative = OefSearchMessage . Performative . UNREGISTER_SERVICE , dialogue_reference = ( str ( oef_msg_id ), \"\" ), service_description = self . _registered_service_description , ) self . context . outbox . put_message ( to = self . context . search_service_address , sender = self . context . agent_address , protocol_id = OefSearchMessage . protocol_id , message = OefSearchSerializer () . encode ( msg ), ) self . context . logger . info ( \"[ {} ]: unregistering services from search OEF node's service directory.\" . format ( self . context . agent_name ) ) self . _registered_service_description = None We create a generic data model to register the service. The following code is placed in `data_model.py`. from typing import Any , Dict , List from aea.helpers.search.models import Attribute , DataModel SUPPORTED_TYPES = { \"str\" : str , \"int\" : int , \"float\" : float , \"bool\" : bool } class GenericDataModel ( DataModel ): \"\"\"Data model for the service.\"\"\" def __init__ ( self , datamodel_name : str , data_model_attributes : Dict [ str , Any ]): \"\"\"Initialise the data model.\"\"\" self . attributes = [] # type: List[Attribute] for values in data_model_attributes . values (): assert ( values [ \"type\" ] in SUPPORTED_TYPES . keys () ), \"Type is not supported. Use str, int, float or bool\" assert isinstance ( values [ \"name\" ], ( SUPPORTED_TYPES [ values [ \"type\" ]],) ), \"The datamodel values are of wrong type!\" assert isinstance ( values [ \"is_required\" ], bool ), \"Wrong type!! is_required must be bool\" self . attributes . append ( Attribute ( name = values [ \"name\" ], # type: ignore type = SUPPORTED_TYPES [ values [ \"type\" ]], is_required = values [ \"is_required\" ], ) ) super () . __init__ ( datamodel_name , self . attributes ) We create a `model` type strategy class and place it in `strategy.py`. from typing import Any , Dict , Optional from aea.helpers.search.models import Description from aea.skills.base import Model from packages.fetchai.skills.simple_service_registration.data_model import ( GenericDataModel , ) DEFAULT_DATA_MODEL_NAME = \"location\" DEFAULT_DATA_MODEL = { \"attribute_one\" : { \"name\" : \"country\" , \"type\" : \"str\" , \"is_required\" : \"True\" }, \"attribute_two\" : { \"name\" : \"city\" , \"type\" : \"str\" , \"is_required\" : \"True\" }, } # type: Optional[Dict[str, Any]] DEFAULT_SERVICE_DATA = { \"country\" : \"UK\" , \"city\" : \"Cambridge\" } class Strategy ( Model ): \"\"\"This class defines a strategy for the agent.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize the strategy of the agent. :return: None \"\"\" super () . __init__ ( ** kwargs ) self . _oef_msg_id = 0 self . _data_model_name = kwargs . pop ( \"data_model_name\" , DEFAULT_DATA_MODEL_NAME ) self . _data_model = kwargs . pop ( \"data_model\" , DEFAULT_DATA_MODEL ) self . _service_data = kwargs . pop ( \"service_data\" , DEFAULT_SERVICE_DATA ) def get_next_oef_msg_id ( self ) -> int : \"\"\" Get the next oef msg id. :return: the next oef msg id \"\"\" self . _oef_msg_id += 1 return self . _oef_msg_id def get_service_description ( self ) -> Description : \"\"\" Get the service description. :return: a description of the offered services \"\"\" desc = Description ( self . _service_data , data_model = GenericDataModel ( self . _data_model_name , self . _data_model ), ) return desc The associated `skill.yaml` is: name : simple_service_registration author : fetchai version : 0.1.0 license : Apache-2.0 description : The scaffold skill is a scaffold for your own skill implementation. fingerprint : '' behaviours : service : args : services_interval : 30 class_name : ServiceRegistrationBehaviour handlers : {} models : strategy : class_name : Strategy args : data_model_name : location data_model : attribute_one : name : country type : str is_required : True attribute_two : name : city type : str is_required : True service_data : country : UK city : Cambridge protocols : [ 'fetchai/oef_search:0.1.0' ] dependencies : {}","title":"Step 7: Run a service provider AEA"},{"location":"aea/skill-guide/#step-8-run-the-search-aea","text":"We can then launch our AEA. aea run --connections fetchai/oef:0.1.0 We can see that the AEA sends search requests to the OEF search node and receives search responses from the OEF search node . Since our AEA is only searching on the OEF search node - and not registered on the OEF search node - the search response returns a single agent (the service provider). We stop the AEA with CTRL + C .","title":"Step 8: Run the Search AEA"},{"location":"aea/skill-guide/#now-its-your-turn","text":"We hope this step by step introduction has helped you develop your own skill. We are excited to see what you will build.","title":"Now it's your turn"},{"location":"aea/skill/","text":"An AEA developer writes skills that the framework can call. When you add a skill with the CLI, a directory is created which includes modules for the Behaviour , Task , and Handler classes as well as a configuration file skill.yaml . Independence of skills Skills are horizontally layered , that is they run independently of each other. They also cannot access each other's state. Two skills can communicate with each other in two ways. The skill context provides access via self.context.shared_state to a key-value store which allows skills to share state. A skill can also define as a callback another skill in a message to the decision maker . Context The skill has a SkillContext object which is shared by all Handler , Behaviour , and Task objects. The skill context also has a link to the AgentContext . The AgentContext provides read access to AEA specific information like the public key and address of the AEA, its preferences and ownership state. It also provides access to the OutBox . This means it is possible to, at any point, grab the context and have access to the code in other parts of the skill and the AEA. For example, in the ErrorHandler(Handler) class, the code often grabs a reference to its context and by doing so can access initialised and running framework objects such as an OutBox for putting messages into. self . context . outbox . put_message ( to = recipient , sender = self . context . agent_address , protocol_id = DefaultMessage . protocol_id , message = DefaultSerializer () . encode ( reply )) Importantly, however, a skill does not have access to the context of another skill or protected AEA components like the DecisionMaker . What to code Each of the skill classes has three methods that must be implemented. All of them include a setup() and teardown() method which the developer must implement. Then there is a specific method that the framework requires for each class. handlers.py There can be none, one or more Handler class per skill. Handler classes can receive Message objects of one protocol type only. However, Handler classes can send Envelope objects of any type of protocol they require. handle(self, message: Message) : is where the skill receives a Message of the specified protocol and decides what to do with it. Todo For example. behaviours.py Conceptually, a Behaviour class contains the business logic specific to initial actions initiated by the AEA rather than reactions to other events. There can be one or more Behaviour classes per skill. The developer must create a subclass from the abstract class Behaviour to create a new Behaviour . A behaviour can be registered in two ways: By declaring it in the skill configuration file skill.yaml (see below ) In any part of the code of the skill, by enqueuing new Behaviour instances in the queue context.new_behaviours . act(self) : is how the framework calls the Behaviour code. The framework supports different types of behaviours: - OneShotBehaviour : this behaviour is executed only once. - CyclicBehaviour : this behaviour is executed many times, as long as done() returns True .) - TickerBehaviour : the act() method is called every tick_interval . E.g. if the TickerBehaviour subclass is instantiated There is another category of behaviours, called CompositeBehaviour . - SequenceBehaviour : a sequence of Behaviour classes, executed one after the other. - FSMBehaviour _ : a state machine of State` behaviours. A state is in charge of scheduling the next state. If your behaviour fits one of the above, we suggest subclassing your behaviour class with that behaviour class. Otherwise, you can always subclass the general-purpose Behaviour class. !! Follows an example of a custom behaviour: from aea.skills.behaviours import OneShotBehaviour class HelloWorldBehaviour ( OneShotBehaviour ): def setup ( self ): \"\"\"This method is called once, when the behaviour gets loaded.\"\"\" def act ( self ): \"\"\"This methods is called in every iteration of the agent main loop.\"\"\" print ( \"Hello, World!\" ) def teardown ( self ): \"\"\"This method is called once, when the behaviour is teared down.\"\"\" If we want to register this behaviour dynamically, in any part of the skill code (i.e. wherever the skill context is available), we can write: self . context . new_behaviours . put ( HelloWorldBehaviour ()) Or, equivalently: def hello (): print ( \"Hello, World!\" ) self . context . new_behaviours . put ( OneShotBehaviour ( act = hello )) The callable passed to the act parameter is equivalent to the implementation of the act method described above. The framework is then in charge of registering the behaviour and scheduling it for execution. tasks.py Conceptually, a Task is where the developer codes any internal tasks the AEA requires. There can be one or more Task classes per skill. The developer subclasses abstract class Task to create a new Task . execute(self) : is how the framework calls a Task . The Task class implements the functor pattern . An instance of the Task class can be invoked as if it were an ordinary function. Once completed, it will store the result in the property result . Raises error if the task has not been executed yet, or an error occurred during computation. We suggest using the task_manager , accessible through the skill context, to manage long-running tasks. The task manager uses multiprocessing to schedule tasks, so be aware that the changes on the task object will not be updated. Here's an example: In tasks.py : from aea.skills.tasks import Task def nth_prime_number ( n : int ) -> int : \"\"\"A naive algorithm to find the n_th prime number.\"\"\" primes = [ 2 ] num = 3 while len ( primes ) < n : for p in primes : if num % p == 0 : break else : primes . append ( num ) num += 2 return primes [ - 1 ] class LongTask ( Task ): def setup ( self ): \"\"\"Set the task up before execution.\"\"\" pass def execute ( self , n : int ): return nth_prime_number ( n ) def teardown ( self ): \"\"\"Clean the task up after execution.\"\"\" pass In behaviours.py : from aea.skills.behaviours import TickerBehaviour from packages.my_author_name.skills.my_skill.tasks import LongTask class MyBehaviour ( TickerBehaviour ): def setup ( self ): my_task = LongTask () task_id = self . context . task_manager . enqueue_task ( my_task , args = ( 10000 , )) self . async_result = self . context . task_manager . get_task_result ( task_id ) # type: multiprocessing.pool.AsyncResult def act ( self ): if self . async_result . ready () is False : print ( \"The task is not finished yet.\" ) else : completed_task = self . async_result . get () # type: LongTask print ( \"The result is:\" , completed_task . result ) # Stop the skill self . context . is_active = False def teardown ( self ): pass Models The developer might want to add other classes on the context level which are shared equally across the Handler , Behaviour and Task classes. To this end, the developer can subclass an abstract Model . These models are made available on the context level upon initialization of the AEA. Say, the developer has a class called SomeModel class SomeModel ( Model ): ... Then, an instance of this class is available on the context level like so: some_model = self . context . some_model Skill config Each skill has a skill.yaml configuration file which lists all Behaviour , Handler , and Task objects pertaining to the skill. It also details the protocol types used in the skill and points to shared modules, i.e. modules of type Model , which allow custom classes within the skill to be accessible in the skill context. name : echo authors : fetchai version : 0.1.0 license : Apache-2.0 behaviours : echo : class_name : EchoBehaviour args : tick_interval : 1.0 handlers : echo : class_name : EchoHandler args : foo : bar models : {} dependencies : {} protocols : [ \"fetchai/default:0.1.0\" ] Error skill All AEA's have a default error skill that contains error handling code for a number of scenarios: Received envelopes with unsupported protocols Received envelopes with unsupported skills (i.e. protocols for which no handler is registered) Envelopes with decoding errors Invalid messages with respect to the registered protocol The error skill relies on the fetchai/default:0.1.0 protocol which provides error codes for the above.","title":"Skill"},{"location":"aea/skill/#independence-of-skills","text":"Skills are horizontally layered , that is they run independently of each other. They also cannot access each other's state. Two skills can communicate with each other in two ways. The skill context provides access via self.context.shared_state to a key-value store which allows skills to share state. A skill can also define as a callback another skill in a message to the decision maker .","title":"Independence of skills"},{"location":"aea/skill/#context","text":"The skill has a SkillContext object which is shared by all Handler , Behaviour , and Task objects. The skill context also has a link to the AgentContext . The AgentContext provides read access to AEA specific information like the public key and address of the AEA, its preferences and ownership state. It also provides access to the OutBox . This means it is possible to, at any point, grab the context and have access to the code in other parts of the skill and the AEA. For example, in the ErrorHandler(Handler) class, the code often grabs a reference to its context and by doing so can access initialised and running framework objects such as an OutBox for putting messages into. self . context . outbox . put_message ( to = recipient , sender = self . context . agent_address , protocol_id = DefaultMessage . protocol_id , message = DefaultSerializer () . encode ( reply )) Importantly, however, a skill does not have access to the context of another skill or protected AEA components like the DecisionMaker .","title":"Context"},{"location":"aea/skill/#what-to-code","text":"Each of the skill classes has three methods that must be implemented. All of them include a setup() and teardown() method which the developer must implement. Then there is a specific method that the framework requires for each class.","title":"What to code"},{"location":"aea/skill/#handlerspy","text":"There can be none, one or more Handler class per skill. Handler classes can receive Message objects of one protocol type only. However, Handler classes can send Envelope objects of any type of protocol they require. handle(self, message: Message) : is where the skill receives a Message of the specified protocol and decides what to do with it. Todo For example.","title":"handlers.py"},{"location":"aea/skill/#behaviourspy","text":"Conceptually, a Behaviour class contains the business logic specific to initial actions initiated by the AEA rather than reactions to other events. There can be one or more Behaviour classes per skill. The developer must create a subclass from the abstract class Behaviour to create a new Behaviour . A behaviour can be registered in two ways: By declaring it in the skill configuration file skill.yaml (see below ) In any part of the code of the skill, by enqueuing new Behaviour instances in the queue context.new_behaviours . act(self) : is how the framework calls the Behaviour code. The framework supports different types of behaviours: - OneShotBehaviour : this behaviour is executed only once. - CyclicBehaviour : this behaviour is executed many times, as long as done() returns True .) - TickerBehaviour : the act() method is called every tick_interval . E.g. if the TickerBehaviour subclass is instantiated There is another category of behaviours, called CompositeBehaviour . - SequenceBehaviour : a sequence of Behaviour classes, executed one after the other. - FSMBehaviour _ : a state machine of State` behaviours. A state is in charge of scheduling the next state. If your behaviour fits one of the above, we suggest subclassing your behaviour class with that behaviour class. Otherwise, you can always subclass the general-purpose Behaviour class. !! Follows an example of a custom behaviour: from aea.skills.behaviours import OneShotBehaviour class HelloWorldBehaviour ( OneShotBehaviour ): def setup ( self ): \"\"\"This method is called once, when the behaviour gets loaded.\"\"\" def act ( self ): \"\"\"This methods is called in every iteration of the agent main loop.\"\"\" print ( \"Hello, World!\" ) def teardown ( self ): \"\"\"This method is called once, when the behaviour is teared down.\"\"\" If we want to register this behaviour dynamically, in any part of the skill code (i.e. wherever the skill context is available), we can write: self . context . new_behaviours . put ( HelloWorldBehaviour ()) Or, equivalently: def hello (): print ( \"Hello, World!\" ) self . context . new_behaviours . put ( OneShotBehaviour ( act = hello )) The callable passed to the act parameter is equivalent to the implementation of the act method described above. The framework is then in charge of registering the behaviour and scheduling it for execution.","title":"behaviours.py"},{"location":"aea/skill/#taskspy","text":"Conceptually, a Task is where the developer codes any internal tasks the AEA requires. There can be one or more Task classes per skill. The developer subclasses abstract class Task to create a new Task . execute(self) : is how the framework calls a Task . The Task class implements the functor pattern . An instance of the Task class can be invoked as if it were an ordinary function. Once completed, it will store the result in the property result . Raises error if the task has not been executed yet, or an error occurred during computation. We suggest using the task_manager , accessible through the skill context, to manage long-running tasks. The task manager uses multiprocessing to schedule tasks, so be aware that the changes on the task object will not be updated. Here's an example: In tasks.py : from aea.skills.tasks import Task def nth_prime_number ( n : int ) -> int : \"\"\"A naive algorithm to find the n_th prime number.\"\"\" primes = [ 2 ] num = 3 while len ( primes ) < n : for p in primes : if num % p == 0 : break else : primes . append ( num ) num += 2 return primes [ - 1 ] class LongTask ( Task ): def setup ( self ): \"\"\"Set the task up before execution.\"\"\" pass def execute ( self , n : int ): return nth_prime_number ( n ) def teardown ( self ): \"\"\"Clean the task up after execution.\"\"\" pass In behaviours.py : from aea.skills.behaviours import TickerBehaviour from packages.my_author_name.skills.my_skill.tasks import LongTask class MyBehaviour ( TickerBehaviour ): def setup ( self ): my_task = LongTask () task_id = self . context . task_manager . enqueue_task ( my_task , args = ( 10000 , )) self . async_result = self . context . task_manager . get_task_result ( task_id ) # type: multiprocessing.pool.AsyncResult def act ( self ): if self . async_result . ready () is False : print ( \"The task is not finished yet.\" ) else : completed_task = self . async_result . get () # type: LongTask print ( \"The result is:\" , completed_task . result ) # Stop the skill self . context . is_active = False def teardown ( self ): pass","title":"tasks.py"},{"location":"aea/skill/#models","text":"The developer might want to add other classes on the context level which are shared equally across the Handler , Behaviour and Task classes. To this end, the developer can subclass an abstract Model . These models are made available on the context level upon initialization of the AEA. Say, the developer has a class called SomeModel class SomeModel ( Model ): ... Then, an instance of this class is available on the context level like so: some_model = self . context . some_model","title":"Models"},{"location":"aea/skill/#skill-config","text":"Each skill has a skill.yaml configuration file which lists all Behaviour , Handler , and Task objects pertaining to the skill. It also details the protocol types used in the skill and points to shared modules, i.e. modules of type Model , which allow custom classes within the skill to be accessible in the skill context. name : echo authors : fetchai version : 0.1.0 license : Apache-2.0 behaviours : echo : class_name : EchoBehaviour args : tick_interval : 1.0 handlers : echo : class_name : EchoHandler args : foo : bar models : {} dependencies : {} protocols : [ \"fetchai/default:0.1.0\" ]","title":"Skill config"},{"location":"aea/skill/#error-skill","text":"All AEA's have a default error skill that contains error handling code for a number of scenarios: Received envelopes with unsupported protocols Received envelopes with unsupported skills (i.e. protocols for which no handler is registered) Envelopes with decoding errors Invalid messages with respect to the registered protocol The error skill relies on the fetchai/default:0.1.0 protocol which provides error codes for the above.","title":"Error skill"},{"location":"aea/standalone-transaction/","text":"In this guide, we will generate some wealth for the Fetch.ai testnet and create a standalone transaction. After the completion of the transaction, we get the transaction digest. With this we can search for the transaction on the block explorer First, import the python and application specific libraries and set the static variables. import logging from aea.crypto.fetchai import FETCHAI from aea.crypto.helpers import _create_fetchai_private_key , _try_generate_testnet_wealth from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( level = logging . INFO ) FETCHAI_PRIVATE_KEY_FILE_1 = \"fet_private_key_1.txt\" FETCHAI_PRIVATE_KEY_FILE_2 = \"fet_private_key_2.txt\" Create the private keys # Create a private keys _create_fetchai_private_key ( private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) _create_fetchai_private_key ( private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 ) Create the wallets Once we created the private keys we need to generate the wallets. # Set up the wallets wallet_1 = Wallet ({ FETCHAI : FETCHAI_PRIVATE_KEY_FILE_1 }) wallet_2 = Wallet ({ FETCHAI : FETCHAI_PRIVATE_KEY_FILE_2 }) Create LedgerApis We need to create the LedgerApis object in order to be able to interact with the Fetch.ai testnet # Set up the LedgerApis ledger_apis = LedgerApis ({ FETCHAI : { \"network\" : \"testnet\" }}, FETCHAI ) Generate wealth Since we want to send funds from wallet_1 to wallet_2 , we need to generate some wealth for the wallet_1 . We can do this with the following code # Generate some wealth _try_generate_testnet_wealth ( FETCHAI , wallet_1 . addresses [ FETCHAI ]) Send transaction Finally, we create a transaction that sends the funds to the wallet_2 # Create the transaction and send it to the ledger. ledger_api = ledger_apis . apis [ FETCHAI ] tx_nonce = ledger_api . generate_tx_nonce ( wallet_2 . addresses . get ( FETCHAI ), wallet_1 . addresses . get ( FETCHAI ) ) tx_digest = ledger_api . send_transaction ( crypto = wallet_1 . crypto_objects . get ( FETCHAI ), destination_address = wallet_2 . addresses . get ( FETCHAI ), amount = 1 , tx_fee = 1 , tx_nonce = tx_nonce , ) logger . info ( \"Transaction complete.\" ) logger . info ( \"The transaction digest is {} \" . format ( tx_digest )) Stand-alone transaction full code import logging from aea.crypto.fetchai import FETCHAI from aea.crypto.helpers import _create_fetchai_private_key , _try_generate_testnet_wealth from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( level = logging . INFO ) FETCHAI_PRIVATE_KEY_FILE_1 = \"fet_private_key_1.txt\" FETCHAI_PRIVATE_KEY_FILE_2 = \"fet_private_key_2.txt\" def run (): # Create a private keys _create_fetchai_private_key ( private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) _create_fetchai_private_key ( private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 ) # Set up the wallets wallet_1 = Wallet ({ FETCHAI : FETCHAI_PRIVATE_KEY_FILE_1 }) wallet_2 = Wallet ({ FETCHAI : FETCHAI_PRIVATE_KEY_FILE_2 }) # Set up the LedgerApis ledger_apis = LedgerApis ({ FETCHAI : { \"network\" : \"testnet\" }}, FETCHAI ) # Generate some wealth _try_generate_testnet_wealth ( FETCHAI , wallet_1 . addresses [ FETCHAI ]) logger . info ( \"Sending amount to {} \" . format ( wallet_2 . addresses . get ( FETCHAI ))) # Create the transaction and send it to the ledger. ledger_api = ledger_apis . apis [ FETCHAI ] tx_nonce = ledger_api . generate_tx_nonce ( wallet_2 . addresses . get ( FETCHAI ), wallet_1 . addresses . get ( FETCHAI ) ) tx_digest = ledger_api . send_transaction ( crypto = wallet_1 . crypto_objects . get ( FETCHAI ), destination_address = wallet_2 . addresses . get ( FETCHAI ), amount = 1 , tx_fee = 1 , tx_nonce = tx_nonce , ) logger . info ( \"Transaction complete.\" ) logger . info ( \"The transaction digest is {} \" . format ( tx_digest )) if __name__ == \"__main__\" : run ()","title":"Create stand-alone transaction"},{"location":"aea/standalone-transaction/#create-the-private-keys","text":"# Create a private keys _create_fetchai_private_key ( private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) _create_fetchai_private_key ( private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 )","title":"Create the private keys"},{"location":"aea/standalone-transaction/#create-the-wallets","text":"Once we created the private keys we need to generate the wallets. # Set up the wallets wallet_1 = Wallet ({ FETCHAI : FETCHAI_PRIVATE_KEY_FILE_1 }) wallet_2 = Wallet ({ FETCHAI : FETCHAI_PRIVATE_KEY_FILE_2 })","title":"Create the wallets"},{"location":"aea/standalone-transaction/#create-ledgerapis","text":"We need to create the LedgerApis object in order to be able to interact with the Fetch.ai testnet # Set up the LedgerApis ledger_apis = LedgerApis ({ FETCHAI : { \"network\" : \"testnet\" }}, FETCHAI )","title":"Create LedgerApis"},{"location":"aea/standalone-transaction/#generate-wealth","text":"Since we want to send funds from wallet_1 to wallet_2 , we need to generate some wealth for the wallet_1 . We can do this with the following code # Generate some wealth _try_generate_testnet_wealth ( FETCHAI , wallet_1 . addresses [ FETCHAI ])","title":"Generate wealth"},{"location":"aea/standalone-transaction/#send-transaction","text":"Finally, we create a transaction that sends the funds to the wallet_2 # Create the transaction and send it to the ledger. ledger_api = ledger_apis . apis [ FETCHAI ] tx_nonce = ledger_api . generate_tx_nonce ( wallet_2 . addresses . get ( FETCHAI ), wallet_1 . addresses . get ( FETCHAI ) ) tx_digest = ledger_api . send_transaction ( crypto = wallet_1 . crypto_objects . get ( FETCHAI ), destination_address = wallet_2 . addresses . get ( FETCHAI ), amount = 1 , tx_fee = 1 , tx_nonce = tx_nonce , ) logger . info ( \"Transaction complete.\" ) logger . info ( \"The transaction digest is {} \" . format ( tx_digest )) Stand-alone transaction full code import logging from aea.crypto.fetchai import FETCHAI from aea.crypto.helpers import _create_fetchai_private_key , _try_generate_testnet_wealth from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( level = logging . INFO ) FETCHAI_PRIVATE_KEY_FILE_1 = \"fet_private_key_1.txt\" FETCHAI_PRIVATE_KEY_FILE_2 = \"fet_private_key_2.txt\" def run (): # Create a private keys _create_fetchai_private_key ( private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) _create_fetchai_private_key ( private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 ) # Set up the wallets wallet_1 = Wallet ({ FETCHAI : FETCHAI_PRIVATE_KEY_FILE_1 }) wallet_2 = Wallet ({ FETCHAI : FETCHAI_PRIVATE_KEY_FILE_2 }) # Set up the LedgerApis ledger_apis = LedgerApis ({ FETCHAI : { \"network\" : \"testnet\" }}, FETCHAI ) # Generate some wealth _try_generate_testnet_wealth ( FETCHAI , wallet_1 . addresses [ FETCHAI ]) logger . info ( \"Sending amount to {} \" . format ( wallet_2 . addresses . get ( FETCHAI ))) # Create the transaction and send it to the ledger. ledger_api = ledger_apis . apis [ FETCHAI ] tx_nonce = ledger_api . generate_tx_nonce ( wallet_2 . addresses . get ( FETCHAI ), wallet_1 . addresses . get ( FETCHAI ) ) tx_digest = ledger_api . send_transaction ( crypto = wallet_1 . crypto_objects . get ( FETCHAI ), destination_address = wallet_2 . addresses . get ( FETCHAI ), amount = 1 , tx_fee = 1 , tx_nonce = tx_nonce , ) logger . info ( \"Transaction complete.\" ) logger . info ( \"The transaction digest is {} \" . format ( tx_digest )) if __name__ == \"__main__\" : run ()","title":"Send transaction"},{"location":"aea/steps/","text":"There are a number of ways to build an AEA: To start with, we recommended you build an AEA project step-by-step with the CLI tool as demonstrated in the quick start guide and described here . Using the CLI aea fetch command, pull in an already built project and run as is or extend it to your needs. The last option is to build an AEA programmatically as described here . Sometimes, an AEA is more than is required for the task at hand. In particular, an AEA is much more than just an agent. In those cases, we suggest you have a look at the following two guides: the AEA vs Agents guide shows the difference between an agent and an AEA in code, the Use multiplexer standalone guide shows how to use the multiplexer on its own to receive and send envelopes.","title":"Ways to build an AEA"},{"location":"aea/tac-skills/","text":"The AEA TAC - trading agent competition - skills demonstrate an interaction between multiple AEAs in a game. There are two types of AEAs: The tac_controller which coordinates the game. The tac_participant AEAs which compete in the game. The tac_participant AEAs trade tokens with each other to maximize their utility. Discussion The scope of the specific demo is to demonstrate how the agents negotiate autonomously with each other while they pursue their goals by playing a game of TAC. An other AEA has the role of the controller and it's responsible for calculating the revenue for each participant and if the transaction messages are valid. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Launch an OEF search and communication node In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for all the following demos. Demo instructions 1: no ledger transactions This demo uses another AEA - a controller AEA - to take the role of running the competition and validating the transactions negotiated by the AEAs. Create the TAC controller AEA In the root directory, create the tac controller AEA and enter the project. aea create tac_controller cd tac_controller Add the tac control skill aea add connection fetchai/oef:0.1.0 aea add skill fetchai/tac_control:0.1.0 aea install Add the following configs to the aea config: ledger_apis : ethereum : addr : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 gas_price : 20 Set the default ledger to ethereum: aea config set agent.default_ledger ethereum Update the game parameters You can change the game parameters in tac_controller/skills/tac_control/skill.yaml under Parameters . You must set the start time to a point in the future start_time: 12 11 2019 15:01 . Alternatively, use the command line to get and set the start time: aea config get skills.tac_control.models.parameters.args.start_time aea config set skills.tac_control.models.parameters.args.start_time '21 12 2019 07:14' Run the TAC controller AEA aea run --connections fetchai/oef:0.1.0 Create the TAC participants AEA In a separate terminal, in the root directory, create the tac participant AEA. aea create tac_participant_one aea create tac_participant_two Add the tac participation skill to participant one cd tac_participant_one aea add connection fetchai/oef:0.1.0 aea add skill fetchai/tac_participation:0.1.0 aea add skill fetchai/tac_negotiation:0.1.0 aea install Set the default ledger to ethereum: aea config set agent.default_ledger ethereum Add the tac participation skill to participant two cd tac_participant_two aea add connection fetchai/oef:0.1.0 aea add skill fetchai/tac_participation:0.1.0 aea add skill fetchai/tac_negotiation:0.1.0 aea install Set the default ledger to ethereum: aea config set agent.default_ledger ethereum Run both the TAC participant AEAs aea run --connections fetchai/oef:0.1.0 Using aea launch The CLI tool supports the launch of several agents at once. For example, assuming you followed the tutorial, you can launch the TAC agents as follows: set the default connection fetchai/oef:0.1.0 for every agent; run: aea launch tac_controller tac_participant_one tac_participant_two Communication There are two types of interactions: - between the participants and the controller, the game communication - between the participants, the negotiation Registration communication This diagram shows the communication between the various entities during the registration phase. sequenceDiagram participant Agent_2 participant Agent_1 participant Search participant Controller activate Search activate Controller Controller->>Search: register_service activate Agent_1 Agent_1->>Search: search Search-->>Agent_1: controller Agent_1->>Controller: register activate Agent_2 Agent_2->>Search: search Search-->>Agent_2: controller Agent_2->>Controller: register Controller->>Agent_1: game_data Controller->>Agent_2: game_data deactivate Agent_1 deactivate Agent_2 deactivate Search deactivate Controller Transaction communication This diagram shows the communication between the two AEAs and the controller. In this case, we have a Seller_Agent which is set up as a seller (and registers itself as such with the controller during the registration phase). We also have the Searching_Agent which is set up to search for sellers. sequenceDiagram participant Buyer_Agent participant Seller_Agent participant Search participant Controller activate Buyer_Agent activate Seller_Agent activate Search activate Controller Seller_Agent->>Search: register_service Buyer_Agent->>Search: search Search-->>Buyer_Agent: list_of_agents Buyer_Agent->>Seller_Agent: call_for_proposal Seller_Agent->>Buyer_Agent: proposal Buyer_Agent->>Seller_Agent: accept Seller_Agent->>Buyer_Agent: match_accept Seller_Agent->>Controller: transaction Controller->>Controller: transaction_execution Controller->>Seller_Agent: confirm_transaction Controller->>Buyer_Agent: confirm_transaction deactivate Buyer_Agent deactivate Seller_Agent deactivate Search deactivate Controller In the above case, the proposal received contains a set of good which the seller wishes to sell and a cost of them. The buyer AEA needs to determine if this is a good deal for them and if so, it accepts. There is an equivalent diagram for seller AEAs set up to search for buyers and their interaction with AEAs which are registered as buyers. In that scenario, the proposal will instead, be a list of goods that the buyer wishes to buy and the price it is willing to pay for them. Negotiation skill - deep dive The AEA tac_negotiation skill demonstrates how negotiation strategies may be embedded into an Autonomous Economic Agent. The tac_negotiation skill skill.yaml configuration file looks like this. name : tac_negotiation authors : fetchai version : 0.1.0 license : Apache-2.0 description : \"The tac negotiation skill implements the logic for an AEA to do fipa negotiation in the TAC.\" behaviours : behaviour : class_name : GoodsRegisterAndSearchBehaviour args : services_interval : 5 clean_up : class_name : TransactionCleanUpTask args : tick_interval : 5.0 handlers : fipa : class_name : FIPANegotiationHandler args : {} transaction : class_name : TransactionHandler args : {} oef : class_name : OEFSearchHandler args : {} models : search : class_name : Search args : search_interval : 5 registration : class_name : Registration args : update_interval : 5 strategy : class_name : Strategy args : register_as : both search_for : both dialogues : class_name : Dialogues args : {} transactions : class_name : Transactions args : pending_transaction_timeout : 30 protocols : [ 'fetchai/oef_search:0.1.0' , 'fetchai/fipa:0.1.0' ] Above, you can see the registered Behaviour class name GoodsRegisterAndSearchBehaviour which implements register and search behaviour of an AEA for the tac_negotiation skill. The FIPANegotiationHandler deals with receiving FipaMessage types containing FIPA negotiation terms, such as cfp , propose , decline , accept and match_accept . The TransactionHandler deals with TransactionMessage s received from the decision maker component. The decision maker component is responsible for cryptoeconomic security. The OEFSearchHandler deals with OefSearchMessage types returned from the OEF search node The TransactionCleanUpTask is responsible for cleaning up transactions which are no longer likely to being settled with the controller AEA. Models The models element in the configuration yaml lists a number of important classes which are shared between the handlers, behaviours and tasks. Search This class abstracts the logic required by AEAs performing searches for other buying/selling AEAs according to strategy (see below). Registration This class abstracts the logic required by AEAs performing service registrations on the OEF search node . Strategy This class defines the strategy behind an AEA's activities. The class is instantiated with the AEA's goals, for example whether the AEA intends to buy/sell something, and is therefore looking for other sellers, buyers, or both. It also provides methods for defining what goods AEAs are looking for and what goods they may have to sell, for generating proposal queries, and checking whether a proposal is profitable or not. Dialogue Dialogues abstract the negotiations that take place between AEAs including all negotiation end states, such as accepted, declined, etc. and all the negotiation states in between. Transactions This class deals with representing potential transactions between AEAs.","title":"TAC skills"},{"location":"aea/tac-skills/#discussion","text":"The scope of the specific demo is to demonstrate how the agents negotiate autonomously with each other while they pursue their goals by playing a game of TAC. An other AEA has the role of the controller and it's responsible for calculating the revenue for each participant and if the transaction messages are valid.","title":"Discussion"},{"location":"aea/tac-skills/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/tac-skills/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/tac-skills/#launch-an-oef-search-and-communication-node","text":"In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for all the following demos.","title":"Launch an OEF search and communication node"},{"location":"aea/tac-skills/#demo-instructions-1-no-ledger-transactions","text":"This demo uses another AEA - a controller AEA - to take the role of running the competition and validating the transactions negotiated by the AEAs.","title":"Demo instructions 1: no ledger transactions"},{"location":"aea/tac-skills/#create-the-tac-controller-aea","text":"In the root directory, create the tac controller AEA and enter the project. aea create tac_controller cd tac_controller","title":"Create the TAC controller AEA"},{"location":"aea/tac-skills/#add-the-tac-control-skill","text":"aea add connection fetchai/oef:0.1.0 aea add skill fetchai/tac_control:0.1.0 aea install Add the following configs to the aea config: ledger_apis : ethereum : addr : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 gas_price : 20 Set the default ledger to ethereum: aea config set agent.default_ledger ethereum","title":"Add the tac control skill"},{"location":"aea/tac-skills/#update-the-game-parameters","text":"You can change the game parameters in tac_controller/skills/tac_control/skill.yaml under Parameters . You must set the start time to a point in the future start_time: 12 11 2019 15:01 . Alternatively, use the command line to get and set the start time: aea config get skills.tac_control.models.parameters.args.start_time aea config set skills.tac_control.models.parameters.args.start_time '21 12 2019 07:14'","title":"Update the game parameters"},{"location":"aea/tac-skills/#run-the-tac-controller-aea","text":"aea run --connections fetchai/oef:0.1.0","title":"Run the TAC controller AEA"},{"location":"aea/tac-skills/#create-the-tac-participants-aea","text":"In a separate terminal, in the root directory, create the tac participant AEA. aea create tac_participant_one aea create tac_participant_two","title":"Create the TAC participants AEA"},{"location":"aea/tac-skills/#add-the-tac-participation-skill-to-participant-one","text":"cd tac_participant_one aea add connection fetchai/oef:0.1.0 aea add skill fetchai/tac_participation:0.1.0 aea add skill fetchai/tac_negotiation:0.1.0 aea install Set the default ledger to ethereum: aea config set agent.default_ledger ethereum","title":"Add the tac participation skill to participant one"},{"location":"aea/tac-skills/#add-the-tac-participation-skill-to-participant-two","text":"cd tac_participant_two aea add connection fetchai/oef:0.1.0 aea add skill fetchai/tac_participation:0.1.0 aea add skill fetchai/tac_negotiation:0.1.0 aea install Set the default ledger to ethereum: aea config set agent.default_ledger ethereum","title":"Add the tac participation skill to participant two"},{"location":"aea/tac-skills/#run-both-the-tac-participant-aeas","text":"aea run --connections fetchai/oef:0.1.0","title":"Run both the TAC participant AEAs"},{"location":"aea/tac-skills/#using-aea-launch","text":"The CLI tool supports the launch of several agents at once. For example, assuming you followed the tutorial, you can launch the TAC agents as follows: set the default connection fetchai/oef:0.1.0 for every agent; run: aea launch tac_controller tac_participant_one tac_participant_two","title":"Using aea launch"},{"location":"aea/tac-skills/#communication","text":"There are two types of interactions: - between the participants and the controller, the game communication - between the participants, the negotiation","title":"Communication"},{"location":"aea/tac-skills/#registration-communication","text":"This diagram shows the communication between the various entities during the registration phase. sequenceDiagram participant Agent_2 participant Agent_1 participant Search participant Controller activate Search activate Controller Controller->>Search: register_service activate Agent_1 Agent_1->>Search: search Search-->>Agent_1: controller Agent_1->>Controller: register activate Agent_2 Agent_2->>Search: search Search-->>Agent_2: controller Agent_2->>Controller: register Controller->>Agent_1: game_data Controller->>Agent_2: game_data deactivate Agent_1 deactivate Agent_2 deactivate Search deactivate Controller","title":"Registration communication"},{"location":"aea/tac-skills/#transaction-communication","text":"This diagram shows the communication between the two AEAs and the controller. In this case, we have a Seller_Agent which is set up as a seller (and registers itself as such with the controller during the registration phase). We also have the Searching_Agent which is set up to search for sellers. sequenceDiagram participant Buyer_Agent participant Seller_Agent participant Search participant Controller activate Buyer_Agent activate Seller_Agent activate Search activate Controller Seller_Agent->>Search: register_service Buyer_Agent->>Search: search Search-->>Buyer_Agent: list_of_agents Buyer_Agent->>Seller_Agent: call_for_proposal Seller_Agent->>Buyer_Agent: proposal Buyer_Agent->>Seller_Agent: accept Seller_Agent->>Buyer_Agent: match_accept Seller_Agent->>Controller: transaction Controller->>Controller: transaction_execution Controller->>Seller_Agent: confirm_transaction Controller->>Buyer_Agent: confirm_transaction deactivate Buyer_Agent deactivate Seller_Agent deactivate Search deactivate Controller In the above case, the proposal received contains a set of good which the seller wishes to sell and a cost of them. The buyer AEA needs to determine if this is a good deal for them and if so, it accepts. There is an equivalent diagram for seller AEAs set up to search for buyers and their interaction with AEAs which are registered as buyers. In that scenario, the proposal will instead, be a list of goods that the buyer wishes to buy and the price it is willing to pay for them.","title":"Transaction communication"},{"location":"aea/tac-skills/#negotiation-skill-deep-dive","text":"The AEA tac_negotiation skill demonstrates how negotiation strategies may be embedded into an Autonomous Economic Agent. The tac_negotiation skill skill.yaml configuration file looks like this. name : tac_negotiation authors : fetchai version : 0.1.0 license : Apache-2.0 description : \"The tac negotiation skill implements the logic for an AEA to do fipa negotiation in the TAC.\" behaviours : behaviour : class_name : GoodsRegisterAndSearchBehaviour args : services_interval : 5 clean_up : class_name : TransactionCleanUpTask args : tick_interval : 5.0 handlers : fipa : class_name : FIPANegotiationHandler args : {} transaction : class_name : TransactionHandler args : {} oef : class_name : OEFSearchHandler args : {} models : search : class_name : Search args : search_interval : 5 registration : class_name : Registration args : update_interval : 5 strategy : class_name : Strategy args : register_as : both search_for : both dialogues : class_name : Dialogues args : {} transactions : class_name : Transactions args : pending_transaction_timeout : 30 protocols : [ 'fetchai/oef_search:0.1.0' , 'fetchai/fipa:0.1.0' ] Above, you can see the registered Behaviour class name GoodsRegisterAndSearchBehaviour which implements register and search behaviour of an AEA for the tac_negotiation skill. The FIPANegotiationHandler deals with receiving FipaMessage types containing FIPA negotiation terms, such as cfp , propose , decline , accept and match_accept . The TransactionHandler deals with TransactionMessage s received from the decision maker component. The decision maker component is responsible for cryptoeconomic security. The OEFSearchHandler deals with OefSearchMessage types returned from the OEF search node The TransactionCleanUpTask is responsible for cleaning up transactions which are no longer likely to being settled with the controller AEA.","title":"Negotiation skill - deep dive"},{"location":"aea/tac-skills/#models","text":"The models element in the configuration yaml lists a number of important classes which are shared between the handlers, behaviours and tasks.","title":"Models"},{"location":"aea/tac-skills/#search","text":"This class abstracts the logic required by AEAs performing searches for other buying/selling AEAs according to strategy (see below).","title":"Search"},{"location":"aea/tac-skills/#registration","text":"This class abstracts the logic required by AEAs performing service registrations on the OEF search node .","title":"Registration"},{"location":"aea/tac-skills/#strategy","text":"This class defines the strategy behind an AEA's activities. The class is instantiated with the AEA's goals, for example whether the AEA intends to buy/sell something, and is therefore looking for other sellers, buyers, or both. It also provides methods for defining what goods AEAs are looking for and what goods they may have to sell, for generating proposal queries, and checking whether a proposal is profitable or not.","title":"Strategy"},{"location":"aea/tac-skills/#dialogue","text":"Dialogues abstract the negotiations that take place between AEAs including all negotiation end states, such as accepted, declined, etc. and all the negotiation states in between.","title":"Dialogue"},{"location":"aea/tac-skills/#transactions","text":"This class deals with representing potential transactions between AEAs.","title":"Transactions"},{"location":"aea/tac/","text":"The original TAC has its own repo . Follow the instructions below to build and run the TAC demo. Requirements Make sure you are running Docker and Docker Compose . Quick start Clone the repo to include sub-modules. git clone git@github.com:fetchai/agents-tac.git --recursive && cd agents-tac Check you have pipenv . which pipenv If you don't have it, install it. Instructions are here . Create and launch a virtual environment. pipenv --python 3 .7 && pipenv shell Install the dependencies. pipenv install Install the package. python setup.py install Run the launch script. This may take a while. python scripts/launch.py The visdom server is now running. The controller GUI at http://localhost:8097 provides real time insights. In the Environment tab, make sure you have the tac_controller environment selected. Alternative build and run In a new terminal window, clone the repo, build the sandbox, and launch it. git clone git@github.com:fetchai/agents-tac.git --recursive && cd agents-tac pipenv --python 3 .7 && pipenv shell python setup.py install cd sandbox && docker-compose build docker-compose up In a new terminal window, enter the virtual environment, and connect a template agent to the sandbox. pipenv shell python templates/v1/basic.py --name my_agent --dashboard Click through to the controller GUI . Launcher GUI Todo Possible gotchas Stop all running containers before restart. docker stop $( docker ps -q ) To remove all images, run the following command. # mac docker ps -q | xargs docker stop ; docker system prune -a","title":"TAC external app"},{"location":"aea/tac/#requirements","text":"Make sure you are running Docker and Docker Compose .","title":"Requirements"},{"location":"aea/tac/#quick-start","text":"Clone the repo to include sub-modules. git clone git@github.com:fetchai/agents-tac.git --recursive && cd agents-tac Check you have pipenv . which pipenv If you don't have it, install it. Instructions are here . Create and launch a virtual environment. pipenv --python 3 .7 && pipenv shell Install the dependencies. pipenv install Install the package. python setup.py install Run the launch script. This may take a while. python scripts/launch.py The visdom server is now running. The controller GUI at http://localhost:8097 provides real time insights. In the Environment tab, make sure you have the tac_controller environment selected.","title":"Quick start"},{"location":"aea/tac/#alternative-build-and-run","text":"In a new terminal window, clone the repo, build the sandbox, and launch it. git clone git@github.com:fetchai/agents-tac.git --recursive && cd agents-tac pipenv --python 3 .7 && pipenv shell python setup.py install cd sandbox && docker-compose build docker-compose up In a new terminal window, enter the virtual environment, and connect a template agent to the sandbox. pipenv shell python templates/v1/basic.py --name my_agent --dashboard Click through to the controller GUI .","title":"Alternative build and run"},{"location":"aea/tac/#launcher-gui","text":"Todo","title":"Launcher GUI"},{"location":"aea/tac/#possible-gotchas","text":"Stop all running containers before restart. docker stop $( docker ps -q ) To remove all images, run the following command. # mac docker ps -q | xargs docker stop ; docker system prune -a","title":"Possible gotchas"},{"location":"aea/thermometer-skills-step-by-step/","text":"This guide is an introduction to building an AEA that represents static, and dynamic data to be advertised on the Open Economic Framework. Planning the AEA To follow this tutorial to completion you will need: - Raspberry Pi 4 Mini SD card Thermometer sensor AEA Framework The AEA will \u201clive\u201d inside the Raspberry Pi and will read the data from a sensor. Then it will connect to the OEF search and communication node and will identify itself as a seller of that data. Throughout the tutorial we are using Python3.7, but you can use any Python >= 3.6. Setup the environment You can follow this link here in order to setup your environment and prepare your raspberry. Once you setup your raspberry Open a terminal and navigate to /etc/udev/rules.d/ . Create a new file there (I named mine 99-hidraw-permissions.rules) sudo nano 99 -hidraw-permissions.rules and add the following inside the file: KERNEL == \"hidraw*\" , SUBSYSTEM == \"hidraw\" , MODE = \"0664\" , GROUP = \"plugdev\" this assigns all devices coming out of the hidraw subsystem in the kernel to the group plugdev and sets the permissions to r/w r/w r (for root [the default owner], plugdev, and everyone else respectively) Step1: Create the thermometer_AEA Create a new AEA by typing the following command in the terminal: aea create my_aea cd my_aea Our newly created AEA is inside the current working directory. Let\u2019s create our new skill that will handle the data type the following command: aea scaffold skill thermometer This command will create the correct structure for a new skill inside our AEA project You can locate the newly created skill inside the skills folder and it must contain the following files: - behaviours.py - handlers.py - my_model.py - skills.yaml - tasks.py - __init__.py Step2: Create the behaviour A Behaviour class contains the business logic specific to initial actions initiated by the AEA rather than reactions to other events. Open the behaviours.py (my_aea/skills/thermometer/behaviours.py) and add the following code from typing import Optional , cast from aea.crypto.ethereum import ETHEREUM from aea.crypto.fetchai import FETCHAI from aea.helpers.search.models import Description from aea.skills.behaviours import TickerBehaviour from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.protocols.oef_search.serialization import OefSearchSerializer from packages.fetchai.skills.thermometer.strategy import Strategy DEFAULT_SERVICES_INTERVAL = 30.0 class ServiceRegistrationBehaviour ( TickerBehaviour ): \"\"\"This class implements a behaviour.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialise the behaviour.\"\"\" services_interval = kwargs . pop ( \"services_interval\" , DEFAULT_SERVICES_INTERVAL ) # type: int super () . __init__ ( tick_interval = services_interval , ** kwargs ) self . _registered_service_description = None # type: Optional[Description] def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" if self . context . ledger_apis . has_fetchai : fet_balance = self . context . ledger_apis . token_balance ( FETCHAI , cast ( str , self . context . agent_addresses . get ( FETCHAI )) ) if fet_balance > 0 : self . context . logger . info ( \"[ {} ]: starting balance on fetchai ledger= {} .\" . format ( self . context . agent_name , fet_balance ) ) else : self . context . logger . warning ( \"[ {} ]: you have no starting balance on fetchai ledger!\" . format ( self . context . agent_name ) ) if self . context . ledger_apis . has_ethereum : eth_balance = self . context . ledger_apis . token_balance ( ETHEREUM , cast ( str , self . context . agent_addresses . get ( ETHEREUM )) ) if eth_balance > 0 : self . context . logger . info ( \"[ {} ]: starting balance on ethereum ledger= {} .\" . format ( self . context . agent_name , eth_balance ) ) else : self . context . logger . warning ( \"[ {} ]: you have no starting balance on ethereum ledger!\" . format ( self . context . agent_name ) ) self . _register_service () def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" self . _unregister_service () self . _register_service () def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" if self . context . ledger_apis . has_fetchai : balance = self . context . ledger_apis . token_balance ( FETCHAI , cast ( str , self . context . agent_addresses . get ( FETCHAI )) ) self . context . logger . info ( \"[ {} ]: ending balance on fetchai ledger= {} .\" . format ( self . context . agent_name , balance ) ) if self . context . ledger_apis . has_ethereum : balance = self . context . ledger_apis . token_balance ( ETHEREUM , cast ( str , self . context . agent_addresses . get ( ETHEREUM )) ) self . context . logger . info ( \"[ {} ]: ending balance on ethereum ledger= {} .\" . format ( self . context . agent_name , balance ) ) self . _unregister_service () def _register_service ( self ) -> None : \"\"\" Register to the OEF search node's service directory. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) desc = strategy . get_service_description () self . _registered_service_description = desc oef_msg_id = strategy . get_next_oef_msg_id () msg = OefSearchMessage ( performative = OefSearchMessage . Performative . REGISTER_SERVICE , dialogue_reference = ( str ( oef_msg_id ), \"\" ), service_description = desc , ) self . context . outbox . put_message ( to = self . context . search_service_address , sender = self . context . agent_address , protocol_id = OefSearchMessage . protocol_id , message = OefSearchSerializer () . encode ( msg ), ) self . context . logger . info ( \"[ {} ]: updating thermometer services on OEF search node's service directory.\" . format ( self . context . agent_name ) ) def _unregister_service ( self ) -> None : \"\"\" Unregister service from OEF search node's service directory. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) oef_msg_id = strategy . get_next_oef_msg_id () msg = OefSearchMessage ( performative = OefSearchMessage . Performative . UNREGISTER_SERVICE , dialogue_reference = ( str ( oef_msg_id ), \"\" ), service_description = self . _registered_service_description , ) self . context . outbox . put_message ( to = self . context . search_service_address , sender = self . context . agent_address , protocol_id = OefSearchMessage . protocol_id , message = OefSearchSerializer () . encode ( msg ), ) self . context . logger . info ( \"[ {} ]: unregistering thermometer station services from OEF search node's service directory.\" . format ( self . context . agent_name ) ) self . _registered_service_description = None This Behaviour will register and de-register our AEA\u2019s service on the OEF search node at regular tick intervals. By registering, the AEA becomes discoverable to possible clients. Currently, the AEA-framework supports two different blockchains [Ethereum, Fetchai], and that\u2019s the reason we are checking if we have balance for these two blockchains in the setup method. The act method unregisters and registers the AEA to the OEF search node on each tick. Finally, the teardown method unregisters the AEA and reports your balances. Step3: Create the handler So far, we have tasked the AEA with sending register/unregister requests to the OEF search node . However, we have no way of handling the responses sent to the AEA by the OEF search node or any other AEA at the moment. This script contains the logic to negotiate with another AEA based on the strategy we want our AEA to follow. (we are going to write this next) . It is important to understand the way a negotiation happens between two AEAs. The following diagram illustrates the negotiation flow, up to the agreement between a seller_AEA and a client_AEA. sequenceDiagram participant Search participant Client_AEA participant Seller_AEA participant Blockchain activate Client_AEA activate Search activate Seller_AEA activate Blockchain Seller_AEA->>Search: register_service Client_AEA->>Search: search Search-->>Client_AEA: list_of_agents Client_AEA->>Seller_AEA: call_for_proposal Seller_AEA->>Client_AEA: propose Client_AEA->>Seller_AEA: accept Seller_AEA->>Client_AEA: match_accept Client_AEA->>Blockchain: transfer_funds Client_AEA->>Seller_AEA: send_transaction_hash Seller_AEA->>Blockchain: check_transaction_status Seller_AEA->>Client_AEA: send_data deactivate Client_AEA deactivate Search deactivate Seller_AEA deactivate Blockchain Let us now implement a handler to deal with the incoming responses. Open the handlers.py (my_aea/skills/thermometer/handlers.py) and add the following code: from typing import Optional , cast from aea.configurations.base import ProtocolId from aea.helpers.search.models import Description , Query from aea.protocols.base import Message from aea.protocols.default.message import DefaultMessage from aea.protocols.default.serialization import DefaultSerializer from aea.skills.base import Handler from packages.fetchai.protocols.fipa.message import FipaMessage from packages.fetchai.protocols.fipa.serialization import FipaSerializer from packages.fetchai.skills.thermometer.dialogues import Dialogue , Dialogues from packages.fetchai.skills.thermometer.strategy import Strategy class FIPAHandler ( Handler ): \"\"\"This class scaffolds a handler.\"\"\" SUPPORTED_PROTOCOL = FipaMessage . protocol_id # type: Optional[ProtocolId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" # convenience representations fipa_msg = cast ( FipaMessage , message ) dialogue_reference = fipa_msg . dialogue_reference # recover dialogue dialogues = cast ( Dialogues , self . context . dialogues ) if dialogues . is_belonging_to_registered_dialogue ( fipa_msg , self . context . agent_address ): dialogue = cast ( Dialogue , dialogues . get_dialogue ( fipa_msg , self . context . agent_address ) ) dialogue . incoming_extend ( fipa_msg ) elif dialogues . is_permitted_for_new_dialogue ( fipa_msg ): dialogue = cast ( Dialogue , dialogues . create_opponent_initiated ( message . counterparty , dialogue_reference = dialogue_reference , is_seller = True , ), ) dialogue . incoming_extend ( fipa_msg ) else : self . _handle_unidentified_dialogue ( fipa_msg ) return # handle message if fipa_msg . performative == FipaMessage . Performative . CFP : self . _handle_cfp ( fipa_msg , dialogue ) elif fipa_msg . performative == FipaMessage . Performative . DECLINE : self . _handle_decline ( fipa_msg , dialogue ) elif fipa_msg . performative == FipaMessage . Performative . ACCEPT : self . _handle_accept ( fipa_msg , dialogue ) elif fipa_msg . performative == FipaMessage . Performative . INFORM : self . _handle_inform ( fipa_msg , dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass The code above is logic for handling messages and storing the dialogues between the seller_aea and the client_aea. We are checking if the dialogue is registered to an existing one or we have to create a new dialogue. The second part checks what kind of message we received. We are going to implement each case in a different function. Under the teardown function add the following code: def _handle_unidentified_dialogue ( self , msg : FipaMessage ) -> None : \"\"\" Handle an unidentified dialogue. Respond to the sender with a default message containing the appropriate error information. :param msg: the message :return: None \"\"\" self . context . logger . info ( \"[ {} ]: unidentified dialogue.\" . format ( self . context . agent_name )) default_msg = DefaultMessage ( performative = DefaultMessage . Performative . ERROR , error_code = DefaultMessage . ErrorCode . INVALID_DIALOGUE . value , error_msg = \"Invalid dialogue.\" , error_data = \"fipa_message\" , ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = DefaultMessage . protocol_id , message = DefaultSerializer () . encode ( default_msg ), ) The above code handles an unidentified dialogue by responding to the sender with a default message containing the appropriate error information. The next code block handles the CFP message, paste the code under the _handle_unidentified_dialogue function : def _handle_cfp ( self , msg : FipaMessage , dialogue : Dialogue ) -> None : \"\"\" Handle the CFP. If the CFP matches the supplied services then send a PROPOSE, otherwise send a DECLINE. :param msg: the message :param dialogue: the dialogue object :return: None \"\"\" new_message_id = msg . message_id + 1 new_target = msg . message_id self . context . logger . info ( \"[ {} ]: received CFP from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) query = cast ( Query , msg . query ) strategy = cast ( Strategy , self . context . strategy ) if strategy . is_matching_supply ( query ): proposal , temp_data = strategy . generate_proposal_and_data ( query , msg . counterparty ) dialogue . temp_data = temp_data dialogue . proposal = proposal self . context . logger . info ( \"[ {} ]: sending sender= {} a PROPOSE with proposal= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :], proposal . values ) ) proposal_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target , performative = FipaMessage . Performative . PROPOSE , proposal = [ proposal ], ) dialogue . outgoing_extend ( proposal_msg ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( proposal_msg ), ) else : self . context . logger . info ( \"[ {} ]: declined the CFP from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) decline_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target , performative = FipaMessage . Performative . DECLINE , ) dialogue . outgoing_extend ( decline_msg ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( decline_msg ), ) The above code will respond with a proposal to the client if the CFP matches the supplied services and our strategy otherwise it will respond with a Decline message. The next code-block handles the decline message we receive from the client. Add the following code under the _handle_cfp function: def _handle_decline ( self , msg : FipaMessage , dialogue : Dialogue ) -> None : \"\"\" Handle the DECLINE. Close the dialogue. :param msg: the message :param dialogue: the dialogue object :return: None \"\"\" self . context . logger . info ( \"[ {} ]: received DECLINE from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) dialogues = cast ( Dialogues , self . context . dialogues ) dialogues . dialogue_stats . add_dialogue_endstate ( Dialogue . EndState . DECLINED_PROPOSE , dialogue . is_self_initiated ) If we receive a decline message from the client we have to close the dialogue and terminate the conversation with the client_aea. The opposite would be to receive an accept message. Inorder to handle this option add the following code under the _handle_decline function: def _handle_accept ( self , msg : FipaMessage , dialogue : Dialogue ) -> None : \"\"\" Handle the ACCEPT. Respond with a MATCH_ACCEPT_W_INFORM which contains the address to send the funds to. :param msg: the message :param dialogue: the dialogue object :return: None \"\"\" new_message_id = msg . message_id + 1 new_target = msg . message_id self . context . logger . info ( \"[ {} ]: received ACCEPT from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) self . context . logger . info ( \"[ {} ]: sending MATCH_ACCEPT_W_INFORM to sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) proposal = cast ( Description , dialogue . proposal ) identifier = cast ( str , proposal . values . get ( \"ledger_id\" )) match_accept_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target , performative = FipaMessage . Performative . MATCH_ACCEPT_W_INFORM , info = { \"address\" : self . context . agent_addresses [ identifier ]}, ) dialogue . outgoing_extend ( match_accept_msg ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( match_accept_msg ), ) When the client_aea accepts the proposal we send him, we also have to respond with another message (MATCH_ACCEPT_W_INFORM ) to inform the client about the address we would like to send the funds to. Lastly, when we receive the \u201cinform\u201d message means that the client sends the funds to the specific address. Add the following code : def _handle_inform ( self , msg : FipaMessage , dialogue : Dialogue ) -> None : \"\"\" Handle the INFORM. If the INFORM message contains the transaction_digest then verify that it is settled, otherwise do nothing. If the transaction is settled send the temperature data, otherwise do nothing. :param msg: the message :param dialogue: the dialogue object :return: None \"\"\" new_message_id = msg . message_id + 1 new_target = msg . message_id logger . info ( \"[ {} ]: received INFORM from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) strategy = cast ( Strategy , self . context . strategy ) if strategy . is_ledger_tx and ( \"transaction_digest\" in msg . info . keys ()): tx_digest = msg . info [ \"transaction_digest\" ] self . context . logger . info ( \"[ {} ]: checking whether transaction= {} has been received ...\" . format ( self . context . agent_name , tx_digest ) ) proposal = cast ( Description , dialogue . proposal ) ledger_id = cast ( str , proposal . values . get ( \"ledger_id\" )) is_valid = self . context . ledger_apis . is_tx_valid ( ledger_id , tx_digest , self . context . agent_addresses [ ledger_id ], msg . counterparty , cast ( str , proposal . values . get ( \"tx_nonce\" )), cast ( int , proposal . values . get ( \"price\" )), ) if is_valid : token_balance = self . context . ledger_apis . token_balance ( ledger_id , cast ( str , self . context . agent_addresses . get ( ledger_id )) ) self . context . logger . info ( \"[ {} ]: transaction= {} settled, new balance= {} . Sending data to sender= {} \" . format ( self . context . agent_name , tx_digest , token_balance , msg . counterparty [ - 5 :], ) ) inform_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target , performative = FipaMessage . Performative . INFORM , info = dialogue . temp_data , ) dialogue . outgoing_extend ( inform_msg ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( inform_msg ), ) dialogues = cast ( Dialogues , self . context . dialogues ) dialogues . dialogue_stats . add_dialogue_endstate ( Dialogue . EndState . SUCCESSFUL , dialogue . is_self_initiated ) else : self . context . logger . info ( \"[ {} ]: transaction= {} not settled, aborting\" . format ( self . context . agent_name , tx_digest ) ) elif \"Done\" in msg . info . keys (): inform_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target , performative = FipaMessage . Performative . INFORM , info = dialogue . temp_data , ) dialogue . outgoing_extend ( inform_msg ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( inform_msg ), ) dialogues = cast ( Dialogues , self . context . dialogues ) dialogues . dialogue_stats . add_dialogue_endstate ( Dialogue . EndState . SUCCESSFUL , dialogue . is_self_initiated ) else : self . context . logger . warning ( \"[ {} ]: did not receive transaction digest from sender= {} .\" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) We are checking the inform message. If it contains the transaction digest we verify that transaction matches the proposal that the client accepted. If the transaction is valid and we received the funds then we send the data to the client. Otherwise we don\u2019t do anything. Step4: Create the strategy We are going to create the strategy that we want our AEA to follow. Rename the my_model.py file to strategy.py and paste the following code: from random import randrange from typing import Any , Dict , Tuple from temper import Temper from aea.helpers.search.models import Description , Query from aea.mail.base import Address from aea.skills.base import Model from packages.fetchai.skills.thermometer.thermometer_data_model import ( SCHEME , THERMOMETER_DATAMODEL , ) DEFAULT_PRICE_PER_ROW = 1 DEFAULT_SELLER_TX_FEE = 0 DEFAULT_CURRENCY_PBK = \"FET\" DEFAULT_LEDGER_ID = \"fetchai\" DEFAULT_IS_LEDGER_TX = True DEFAULT_HAS_SENSOR = True class Strategy ( Model ): \"\"\"This class defines a strategy for the agent.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize the strategy of the agent. :param register_as: determines whether the agent registers as seller, buyer or both :param search_for: determines whether the agent searches for sellers, buyers or both :return: None \"\"\" self . _price_per_row = kwargs . pop ( \"price_per_row\" , DEFAULT_PRICE_PER_ROW ) self . _seller_tx_fee = kwargs . pop ( \"seller_tx_fee\" , DEFAULT_SELLER_TX_FEE ) self . _currency_id = kwargs . pop ( \"currency_id\" , DEFAULT_CURRENCY_PBK ) self . _ledger_id = kwargs . pop ( \"ledger_id\" , DEFAULT_LEDGER_ID ) self . is_ledger_tx = kwargs . pop ( \"is_ledger_tx\" , DEFAULT_IS_LEDGER_TX ) self . _has_sensor = kwargs . pop ( \"has_sensor\" , DEFAULT_HAS_SENSOR ) super () . __init__ ( ** kwargs ) self . _oef_msg_id = 0 We initialise the strategy class. We are trying to read the strategy variables from the yaml file. If this is not possible we specified some default values. The following three functions are related with the oef registration and we assume that the query matches the supply, add them under the initialization of the class: def get_next_oef_msg_id ( self ) -> int : \"\"\" Get the next oef msg id. :return: the next oef msg id \"\"\" self . _oef_msg_id += 1 return self . _oef_msg_id def get_service_description ( self ) -> Description : \"\"\" Get the service description. :return: a description of the offered services \"\"\" desc = Description ( SCHEME , data_model = THERMOMETER_DATAMODEL ()) return desc def is_matching_supply ( self , query : Query ) -> bool : \"\"\" Check if the query matches the supply. :param query: the query :return: bool indicating whether matches or not \"\"\" # TODO, this is a stub return True Lastly, we are going to create the function that generates the proposal that we will send to the aea_client: def generate_proposal_and_data ( self , query : Query , counterparty : Address ) -> Tuple [ Description , Dict [ str , Any ]]: \"\"\" Generate a proposal matching the query. :param counterparty: the counterparty of the proposal. :param query: the query :return: a tuple of proposal and the temperature data \"\"\" tx_nonce = self . context . ledger_apis . generate_tx_nonce ( identifier = self . _ledger_id , seller = self . context . agent_addresses [ self . _ledger_id ], client = counterparty , ) temp_data = self . _build_data_payload () total_price = self . _price_per_row assert ( total_price - self . _seller_tx_fee > 0 ), \"This sale would generate a loss, change the configs!\" proposal = Description ( { \"price\" : total_price , \"seller_tx_fee\" : self . _seller_tx_fee , \"currency_id\" : self . _currency_id , \"ledger_id\" : self . _ledger_id , \"tx_nonce\" : tx_nonce , } ) return proposal , temp_data def _build_data_payload ( self ) -> Dict [ str , Any ]: \"\"\" Build the data payload. :return: a tuple of the data and the rows \"\"\" if self . _has_sensor : temper = Temper () while True : results = temper . read () if \"internal temperature\" in results . keys (): degrees = { \"thermometer_data\" : results } else : self . context . logger . debug ( \"Couldn't read the sensor I am re-trying.\" ) else : degrees = { \"thermometer_data\" : randrange ( 10 , 25 )} self . context . logger . info ( degrees ) return degrees Before the creation of the actual proposal, we have to check if this sale generates value for us or a loss. If it is a loss, we ask the user to change the configurations. The helper private function _build_data_payload, is where we read data from our sensor or in case we don\u2019t have a sensor generate a random number. Step5: Create the dialogues When we are negotiating with other AEA we would like to keep track on these negotiations for various reasons. So create a new file and name it dialogues.py. Inside this file add the following code: from typing import Any , Dict , Optional from aea.helpers.dialogue.base import DialogueLabel from aea.helpers.search.models import Description from aea.skills.base import Model from packages.fetchai.protocols.fipa.dialogues import FipaDialogue , FipaDialogues class Dialogue ( FipaDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" def __init__ ( self , dialogue_label : DialogueLabel , is_seller : bool ) -> None : \"\"\" Initialize a dialogue label. :param dialogue_label: the identifier of the dialogue :param is_seller: indicates whether the agent associated with the dialogue is a seller or buyer :return: None \"\"\" FipaDialogue . __init__ ( self , dialogue_label = dialogue_label , is_seller = is_seller ) self . temp_data = None # type: Optional[Dict[str, Any]] self . proposal = None # type: Optional[Description] class Dialogues ( Model , FipaDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" Model . __init__ ( self , ** kwargs ) FipaDialogues . __init__ ( self ) The dialogues class stores dialogue with each client_aea in a list so we can have access to previous messages and enable us to identify possible communications problems between the seller_aea and the client_aea. Also contains the data that we fetch during the proposal phase. Step6: Create the data_model Each AEA in the oef needs a Description in order to be able to register as a service.The data model will help us create this description. Create a new file and call it thermometer_data_model.py and paste the following code: from aea.helpers.search.models import Attribute , DataModel SCHEME = { \"country\" : \"UK\" , \"city\" : \"Cambridge\" } class Thermometer_Datamodel ( DataModel ): \"\"\"Data model for the thermo Agent.\"\"\" def __init__ ( self ): \"\"\"Initialise the dataModel.\"\"\" self . attribute_country = Attribute ( \"country\" , str , True ) self . attribute_city = Attribute ( \"city\" , str , True ) super () . __init__ ( \"thermometer_datamodel\" , [ self . attribute_country , self . attribute_city ] ) This data model registers to the OEF search node as an AEA that is in the UK and specifically in Cambridge. If a client_AEA searches for AEA in the UK the oef will respond with the address of our AEA. Step7: Update the YAML files Since we made so many changes to our AEA we have to update the skill.yaml and the aea-config.yaml to contain our newly created scripts and the details that will be used from the strategy. Firstly, we will update the skill.yaml. Make sure that your skill.yaml matches with the following code name : thermometer author : fetchai version : 0.1.0 license : Apache-2.0 fingerprint : \"\" description : \"The thermometer skill implements the functionality to sell data.\" behaviours : service_registration : class_name : ServiceRegistrationBehaviour args : services_interval : 60 handlers : fipa : class_name : FIPAHandler args : {} models : strategy : class_name : Strategy args : price : 1 seller_tx_fee : 0 currency_id : 'FET' ledger_id : 'fetchai' has_sensor : True is_ledger_tx : True dialogues : class_name : Dialogues args : {} protocols : [ 'fetchai/fipa:0.1.0' , 'fetchai/oef_search:0.1.0' , 'fetchai/default:0.1.0' ] ledgers : [ 'fetchai' ] dependencies : pyserial : {} temper-py : {} We must pay attention to the models and the strategy\u2019s variables. Here we can change the price we would like to sell each reading or the currency we would like to transact with. Lastly,the dependencies are the third party packages we need to install in order to get readings from the sensor. The next file we have to update is the aea-config.yaml file. You can locate this file under your AEA\u2019s folder. We are going to modify this file later on before we run the aea but for now make sure it matches the following code : aea_version: 0.2.4 agent_name: my_aea author: author connections: - fetchai/oef:0.1.0 - fetchai/stub:0.1.0 default_connection: fetchai/stub:0.1.0 default_ledger: fetchai description: '' fingerprint: '' ledger_apis: {} license: Apache-2.0 logging_config: disable_existing_loggers: false version: 1 private_key_paths: {} protocols: - fetchai/default:0.1.0 registry_path: ../packages skills: - author/thermometer:0.1.0 - fetchai/error:0.1.0 version: 0.1.0 Step1: Create the Client_AEA Create a new AEA by typing the following command in the terminal: aea create my_client cd my_client Our newly created AEA is inside the current working directory. Let\u2019s create our new skill that will handle the data type the following command: aea scaffold skill thermometer_client This command will create the correct structure for a new skill inside our AEA project You can locate the newly created skill inside the skills folder and it must contain the following files: - behaviours.py - handlers.py - my_model.py - skills.yaml - tasks.py - __init__.py Step2: Create the behaviour A Behaviour class contains the business logic specific to initial actions initiated by the AEA rather than reactions to other events. Open the behaviours.py (my_client/skills/thermometer_client/behaviours.py) and add the following code: from typing import cast from aea.crypto.ethereum import ETHEREUM from aea.crypto.fetchai import FETCHAI from aea.skills.behaviours import TickerBehaviour from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.protocols.oef_search.serialization import OefSearchSerializer from packages.fetchai.skills.thermometer_client.strategy import Strategy DEFAULT_SEARCH_INTERVAL = 5.0 class MySearchBehaviour ( TickerBehaviour ): \"\"\"This class implements a search behaviour.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialize the search behaviour.\"\"\" search_interval = cast ( float , kwargs . pop ( \"search_interval\" , DEFAULT_SEARCH_INTERVAL ) ) super () . __init__ ( tick_interval = search_interval , ** kwargs ) def setup ( self ) -> None : \"\"\"Implement the setup for the behaviour.\"\"\" if self . context . ledger_apis . has_fetchai : fet_balance = self . context . ledger_apis . token_balance ( FETCHAI , cast ( str , self . context . agent_addresses . get ( FETCHAI )) ) if fet_balance > 0 : self . context . logger . info ( \"[ {} ]: starting balance on fetchai ledger= {} .\" . format ( self . context . agent_name , fet_balance ) ) else : self . context . logger . warning ( \"[ {} ]: you have no starting balance on fetchai ledger!\" . format ( self . context . agent_name ) ) if self . context . ledger_apis . has_ethereum : eth_balance = self . context . ledger_apis . token_balance ( ETHEREUM , cast ( str , self . context . agent_addresses . get ( ETHEREUM )) ) if eth_balance > 0 : self . context . logger . info ( \"[ {} ]: starting balance on ethereum ledger= {} .\" . format ( self . context . agent_name , eth_balance ) ) else : self . context . logger . warning ( \"[ {} ]: you have no starting balance on ethereum ledger!\" . format ( self . context . agent_name ) ) def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) if strategy . is_searching : query = strategy . get_service_query () search_id = strategy . get_next_search_id () oef_msg = OefSearchMessage ( performative = OefSearchMessage . Performative . SEARCH_SERVICES , dialogue_reference = ( str ( search_id ), \"\" ), query = query ) self . context . outbox . put_message ( to = self . context . search_service_address , sender = self . context . agent_address , protocol_id = OefSearchMessage . protocol_id , message = OefSearchSerializer () . encode ( oef_msg ), ) def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" if self . context . ledger_apis . has_fetchai : balance = self . context . ledger_apis . token_balance ( FETCHAI , cast ( str , self . context . agent_addresses . get ( FETCHAI )) ) self . context . logger . info ( \"[ {} ]: ending balance on fetchai ledger= {} .\" . format ( self . context . agent_name , balance ) ) if self . context . ledger_apis . has_ethereum : balance = self . context . ledger_apis . token_balance ( ETHEREUM , cast ( str , self . context . agent_addresses . get ( ETHEREUM )) ) self . context . logger . info ( \"[ {} ]: ending balance on ethereum ledger= {} .\" . format ( self . context . agent_name , balance ) ) This Behaviour will register to the Search_Service of the oef with a specific query at regular tick intervals. By registering to the search service the OEF search node can respond with possible sellers that match our query. Step3: Create the handler So far, we have tasked the AEA with sending search queries to the OEF search node . However, we have no way of handling the responses sent to the AEA by the OEF search node or any other agent at the moment. This script contains the logic to negotiate with another AEA based on the strategy we want our AEA to follow (we are going to write this next) . import pprint from typing import Any , Dict , List , Optional , cast from aea.configurations.base import ProtocolId , PublicId from aea.decision_maker.messages.transaction import TransactionMessage from aea.helpers.dialogue.base import DialogueLabel from aea.helpers.search.models import Description from aea.protocols.base import Message from aea.protocols.default.message import DefaultMessage from aea.protocols.default.serialization import DefaultSerializer from aea.skills.base import Handler from packages.fetchai.protocols.fipa.message import FipaMessage from packages.fetchai.protocols.fipa.serialization import FipaSerializer from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.thermometer_client.dialogues import Dialogue , Dialogues from packages.fetchai.skills.thermometer_client.strategy import Strategy class FIPAHandler ( Handler ): \"\"\"This class scaffolds a handler.\"\"\" SUPPORTED_PROTOCOL = FipaMessage . protocol_id # type: Optional[ProtocolId] def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" # convenience representations fipa_msg = cast ( FipaMessage , message ) # recover dialogue dialogues = cast ( Dialogues , self . context . dialogues ) if dialogues . is_belonging_to_registered_dialogue ( fipa_msg , self . context . agent_address ): dialogue = cast ( Dialogue , dialogues . get_dialogue ( fipa_msg , self . context . agent_address ) ) dialogue . incoming_extend ( fipa_msg ) else : self . _handle_unidentified_dialogue ( fipa_msg ) return # handle message if fipa_msg . performative == FipaMessage . Performative . PROPOSE : self . _handle_propose ( fipa_msg , dialogue ) elif fipa_msg . performative == FipaMessage . Performative . DECLINE : self . _handle_decline ( fipa_msg , dialogue ) elif fipa_msg . performative == FipaMessage . Performative . MATCH_ACCEPT_W_INFORM : self . _handle_match_accept ( fipa_msg , dialogue ) elif fipa_msg . performative == FipaMessage . Performative . INFORM : self . _handle_inform ( fipa_msg , dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass You will see that we are following similar logic when we develop the client\u2019s side of the negotiation. The first thing is that we create a new dialogue and we store it in the dialogues class. Then we are checking what kind of message we received. So lets start creating our handlers: def _handle_unidentified_dialogue ( self , msg : FipaMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the message \"\"\" self . context . logger . info ( \"[ {} ]: unidentified dialogue.\" . format ( self . context . agent_name )) default_msg = DefaultMessage ( performative = DefaultMessage . Performative . ERROR , error_code = DefaultMessage . ErrorCode . INVALID_DIALOGUE . value , error_msg = \"Invalid dialogue.\" , error_data = \"fipa_message\" , ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = DefaultMessage . protocol_id , message = DefaultSerializer () . encode ( default_msg ), ) The above code handles the unidentified dialogues. And responds with an error message to the sender. Next we will handle the proposal that we receive from the seller_aea : def _handle_propose ( self , msg : FipaMessage , dialogue : Dialogue ) -> None : \"\"\" Handle the propose. :param msg: the message :param dialogue: the dialogue object :return: None \"\"\" new_message_id = msg . message_id + 1 new_target_id = msg . message_id proposals = msg . proposal if proposals is not []: # only take the first proposal proposal = proposals [ 0 ] self . context . logger . info ( \"[ {} ]: received proposal= {} from sender= {} \" . format ( self . context . agent_name , proposal . values , msg . counterparty [ - 5 :] ) ) strategy = cast ( Strategy , self . context . strategy ) acceptable = strategy . is_acceptable_proposal ( proposal ) affordable = strategy . is_affordable_proposal ( proposal ) if acceptable and affordable : strategy . is_searching = False self . context . logger . info ( \"[ {} ]: accepting the proposal from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) dialogue . proposal = proposal accept_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target_id , performative = FipaMessage . Performative . ACCEPT , ) dialogue . outgoing_extend ( accept_msg ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( accept_msg ), ) else : self . context . logger . info ( \"[ {} ]: declining the proposal from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) decline_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target_id , performative = FipaMessage . Performative . DECLINE , ) dialogue . outgoing_extend ( decline_msg ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( decline_msg ), ) When we receive a proposal we have to check if we have the funds to complete the transaction and if the proposal is acceptable based on our strategy. If the proposal is not affordable or acceptable we respond with a decline message. Otherwise, we send an accept message to the seller. The next code-block handles the decline message that we may receive from the client on our CFP message or our ACCEPT message: def _handle_decline ( self , msg : FipaMessage , dialogue : Dialogue ) -> None : \"\"\" Handle the decline. :param msg: the message :param dialogue: the dialogue object :return: None \"\"\" self . context . logger . info ( \"[ {} ]: received DECLINE from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) target = msg . get ( \"target\" ) dialogues = cast ( Dialogues , self . context . dialogues ) if target == 1 : dialogues . dialogue_stats . add_dialogue_endstate ( Dialogue . EndState . DECLINED_CFP , dialogue . is_self_initiated ) elif target == 3 : dialogues . dialogue_stats . add_dialogue_endstate ( Dialogue . EndState . DECLINED_ACCEPT , dialogue . is_self_initiated ) The above code terminates each dialogue with the specific aea and stores the step. For example, if the target == 1 we know that the seller declined our CFP message. In case you didn\u2019t receive any decline message that means that the seller_aea want to move on with the sale, in that case, it will send a match_accept message in order to handle this add the following code : def _handle_match_accept ( self , msg : FipaMessage , dialogue : Dialogue ) -> None : \"\"\" Handle the match accept. :param msg: the message :param dialogue: the dialogue object :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) if strategy . is_ledger_tx : self . context . logger . info ( \"[ {} ]: received MATCH_ACCEPT_W_INFORM from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) info = msg . info address = cast ( str , info . get ( \"address\" )) proposal = cast ( Description , dialogue . proposal ) tx_msg = TransactionMessage ( performative = TransactionMessage . Performative . PROPOSE_FOR_SETTLEMENT , skill_callback_ids = [ PublicId ( \"fetchai\" , \"thermometer_client\" , \"0.1.0\" )], tx_id = \"transaction0\" , tx_sender_addr = self . context . agent_addresses [ proposal . values [ \"ledger_id\" ] ], tx_counterparty_addr = address , tx_amount_by_currency_id = { proposal . values [ \"currency_id\" ]: - proposal . values [ \"price\" ] }, tx_sender_fee = strategy . max_buyer_tx_fee , tx_counterparty_fee = proposal . values [ \"seller_tx_fee\" ], tx_quantities_by_good_id = {}, ledger_id = proposal . values [ \"ledger_id\" ], info = { \"dialogue_label\" : dialogue . dialogue_label . json }, tx_nonce = proposal . values . get ( \"tx_nonce\" ), ) self . context . decision_maker_message_queue . put_nowait ( tx_msg ) self . context . logger . info ( \"[ {} ]: proposing the transaction to the decision maker. Waiting for confirmation ...\" . format ( self . context . agent_name ) ) else : new_message_id = msg . message_id + 1 new_target = msg . message_id inform_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target , performative = FipaMessage . Performative . INFORM , info = { \"Done\" : \"Sending payment via bank transfer\" }, ) dialogue . outgoing_extend ( inform_msg ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( inform_msg ), ) self . context . logger . info ( \"[ {} ]: informing counterparty= {} of payment.\" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) The first thing we are checking is if we enabled our aea to transact with a ledger. If we can transact with a ledger we generate a transaction message and we propose it to the decision_maker. The decision_maker then will check the transaction message if it is acceptable, we have the funds, etc, it signs and sends the transaction to the specified ledger. Then it returns us the transaction digest. Lastly, we need to handle the inform message because this is the message that will have our data: def _handle_inform ( self , msg : FipaMessage , dialogue : Dialogue ) -> None : \"\"\" Handle the match inform. :param msg: the message :param dialogue: the dialogue object :return: None \"\"\" self . context . logger . info ( \"[ {} ]: received INFORM from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) if \"thermometer_data\" in msg . info . keys (): thermometer_data = msg . info [ \"thermometer_data\" ] self . context . logger . info ( \"[ {} ]: received the following thermometer data= {} \" . format ( self . context . agent_name , pprint . pformat ( thermometer_data ) ) ) dialogues = cast ( Dialogues , self . context . dialogues ) dialogues . dialogue_stats . add_dialogue_endstate ( Dialogue . EndState . SUCCESSFUL , dialogue . is_self_initiated ) else : self . context . logger . info ( \"[ {} ]: received no data from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) The main difference between this handler and the my_aea handler is that in this one we create more than one handler. The reason is that we receive messages not only from the seller_aea but also from the decision_maker and the OEF search node . So we need a handler to be able to read different kinds of messages. To handle the OEF search node response on our search request adds the following code in the same file : class OEFHandler ( Handler ): \"\"\"This class scaffolds a handler.\"\"\" SUPPORTED_PROTOCOL = OefSearchMessage . protocol_id # type: Optional[ProtocolId] def setup ( self ) -> None : \"\"\"Call to setup the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" # convenience representations oef_msg = cast ( OefSearchMessage , message ) if oef_msg . type is OefSearchMessage . Performative . SEARCH_RESULT : agents = oef_msg . agents self . _handle_search ( agents ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass def _handle_search ( self , agents : List [ str ]) -> None : \"\"\" Handle the search response. :param agents: the agents returned by the search :return: None \"\"\" if len ( agents ) > 0 : self . context . logger . info ( \"[ {} ]: found agents= {} , stopping search.\" . format ( self . context . agent_name , list ( map ( lambda x : x [ - 5 :], agents )) ) ) strategy = cast ( Strategy , self . context . strategy ) # stopping search strategy . is_searching = False # pick first agent found opponent_addr = agents [ 0 ] dialogues = cast ( Dialogues , self . context . dialogues ) dialogue = dialogues . create_self_initiated ( opponent_addr , self . context . agent_address , is_seller = False ) query = strategy . get_service_query () self . context . logger . info ( \"[ {} ]: sending CFP to agent= {} \" . format ( self . context . agent_name , opponent_addr [ - 5 :] ) ) cfp_msg = FipaMessage ( message_id = FipaMessage . STARTING_MESSAGE_ID , dialogue_reference = dialogue . dialogue_label . dialogue_reference , performative = FipaMessage . Performative . CFP , target = FipaMessage . STARTING_TARGET , query = query , ) dialogue . outgoing_extend ( cfp_msg ) self . context . outbox . put_message ( to = opponent_addr , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( cfp_msg ), ) else : self . context . logger . info ( \"[ {} ]: found no agents, continue searching.\" . format ( self . context . agent_name ) ) When we receive a message from the oef of a type Search_Result, we are passing the details to the handle function. The latest calls the _handle_search function and passes as input to the agent list. There we are checking that the list contains some agents and we stop the search. We pick our first agent and we send a CFP message. The last handler we will need is the Transaction Handler. This one will handle the internal messages that we receive from the decision_maker. class MyTransactionHandler ( Handler ): \"\"\"Implement the transaction handler.\"\"\" SUPPORTED_PROTOCOL = TransactionMessage . protocol_id # type: Optional[ProtocolId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" tx_msg_response = cast ( TransactionMessage , message ) if ( tx_msg_response is not None and tx_msg_response . performative == TransactionMessage . Performative . SUCCESSFUL_SETTLEMENT ): self . context . logger . info ( \"[ {} ]: transaction was successful.\" . format ( self . context . agent_name ) ) json_data = { \"transaction_digest\" : tx_msg_response . tx_digest } info = cast ( Dict [ str , Any ], tx_msg_response . info ) dialogue_label = DialogueLabel . from_json ( cast ( Dict [ str , str ], info . get ( \"dialogue_label\" )) ) dialogues = cast ( Dialogues , self . context . dialogues ) dialogue = dialogues . dialogues [ dialogue_label ] fipa_msg = cast ( FipaMessage , dialogue . last_incoming_message ) new_message_id = fipa_msg . message_id + 1 new_target_id = fipa_msg . message_id counterparty_addr = dialogue . dialogue_label . dialogue_opponent_addr inform_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target_id , performative = FipaMessage . Performative . INFORM , info = json_data , ) dialogue . outgoing_extend ( inform_msg ) self . context . outbox . put_message ( to = counterparty_addr , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( inform_msg ), ) self . context . logger . info ( \"[ {} ]: informing counterparty= {} of transaction digest.\" . format ( self . context . agent_name , counterparty_addr [ - 5 :] ) ) else : self . context . logger . info ( \"[ {} ]: transaction was not successful.\" . format ( self . context . agent_name ) ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass Remember that we send a message to the decision-maker with a transaction proposal? Here we handle the response from the decision-maker. If the message is of type SUCCESFUL_SETTLEMENT, we generate the inform_msg for the seller_aea to inform him that we completed the transaction and transferred the funds to the address that he sent us and we pass the transaction digest so the other aea can verify the transaction. Otherwise, inform us that something went wrong and the transaction was not successful. Step4: Create the strategy We are going to create the strategy that we want our AEA to follow. Rename the my_model.py file to strategy.py and paste the following code: from typing import cast from aea.helpers.search.models import Constraint , ConstraintType , Description , Query from aea.skills.base import Model DEFAULT_COUNTRY = \"UK\" SEARCH_TERM = \"country\" DEFAULT_MAX_ROW_PRICE = 5 DEFAULT_MAX_TX_FEE = 50 DEFAULT_CURRENCY_PBK = \"FET\" DEFAULT_LEDGER_ID = \"fetchai\" DEFAULT_IS_LEDGER_TX = True class Strategy ( Model ): \"\"\"This class defines a strategy for the agent.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize the strategy of the agent. :return: None \"\"\" self . _country = kwargs . pop ( \"country\" , DEFAULT_COUNTRY ) self . _max_row_price = kwargs . pop ( \"max_row_price\" , DEFAULT_MAX_ROW_PRICE ) self . max_buyer_tx_fee = kwargs . pop ( \"max_tx_fee\" , DEFAULT_MAX_TX_FEE ) self . _currency_id = kwargs . pop ( \"currency_id\" , DEFAULT_CURRENCY_PBK ) self . _ledger_id = kwargs . pop ( \"ledger_id\" , DEFAULT_LEDGER_ID ) self . is_ledger_tx = kwargs . pop ( \"is_ledger_tx\" , DEFAULT_IS_LEDGER_TX ) super () . __init__ ( ** kwargs ) self . _search_id = 0 self . is_searching = True We initialize the strategy class. We are trying to read the strategy variables from the YAML file. If this is not possible we specified some default values. The following two functions are related to the oef search service, add them under the initialization of the class: def get_next_search_id ( self ) -> int : \"\"\" Get the next search id and set the search time. :return: the next search id \"\"\" self . _search_id += 1 return self . _search_id def get_service_query ( self ) -> Query : \"\"\" Get the service query of the agent. :return: the query \"\"\" query = Query ( [ Constraint ( SEARCH_TERM , ConstraintType ( \"==\" , self . _country ))], model = None ) return query The following code block checks if the proposal that we received is acceptable based on the strategy def is_acceptable_proposal ( self , proposal : Description ) -> bool : \"\"\" Check whether it is an acceptable proposal. :return: whether it is acceptable \"\"\" result = ( ( proposal . values [ \"price\" ] - proposal . values [ \"seller_tx_fee\" ] > 0 ) and ( proposal . values [ \"price\" ] <= self . _max_row_price ) and ( proposal . values [ \"currency_id\" ] == self . _currency_id ) and ( proposal . values [ \"ledger_id\" ] == self . _ledger_id ) ) return result The is_affordable_proposal checks if we can afford the transaction based on the funds we have in our wallets based on the ledger, we would like to transact with. def is_affordable_proposal ( self , proposal : Description ) -> bool : \"\"\" Check whether it is an affordable proposal. :return: whether it is affordable \"\"\" if self . is_ledger_tx : payable = proposal . values [ \"price\" ] + self . max_buyer_tx_fee ledger_id = proposal . values [ \"ledger_id\" ] address = cast ( str , self . context . agent_addresses . get ( ledger_id )) balance = self . context . ledger_apis . token_balance ( ledger_id , address ) result = balance >= payable else : result = True return result Step5: Create the dialogues When we are negotiating with other AEA we would like to keep track of these negotiations for various reasons. Create a new file and name it dialogues.py. Inside this file add the following code: from typing import Optional from aea.helpers.dialogue.base import DialogueLabel from aea.helpers.search.models import Description from aea.skills.base import Model from packages.fetchai.protocols.fipa.dialogues import FipaDialogue , FipaDialogues class Dialogue ( FipaDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" def __init__ ( self , dialogue_label : DialogueLabel , is_seller : bool ) -> None : \"\"\" Initialize a dialogue label. :param dialogue_label: the identifier of the dialogue :param is_seller: indicates whether the agent associated with the dialogue is a seller or buyer :return: None \"\"\" FipaDialogue . __init__ ( self , dialogue_label = dialogue_label , is_seller = is_seller ) self . proposal = None # type: Optional[Description] class Dialogues ( Model , FipaDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" Model . __init__ ( self , ** kwargs ) FipaDialogues . __init__ ( self ) The dialogues class stores dialogue with each client_aea in a list so we can have access to previous messages and enable us to identify possible communications problems between the seller_aea and the client_aea. Step6: Update the YAML files Since we made so many changes to our aea we have to update the skill.yaml and the aea-config.yaml to contain our newly created scripts and the details that will be used from the strategy. Firstly, we will update the skill.yaml. Make sure that your skill.yaml matches with the following code name : thermometer_client author : fetchai version : 0.1.0 license : Apache-2.0 fingerprint : \"\" description : \"The thermometer client skill implements the skill to purchase temperature data.\" behaviours : search : class_name : MySearchBehaviour args : search_interval : 5 handlers : fipa : class_name : FIPAHandler args : {} oef : class_name : OEFHandler args : {} transaction : class_name : MyTransactionHandler args : {} models : strategy : class_name : Strategy args : country : UK max_row_price : 4 max_tx_fee : 2000000 currency_id : 'FET' ledger_id : 'fetchai' is_ledger_tx : True dialogues : class_name : Dialogues args : {} protocols : [ 'fetchai/fipa:0.1.0' , 'fetchai/default:0.1.0' , 'fetchai/oef_search:0.1.0' ] ledgers : [ 'fetchai' ] We must pay attention to the models and the strategy\u2019s variables. Here we can change the price we would like to buy each reading or the currency we would like to transact with. The next file we have to update is the aea-config.yaml file. You can locate this file under your agent\u2019s folder. We are going to modify this file later on before we run the aea but for now, make sure it matches the following code : aea_version : 0.2.4 agent_name : m_client author : author connections : - fetchai/stub:0.1.0 default_connection : fetchai/stub:0.1.0 default_ledger : fetchai description : '' fingerprint : '' ledger_apis : {} license : Apache-2.0 logging_config : disable_existing_loggers : false version : 1 private_key_paths : {} protocols : - fetchai/default:0.1.0 registry_path : ../packages skills : - author/thermometer_client:0.1.0 - fetchai/error:0.1.0 version : 0.1.0 Important: Do not modify the aea_version. Also if you modified the author makes sure that you changed it for the skills too. For example, if you modify the author to my_author you will have to modify the skills section to : skills : - my_authos/thermometer:0.1.0 - fetchai/error:0.1.0 Run the AEAs Make sure that your thermometer sensor is connected to the Raspberry's usb port. You can change the end point's address and port by modifying the connection's yaml file (my_aea/connection/oef/connection.yaml) Under config locate : addr : ${OEF_ADDR : 127.0.0.1} and replace it with your ip (The ip of the machine that runs the oef image.) In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Fetch.ai ledger payment Create the private key for the weather client AEA. aea generate-key fetchai aea add-key fetchai fet_private_key.txt Update the AEA configs Both in my_aea/aea-config.yaml and my_client/aea-config.yaml , replace ledger_apis : {} with the following. ledger_apis : fetchai : network : testnet Fund the temperature client AEA Create some wealth for your weather client on the Fetch.ai testnet. (It takes a while). aea generate-wealth fetchai Run both AEAs from their respective terminals aea add connection fetchai/oef:0.1.0 aea install aea run --connections fetchai/oef:0.1.0 You will see that the AEAs negotiate and then transact using the Fetch.ai testnet. Ethereum ledger payment A demo to run the same scenario but with a true ledger transaction on the Ethereum Ropsten testnet. This demo assumes the temperature client trusts our AEA to send the temperature data upon successful payment. Create the private key for the thermometer client AEA. aea generate-key ethereum aea add-key ethereum eth_private_key.txt Update the AEA configs Both in my_aea/aea-config.yaml and my_client/aea-config.yaml , replace ledger_apis: {} with the following. ledger_apis : ethereum : address : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 gas_price : 50 Update the skill configs In the thermometer skill config (my_aea/skills/thermometer/skill.yaml) under strategy, amend the currency_id and ledger_id as follows. currency_id : 'ETH' ledger_id : 'ethereum' is_ledger_tx : True In the temprature_client skill config (my_client/skills/temprature_client/skill.yaml) under strategy change the currency_id and ledger_id. max_buyer_tx_fee : 20000 currency_id : 'ETH' ledger_id : 'ethereum' is_ledger_tx : True Fund the thermometer client AEA Create some wealth for your weather client on the Ethereum Ropsten test net. Go to the MetaMask Faucet and request some test ETH for the account your weather client AEA is using (you need to first load your AEAs private key into MetaMask). Your private key is at my_client/eth_private_key.txt . Run both AEAs from their respective terminals. aea add connection fetchai/oef:0.1.0 aea install aea run --connections fetchai/oef:0.1.0 You will see that the AEAs negotiate and then transact using the Ethereum testnet. Delete the AEAs When you're done, go up a level and delete the AEAs. cd .. aea delete my_weather_station aea delete my_weather_client","title":"Thermometer skills step by step"},{"location":"aea/thermometer-skills-step-by-step/#planning-the-aea","text":"To follow this tutorial to completion you will need: - Raspberry Pi 4 Mini SD card Thermometer sensor AEA Framework The AEA will \u201clive\u201d inside the Raspberry Pi and will read the data from a sensor. Then it will connect to the OEF search and communication node and will identify itself as a seller of that data. Throughout the tutorial we are using Python3.7, but you can use any Python >= 3.6.","title":"Planning the AEA"},{"location":"aea/thermometer-skills-step-by-step/#setup-the-environment","text":"You can follow this link here in order to setup your environment and prepare your raspberry. Once you setup your raspberry Open a terminal and navigate to /etc/udev/rules.d/ . Create a new file there (I named mine 99-hidraw-permissions.rules) sudo nano 99 -hidraw-permissions.rules and add the following inside the file: KERNEL == \"hidraw*\" , SUBSYSTEM == \"hidraw\" , MODE = \"0664\" , GROUP = \"plugdev\" this assigns all devices coming out of the hidraw subsystem in the kernel to the group plugdev and sets the permissions to r/w r/w r (for root [the default owner], plugdev, and everyone else respectively)","title":"Setup the environment"},{"location":"aea/thermometer-skills-step-by-step/#step1-create-the-thermometer_aea","text":"Create a new AEA by typing the following command in the terminal: aea create my_aea cd my_aea Our newly created AEA is inside the current working directory. Let\u2019s create our new skill that will handle the data type the following command: aea scaffold skill thermometer This command will create the correct structure for a new skill inside our AEA project You can locate the newly created skill inside the skills folder and it must contain the following files: - behaviours.py - handlers.py - my_model.py - skills.yaml - tasks.py - __init__.py","title":"Step1: Create the thermometer_AEA"},{"location":"aea/thermometer-skills-step-by-step/#step2-create-the-behaviour","text":"A Behaviour class contains the business logic specific to initial actions initiated by the AEA rather than reactions to other events. Open the behaviours.py (my_aea/skills/thermometer/behaviours.py) and add the following code from typing import Optional , cast from aea.crypto.ethereum import ETHEREUM from aea.crypto.fetchai import FETCHAI from aea.helpers.search.models import Description from aea.skills.behaviours import TickerBehaviour from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.protocols.oef_search.serialization import OefSearchSerializer from packages.fetchai.skills.thermometer.strategy import Strategy DEFAULT_SERVICES_INTERVAL = 30.0 class ServiceRegistrationBehaviour ( TickerBehaviour ): \"\"\"This class implements a behaviour.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialise the behaviour.\"\"\" services_interval = kwargs . pop ( \"services_interval\" , DEFAULT_SERVICES_INTERVAL ) # type: int super () . __init__ ( tick_interval = services_interval , ** kwargs ) self . _registered_service_description = None # type: Optional[Description] def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" if self . context . ledger_apis . has_fetchai : fet_balance = self . context . ledger_apis . token_balance ( FETCHAI , cast ( str , self . context . agent_addresses . get ( FETCHAI )) ) if fet_balance > 0 : self . context . logger . info ( \"[ {} ]: starting balance on fetchai ledger= {} .\" . format ( self . context . agent_name , fet_balance ) ) else : self . context . logger . warning ( \"[ {} ]: you have no starting balance on fetchai ledger!\" . format ( self . context . agent_name ) ) if self . context . ledger_apis . has_ethereum : eth_balance = self . context . ledger_apis . token_balance ( ETHEREUM , cast ( str , self . context . agent_addresses . get ( ETHEREUM )) ) if eth_balance > 0 : self . context . logger . info ( \"[ {} ]: starting balance on ethereum ledger= {} .\" . format ( self . context . agent_name , eth_balance ) ) else : self . context . logger . warning ( \"[ {} ]: you have no starting balance on ethereum ledger!\" . format ( self . context . agent_name ) ) self . _register_service () def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" self . _unregister_service () self . _register_service () def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" if self . context . ledger_apis . has_fetchai : balance = self . context . ledger_apis . token_balance ( FETCHAI , cast ( str , self . context . agent_addresses . get ( FETCHAI )) ) self . context . logger . info ( \"[ {} ]: ending balance on fetchai ledger= {} .\" . format ( self . context . agent_name , balance ) ) if self . context . ledger_apis . has_ethereum : balance = self . context . ledger_apis . token_balance ( ETHEREUM , cast ( str , self . context . agent_addresses . get ( ETHEREUM )) ) self . context . logger . info ( \"[ {} ]: ending balance on ethereum ledger= {} .\" . format ( self . context . agent_name , balance ) ) self . _unregister_service () def _register_service ( self ) -> None : \"\"\" Register to the OEF search node's service directory. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) desc = strategy . get_service_description () self . _registered_service_description = desc oef_msg_id = strategy . get_next_oef_msg_id () msg = OefSearchMessage ( performative = OefSearchMessage . Performative . REGISTER_SERVICE , dialogue_reference = ( str ( oef_msg_id ), \"\" ), service_description = desc , ) self . context . outbox . put_message ( to = self . context . search_service_address , sender = self . context . agent_address , protocol_id = OefSearchMessage . protocol_id , message = OefSearchSerializer () . encode ( msg ), ) self . context . logger . info ( \"[ {} ]: updating thermometer services on OEF search node's service directory.\" . format ( self . context . agent_name ) ) def _unregister_service ( self ) -> None : \"\"\" Unregister service from OEF search node's service directory. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) oef_msg_id = strategy . get_next_oef_msg_id () msg = OefSearchMessage ( performative = OefSearchMessage . Performative . UNREGISTER_SERVICE , dialogue_reference = ( str ( oef_msg_id ), \"\" ), service_description = self . _registered_service_description , ) self . context . outbox . put_message ( to = self . context . search_service_address , sender = self . context . agent_address , protocol_id = OefSearchMessage . protocol_id , message = OefSearchSerializer () . encode ( msg ), ) self . context . logger . info ( \"[ {} ]: unregistering thermometer station services from OEF search node's service directory.\" . format ( self . context . agent_name ) ) self . _registered_service_description = None This Behaviour will register and de-register our AEA\u2019s service on the OEF search node at regular tick intervals. By registering, the AEA becomes discoverable to possible clients. Currently, the AEA-framework supports two different blockchains [Ethereum, Fetchai], and that\u2019s the reason we are checking if we have balance for these two blockchains in the setup method. The act method unregisters and registers the AEA to the OEF search node on each tick. Finally, the teardown method unregisters the AEA and reports your balances.","title":"Step2: Create the behaviour"},{"location":"aea/thermometer-skills-step-by-step/#step3-create-the-handler","text":"So far, we have tasked the AEA with sending register/unregister requests to the OEF search node . However, we have no way of handling the responses sent to the AEA by the OEF search node or any other AEA at the moment. This script contains the logic to negotiate with another AEA based on the strategy we want our AEA to follow. (we are going to write this next) . It is important to understand the way a negotiation happens between two AEAs. The following diagram illustrates the negotiation flow, up to the agreement between a seller_AEA and a client_AEA. sequenceDiagram participant Search participant Client_AEA participant Seller_AEA participant Blockchain activate Client_AEA activate Search activate Seller_AEA activate Blockchain Seller_AEA->>Search: register_service Client_AEA->>Search: search Search-->>Client_AEA: list_of_agents Client_AEA->>Seller_AEA: call_for_proposal Seller_AEA->>Client_AEA: propose Client_AEA->>Seller_AEA: accept Seller_AEA->>Client_AEA: match_accept Client_AEA->>Blockchain: transfer_funds Client_AEA->>Seller_AEA: send_transaction_hash Seller_AEA->>Blockchain: check_transaction_status Seller_AEA->>Client_AEA: send_data deactivate Client_AEA deactivate Search deactivate Seller_AEA deactivate Blockchain Let us now implement a handler to deal with the incoming responses. Open the handlers.py (my_aea/skills/thermometer/handlers.py) and add the following code: from typing import Optional , cast from aea.configurations.base import ProtocolId from aea.helpers.search.models import Description , Query from aea.protocols.base import Message from aea.protocols.default.message import DefaultMessage from aea.protocols.default.serialization import DefaultSerializer from aea.skills.base import Handler from packages.fetchai.protocols.fipa.message import FipaMessage from packages.fetchai.protocols.fipa.serialization import FipaSerializer from packages.fetchai.skills.thermometer.dialogues import Dialogue , Dialogues from packages.fetchai.skills.thermometer.strategy import Strategy class FIPAHandler ( Handler ): \"\"\"This class scaffolds a handler.\"\"\" SUPPORTED_PROTOCOL = FipaMessage . protocol_id # type: Optional[ProtocolId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" # convenience representations fipa_msg = cast ( FipaMessage , message ) dialogue_reference = fipa_msg . dialogue_reference # recover dialogue dialogues = cast ( Dialogues , self . context . dialogues ) if dialogues . is_belonging_to_registered_dialogue ( fipa_msg , self . context . agent_address ): dialogue = cast ( Dialogue , dialogues . get_dialogue ( fipa_msg , self . context . agent_address ) ) dialogue . incoming_extend ( fipa_msg ) elif dialogues . is_permitted_for_new_dialogue ( fipa_msg ): dialogue = cast ( Dialogue , dialogues . create_opponent_initiated ( message . counterparty , dialogue_reference = dialogue_reference , is_seller = True , ), ) dialogue . incoming_extend ( fipa_msg ) else : self . _handle_unidentified_dialogue ( fipa_msg ) return # handle message if fipa_msg . performative == FipaMessage . Performative . CFP : self . _handle_cfp ( fipa_msg , dialogue ) elif fipa_msg . performative == FipaMessage . Performative . DECLINE : self . _handle_decline ( fipa_msg , dialogue ) elif fipa_msg . performative == FipaMessage . Performative . ACCEPT : self . _handle_accept ( fipa_msg , dialogue ) elif fipa_msg . performative == FipaMessage . Performative . INFORM : self . _handle_inform ( fipa_msg , dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass The code above is logic for handling messages and storing the dialogues between the seller_aea and the client_aea. We are checking if the dialogue is registered to an existing one or we have to create a new dialogue. The second part checks what kind of message we received. We are going to implement each case in a different function. Under the teardown function add the following code: def _handle_unidentified_dialogue ( self , msg : FipaMessage ) -> None : \"\"\" Handle an unidentified dialogue. Respond to the sender with a default message containing the appropriate error information. :param msg: the message :return: None \"\"\" self . context . logger . info ( \"[ {} ]: unidentified dialogue.\" . format ( self . context . agent_name )) default_msg = DefaultMessage ( performative = DefaultMessage . Performative . ERROR , error_code = DefaultMessage . ErrorCode . INVALID_DIALOGUE . value , error_msg = \"Invalid dialogue.\" , error_data = \"fipa_message\" , ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = DefaultMessage . protocol_id , message = DefaultSerializer () . encode ( default_msg ), ) The above code handles an unidentified dialogue by responding to the sender with a default message containing the appropriate error information. The next code block handles the CFP message, paste the code under the _handle_unidentified_dialogue function : def _handle_cfp ( self , msg : FipaMessage , dialogue : Dialogue ) -> None : \"\"\" Handle the CFP. If the CFP matches the supplied services then send a PROPOSE, otherwise send a DECLINE. :param msg: the message :param dialogue: the dialogue object :return: None \"\"\" new_message_id = msg . message_id + 1 new_target = msg . message_id self . context . logger . info ( \"[ {} ]: received CFP from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) query = cast ( Query , msg . query ) strategy = cast ( Strategy , self . context . strategy ) if strategy . is_matching_supply ( query ): proposal , temp_data = strategy . generate_proposal_and_data ( query , msg . counterparty ) dialogue . temp_data = temp_data dialogue . proposal = proposal self . context . logger . info ( \"[ {} ]: sending sender= {} a PROPOSE with proposal= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :], proposal . values ) ) proposal_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target , performative = FipaMessage . Performative . PROPOSE , proposal = [ proposal ], ) dialogue . outgoing_extend ( proposal_msg ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( proposal_msg ), ) else : self . context . logger . info ( \"[ {} ]: declined the CFP from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) decline_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target , performative = FipaMessage . Performative . DECLINE , ) dialogue . outgoing_extend ( decline_msg ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( decline_msg ), ) The above code will respond with a proposal to the client if the CFP matches the supplied services and our strategy otherwise it will respond with a Decline message. The next code-block handles the decline message we receive from the client. Add the following code under the _handle_cfp function: def _handle_decline ( self , msg : FipaMessage , dialogue : Dialogue ) -> None : \"\"\" Handle the DECLINE. Close the dialogue. :param msg: the message :param dialogue: the dialogue object :return: None \"\"\" self . context . logger . info ( \"[ {} ]: received DECLINE from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) dialogues = cast ( Dialogues , self . context . dialogues ) dialogues . dialogue_stats . add_dialogue_endstate ( Dialogue . EndState . DECLINED_PROPOSE , dialogue . is_self_initiated ) If we receive a decline message from the client we have to close the dialogue and terminate the conversation with the client_aea. The opposite would be to receive an accept message. Inorder to handle this option add the following code under the _handle_decline function: def _handle_accept ( self , msg : FipaMessage , dialogue : Dialogue ) -> None : \"\"\" Handle the ACCEPT. Respond with a MATCH_ACCEPT_W_INFORM which contains the address to send the funds to. :param msg: the message :param dialogue: the dialogue object :return: None \"\"\" new_message_id = msg . message_id + 1 new_target = msg . message_id self . context . logger . info ( \"[ {} ]: received ACCEPT from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) self . context . logger . info ( \"[ {} ]: sending MATCH_ACCEPT_W_INFORM to sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) proposal = cast ( Description , dialogue . proposal ) identifier = cast ( str , proposal . values . get ( \"ledger_id\" )) match_accept_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target , performative = FipaMessage . Performative . MATCH_ACCEPT_W_INFORM , info = { \"address\" : self . context . agent_addresses [ identifier ]}, ) dialogue . outgoing_extend ( match_accept_msg ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( match_accept_msg ), ) When the client_aea accepts the proposal we send him, we also have to respond with another message (MATCH_ACCEPT_W_INFORM ) to inform the client about the address we would like to send the funds to. Lastly, when we receive the \u201cinform\u201d message means that the client sends the funds to the specific address. Add the following code : def _handle_inform ( self , msg : FipaMessage , dialogue : Dialogue ) -> None : \"\"\" Handle the INFORM. If the INFORM message contains the transaction_digest then verify that it is settled, otherwise do nothing. If the transaction is settled send the temperature data, otherwise do nothing. :param msg: the message :param dialogue: the dialogue object :return: None \"\"\" new_message_id = msg . message_id + 1 new_target = msg . message_id logger . info ( \"[ {} ]: received INFORM from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) strategy = cast ( Strategy , self . context . strategy ) if strategy . is_ledger_tx and ( \"transaction_digest\" in msg . info . keys ()): tx_digest = msg . info [ \"transaction_digest\" ] self . context . logger . info ( \"[ {} ]: checking whether transaction= {} has been received ...\" . format ( self . context . agent_name , tx_digest ) ) proposal = cast ( Description , dialogue . proposal ) ledger_id = cast ( str , proposal . values . get ( \"ledger_id\" )) is_valid = self . context . ledger_apis . is_tx_valid ( ledger_id , tx_digest , self . context . agent_addresses [ ledger_id ], msg . counterparty , cast ( str , proposal . values . get ( \"tx_nonce\" )), cast ( int , proposal . values . get ( \"price\" )), ) if is_valid : token_balance = self . context . ledger_apis . token_balance ( ledger_id , cast ( str , self . context . agent_addresses . get ( ledger_id )) ) self . context . logger . info ( \"[ {} ]: transaction= {} settled, new balance= {} . Sending data to sender= {} \" . format ( self . context . agent_name , tx_digest , token_balance , msg . counterparty [ - 5 :], ) ) inform_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target , performative = FipaMessage . Performative . INFORM , info = dialogue . temp_data , ) dialogue . outgoing_extend ( inform_msg ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( inform_msg ), ) dialogues = cast ( Dialogues , self . context . dialogues ) dialogues . dialogue_stats . add_dialogue_endstate ( Dialogue . EndState . SUCCESSFUL , dialogue . is_self_initiated ) else : self . context . logger . info ( \"[ {} ]: transaction= {} not settled, aborting\" . format ( self . context . agent_name , tx_digest ) ) elif \"Done\" in msg . info . keys (): inform_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target , performative = FipaMessage . Performative . INFORM , info = dialogue . temp_data , ) dialogue . outgoing_extend ( inform_msg ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( inform_msg ), ) dialogues = cast ( Dialogues , self . context . dialogues ) dialogues . dialogue_stats . add_dialogue_endstate ( Dialogue . EndState . SUCCESSFUL , dialogue . is_self_initiated ) else : self . context . logger . warning ( \"[ {} ]: did not receive transaction digest from sender= {} .\" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) We are checking the inform message. If it contains the transaction digest we verify that transaction matches the proposal that the client accepted. If the transaction is valid and we received the funds then we send the data to the client. Otherwise we don\u2019t do anything.","title":"Step3: Create the handler"},{"location":"aea/thermometer-skills-step-by-step/#step4-create-the-strategy","text":"We are going to create the strategy that we want our AEA to follow. Rename the my_model.py file to strategy.py and paste the following code: from random import randrange from typing import Any , Dict , Tuple from temper import Temper from aea.helpers.search.models import Description , Query from aea.mail.base import Address from aea.skills.base import Model from packages.fetchai.skills.thermometer.thermometer_data_model import ( SCHEME , THERMOMETER_DATAMODEL , ) DEFAULT_PRICE_PER_ROW = 1 DEFAULT_SELLER_TX_FEE = 0 DEFAULT_CURRENCY_PBK = \"FET\" DEFAULT_LEDGER_ID = \"fetchai\" DEFAULT_IS_LEDGER_TX = True DEFAULT_HAS_SENSOR = True class Strategy ( Model ): \"\"\"This class defines a strategy for the agent.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize the strategy of the agent. :param register_as: determines whether the agent registers as seller, buyer or both :param search_for: determines whether the agent searches for sellers, buyers or both :return: None \"\"\" self . _price_per_row = kwargs . pop ( \"price_per_row\" , DEFAULT_PRICE_PER_ROW ) self . _seller_tx_fee = kwargs . pop ( \"seller_tx_fee\" , DEFAULT_SELLER_TX_FEE ) self . _currency_id = kwargs . pop ( \"currency_id\" , DEFAULT_CURRENCY_PBK ) self . _ledger_id = kwargs . pop ( \"ledger_id\" , DEFAULT_LEDGER_ID ) self . is_ledger_tx = kwargs . pop ( \"is_ledger_tx\" , DEFAULT_IS_LEDGER_TX ) self . _has_sensor = kwargs . pop ( \"has_sensor\" , DEFAULT_HAS_SENSOR ) super () . __init__ ( ** kwargs ) self . _oef_msg_id = 0 We initialise the strategy class. We are trying to read the strategy variables from the yaml file. If this is not possible we specified some default values. The following three functions are related with the oef registration and we assume that the query matches the supply, add them under the initialization of the class: def get_next_oef_msg_id ( self ) -> int : \"\"\" Get the next oef msg id. :return: the next oef msg id \"\"\" self . _oef_msg_id += 1 return self . _oef_msg_id def get_service_description ( self ) -> Description : \"\"\" Get the service description. :return: a description of the offered services \"\"\" desc = Description ( SCHEME , data_model = THERMOMETER_DATAMODEL ()) return desc def is_matching_supply ( self , query : Query ) -> bool : \"\"\" Check if the query matches the supply. :param query: the query :return: bool indicating whether matches or not \"\"\" # TODO, this is a stub return True Lastly, we are going to create the function that generates the proposal that we will send to the aea_client: def generate_proposal_and_data ( self , query : Query , counterparty : Address ) -> Tuple [ Description , Dict [ str , Any ]]: \"\"\" Generate a proposal matching the query. :param counterparty: the counterparty of the proposal. :param query: the query :return: a tuple of proposal and the temperature data \"\"\" tx_nonce = self . context . ledger_apis . generate_tx_nonce ( identifier = self . _ledger_id , seller = self . context . agent_addresses [ self . _ledger_id ], client = counterparty , ) temp_data = self . _build_data_payload () total_price = self . _price_per_row assert ( total_price - self . _seller_tx_fee > 0 ), \"This sale would generate a loss, change the configs!\" proposal = Description ( { \"price\" : total_price , \"seller_tx_fee\" : self . _seller_tx_fee , \"currency_id\" : self . _currency_id , \"ledger_id\" : self . _ledger_id , \"tx_nonce\" : tx_nonce , } ) return proposal , temp_data def _build_data_payload ( self ) -> Dict [ str , Any ]: \"\"\" Build the data payload. :return: a tuple of the data and the rows \"\"\" if self . _has_sensor : temper = Temper () while True : results = temper . read () if \"internal temperature\" in results . keys (): degrees = { \"thermometer_data\" : results } else : self . context . logger . debug ( \"Couldn't read the sensor I am re-trying.\" ) else : degrees = { \"thermometer_data\" : randrange ( 10 , 25 )} self . context . logger . info ( degrees ) return degrees Before the creation of the actual proposal, we have to check if this sale generates value for us or a loss. If it is a loss, we ask the user to change the configurations. The helper private function _build_data_payload, is where we read data from our sensor or in case we don\u2019t have a sensor generate a random number.","title":"Step4: Create the strategy"},{"location":"aea/thermometer-skills-step-by-step/#step5-create-the-dialogues","text":"When we are negotiating with other AEA we would like to keep track on these negotiations for various reasons. So create a new file and name it dialogues.py. Inside this file add the following code: from typing import Any , Dict , Optional from aea.helpers.dialogue.base import DialogueLabel from aea.helpers.search.models import Description from aea.skills.base import Model from packages.fetchai.protocols.fipa.dialogues import FipaDialogue , FipaDialogues class Dialogue ( FipaDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" def __init__ ( self , dialogue_label : DialogueLabel , is_seller : bool ) -> None : \"\"\" Initialize a dialogue label. :param dialogue_label: the identifier of the dialogue :param is_seller: indicates whether the agent associated with the dialogue is a seller or buyer :return: None \"\"\" FipaDialogue . __init__ ( self , dialogue_label = dialogue_label , is_seller = is_seller ) self . temp_data = None # type: Optional[Dict[str, Any]] self . proposal = None # type: Optional[Description] class Dialogues ( Model , FipaDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" Model . __init__ ( self , ** kwargs ) FipaDialogues . __init__ ( self ) The dialogues class stores dialogue with each client_aea in a list so we can have access to previous messages and enable us to identify possible communications problems between the seller_aea and the client_aea. Also contains the data that we fetch during the proposal phase.","title":"Step5: Create the dialogues"},{"location":"aea/thermometer-skills-step-by-step/#step6-create-the-data_model","text":"Each AEA in the oef needs a Description in order to be able to register as a service.The data model will help us create this description. Create a new file and call it thermometer_data_model.py and paste the following code: from aea.helpers.search.models import Attribute , DataModel SCHEME = { \"country\" : \"UK\" , \"city\" : \"Cambridge\" } class Thermometer_Datamodel ( DataModel ): \"\"\"Data model for the thermo Agent.\"\"\" def __init__ ( self ): \"\"\"Initialise the dataModel.\"\"\" self . attribute_country = Attribute ( \"country\" , str , True ) self . attribute_city = Attribute ( \"city\" , str , True ) super () . __init__ ( \"thermometer_datamodel\" , [ self . attribute_country , self . attribute_city ] ) This data model registers to the OEF search node as an AEA that is in the UK and specifically in Cambridge. If a client_AEA searches for AEA in the UK the oef will respond with the address of our AEA.","title":"Step6: Create the data_model"},{"location":"aea/thermometer-skills-step-by-step/#step7-update-the-yaml-files","text":"Since we made so many changes to our AEA we have to update the skill.yaml and the aea-config.yaml to contain our newly created scripts and the details that will be used from the strategy. Firstly, we will update the skill.yaml. Make sure that your skill.yaml matches with the following code name : thermometer author : fetchai version : 0.1.0 license : Apache-2.0 fingerprint : \"\" description : \"The thermometer skill implements the functionality to sell data.\" behaviours : service_registration : class_name : ServiceRegistrationBehaviour args : services_interval : 60 handlers : fipa : class_name : FIPAHandler args : {} models : strategy : class_name : Strategy args : price : 1 seller_tx_fee : 0 currency_id : 'FET' ledger_id : 'fetchai' has_sensor : True is_ledger_tx : True dialogues : class_name : Dialogues args : {} protocols : [ 'fetchai/fipa:0.1.0' , 'fetchai/oef_search:0.1.0' , 'fetchai/default:0.1.0' ] ledgers : [ 'fetchai' ] dependencies : pyserial : {} temper-py : {} We must pay attention to the models and the strategy\u2019s variables. Here we can change the price we would like to sell each reading or the currency we would like to transact with. Lastly,the dependencies are the third party packages we need to install in order to get readings from the sensor. The next file we have to update is the aea-config.yaml file. You can locate this file under your AEA\u2019s folder. We are going to modify this file later on before we run the aea but for now make sure it matches the following code : aea_version: 0.2.4 agent_name: my_aea author: author connections: - fetchai/oef:0.1.0 - fetchai/stub:0.1.0 default_connection: fetchai/stub:0.1.0 default_ledger: fetchai description: '' fingerprint: '' ledger_apis: {} license: Apache-2.0 logging_config: disable_existing_loggers: false version: 1 private_key_paths: {} protocols: - fetchai/default:0.1.0 registry_path: ../packages skills: - author/thermometer:0.1.0 - fetchai/error:0.1.0 version: 0.1.0","title":"Step7: Update the YAML files"},{"location":"aea/thermometer-skills-step-by-step/#step1-create-the-client_aea","text":"Create a new AEA by typing the following command in the terminal: aea create my_client cd my_client Our newly created AEA is inside the current working directory. Let\u2019s create our new skill that will handle the data type the following command: aea scaffold skill thermometer_client This command will create the correct structure for a new skill inside our AEA project You can locate the newly created skill inside the skills folder and it must contain the following files: - behaviours.py - handlers.py - my_model.py - skills.yaml - tasks.py - __init__.py","title":"Step1: Create the Client_AEA"},{"location":"aea/thermometer-skills-step-by-step/#step2-create-the-behaviour_1","text":"A Behaviour class contains the business logic specific to initial actions initiated by the AEA rather than reactions to other events. Open the behaviours.py (my_client/skills/thermometer_client/behaviours.py) and add the following code: from typing import cast from aea.crypto.ethereum import ETHEREUM from aea.crypto.fetchai import FETCHAI from aea.skills.behaviours import TickerBehaviour from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.protocols.oef_search.serialization import OefSearchSerializer from packages.fetchai.skills.thermometer_client.strategy import Strategy DEFAULT_SEARCH_INTERVAL = 5.0 class MySearchBehaviour ( TickerBehaviour ): \"\"\"This class implements a search behaviour.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialize the search behaviour.\"\"\" search_interval = cast ( float , kwargs . pop ( \"search_interval\" , DEFAULT_SEARCH_INTERVAL ) ) super () . __init__ ( tick_interval = search_interval , ** kwargs ) def setup ( self ) -> None : \"\"\"Implement the setup for the behaviour.\"\"\" if self . context . ledger_apis . has_fetchai : fet_balance = self . context . ledger_apis . token_balance ( FETCHAI , cast ( str , self . context . agent_addresses . get ( FETCHAI )) ) if fet_balance > 0 : self . context . logger . info ( \"[ {} ]: starting balance on fetchai ledger= {} .\" . format ( self . context . agent_name , fet_balance ) ) else : self . context . logger . warning ( \"[ {} ]: you have no starting balance on fetchai ledger!\" . format ( self . context . agent_name ) ) if self . context . ledger_apis . has_ethereum : eth_balance = self . context . ledger_apis . token_balance ( ETHEREUM , cast ( str , self . context . agent_addresses . get ( ETHEREUM )) ) if eth_balance > 0 : self . context . logger . info ( \"[ {} ]: starting balance on ethereum ledger= {} .\" . format ( self . context . agent_name , eth_balance ) ) else : self . context . logger . warning ( \"[ {} ]: you have no starting balance on ethereum ledger!\" . format ( self . context . agent_name ) ) def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) if strategy . is_searching : query = strategy . get_service_query () search_id = strategy . get_next_search_id () oef_msg = OefSearchMessage ( performative = OefSearchMessage . Performative . SEARCH_SERVICES , dialogue_reference = ( str ( search_id ), \"\" ), query = query ) self . context . outbox . put_message ( to = self . context . search_service_address , sender = self . context . agent_address , protocol_id = OefSearchMessage . protocol_id , message = OefSearchSerializer () . encode ( oef_msg ), ) def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" if self . context . ledger_apis . has_fetchai : balance = self . context . ledger_apis . token_balance ( FETCHAI , cast ( str , self . context . agent_addresses . get ( FETCHAI )) ) self . context . logger . info ( \"[ {} ]: ending balance on fetchai ledger= {} .\" . format ( self . context . agent_name , balance ) ) if self . context . ledger_apis . has_ethereum : balance = self . context . ledger_apis . token_balance ( ETHEREUM , cast ( str , self . context . agent_addresses . get ( ETHEREUM )) ) self . context . logger . info ( \"[ {} ]: ending balance on ethereum ledger= {} .\" . format ( self . context . agent_name , balance ) ) This Behaviour will register to the Search_Service of the oef with a specific query at regular tick intervals. By registering to the search service the OEF search node can respond with possible sellers that match our query.","title":"Step2: Create the behaviour"},{"location":"aea/thermometer-skills-step-by-step/#step3-create-the-handler_1","text":"So far, we have tasked the AEA with sending search queries to the OEF search node . However, we have no way of handling the responses sent to the AEA by the OEF search node or any other agent at the moment. This script contains the logic to negotiate with another AEA based on the strategy we want our AEA to follow (we are going to write this next) . import pprint from typing import Any , Dict , List , Optional , cast from aea.configurations.base import ProtocolId , PublicId from aea.decision_maker.messages.transaction import TransactionMessage from aea.helpers.dialogue.base import DialogueLabel from aea.helpers.search.models import Description from aea.protocols.base import Message from aea.protocols.default.message import DefaultMessage from aea.protocols.default.serialization import DefaultSerializer from aea.skills.base import Handler from packages.fetchai.protocols.fipa.message import FipaMessage from packages.fetchai.protocols.fipa.serialization import FipaSerializer from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.thermometer_client.dialogues import Dialogue , Dialogues from packages.fetchai.skills.thermometer_client.strategy import Strategy class FIPAHandler ( Handler ): \"\"\"This class scaffolds a handler.\"\"\" SUPPORTED_PROTOCOL = FipaMessage . protocol_id # type: Optional[ProtocolId] def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" # convenience representations fipa_msg = cast ( FipaMessage , message ) # recover dialogue dialogues = cast ( Dialogues , self . context . dialogues ) if dialogues . is_belonging_to_registered_dialogue ( fipa_msg , self . context . agent_address ): dialogue = cast ( Dialogue , dialogues . get_dialogue ( fipa_msg , self . context . agent_address ) ) dialogue . incoming_extend ( fipa_msg ) else : self . _handle_unidentified_dialogue ( fipa_msg ) return # handle message if fipa_msg . performative == FipaMessage . Performative . PROPOSE : self . _handle_propose ( fipa_msg , dialogue ) elif fipa_msg . performative == FipaMessage . Performative . DECLINE : self . _handle_decline ( fipa_msg , dialogue ) elif fipa_msg . performative == FipaMessage . Performative . MATCH_ACCEPT_W_INFORM : self . _handle_match_accept ( fipa_msg , dialogue ) elif fipa_msg . performative == FipaMessage . Performative . INFORM : self . _handle_inform ( fipa_msg , dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass You will see that we are following similar logic when we develop the client\u2019s side of the negotiation. The first thing is that we create a new dialogue and we store it in the dialogues class. Then we are checking what kind of message we received. So lets start creating our handlers: def _handle_unidentified_dialogue ( self , msg : FipaMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the message \"\"\" self . context . logger . info ( \"[ {} ]: unidentified dialogue.\" . format ( self . context . agent_name )) default_msg = DefaultMessage ( performative = DefaultMessage . Performative . ERROR , error_code = DefaultMessage . ErrorCode . INVALID_DIALOGUE . value , error_msg = \"Invalid dialogue.\" , error_data = \"fipa_message\" , ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = DefaultMessage . protocol_id , message = DefaultSerializer () . encode ( default_msg ), ) The above code handles the unidentified dialogues. And responds with an error message to the sender. Next we will handle the proposal that we receive from the seller_aea : def _handle_propose ( self , msg : FipaMessage , dialogue : Dialogue ) -> None : \"\"\" Handle the propose. :param msg: the message :param dialogue: the dialogue object :return: None \"\"\" new_message_id = msg . message_id + 1 new_target_id = msg . message_id proposals = msg . proposal if proposals is not []: # only take the first proposal proposal = proposals [ 0 ] self . context . logger . info ( \"[ {} ]: received proposal= {} from sender= {} \" . format ( self . context . agent_name , proposal . values , msg . counterparty [ - 5 :] ) ) strategy = cast ( Strategy , self . context . strategy ) acceptable = strategy . is_acceptable_proposal ( proposal ) affordable = strategy . is_affordable_proposal ( proposal ) if acceptable and affordable : strategy . is_searching = False self . context . logger . info ( \"[ {} ]: accepting the proposal from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) dialogue . proposal = proposal accept_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target_id , performative = FipaMessage . Performative . ACCEPT , ) dialogue . outgoing_extend ( accept_msg ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( accept_msg ), ) else : self . context . logger . info ( \"[ {} ]: declining the proposal from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) decline_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target_id , performative = FipaMessage . Performative . DECLINE , ) dialogue . outgoing_extend ( decline_msg ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( decline_msg ), ) When we receive a proposal we have to check if we have the funds to complete the transaction and if the proposal is acceptable based on our strategy. If the proposal is not affordable or acceptable we respond with a decline message. Otherwise, we send an accept message to the seller. The next code-block handles the decline message that we may receive from the client on our CFP message or our ACCEPT message: def _handle_decline ( self , msg : FipaMessage , dialogue : Dialogue ) -> None : \"\"\" Handle the decline. :param msg: the message :param dialogue: the dialogue object :return: None \"\"\" self . context . logger . info ( \"[ {} ]: received DECLINE from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) target = msg . get ( \"target\" ) dialogues = cast ( Dialogues , self . context . dialogues ) if target == 1 : dialogues . dialogue_stats . add_dialogue_endstate ( Dialogue . EndState . DECLINED_CFP , dialogue . is_self_initiated ) elif target == 3 : dialogues . dialogue_stats . add_dialogue_endstate ( Dialogue . EndState . DECLINED_ACCEPT , dialogue . is_self_initiated ) The above code terminates each dialogue with the specific aea and stores the step. For example, if the target == 1 we know that the seller declined our CFP message. In case you didn\u2019t receive any decline message that means that the seller_aea want to move on with the sale, in that case, it will send a match_accept message in order to handle this add the following code : def _handle_match_accept ( self , msg : FipaMessage , dialogue : Dialogue ) -> None : \"\"\" Handle the match accept. :param msg: the message :param dialogue: the dialogue object :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) if strategy . is_ledger_tx : self . context . logger . info ( \"[ {} ]: received MATCH_ACCEPT_W_INFORM from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) info = msg . info address = cast ( str , info . get ( \"address\" )) proposal = cast ( Description , dialogue . proposal ) tx_msg = TransactionMessage ( performative = TransactionMessage . Performative . PROPOSE_FOR_SETTLEMENT , skill_callback_ids = [ PublicId ( \"fetchai\" , \"thermometer_client\" , \"0.1.0\" )], tx_id = \"transaction0\" , tx_sender_addr = self . context . agent_addresses [ proposal . values [ \"ledger_id\" ] ], tx_counterparty_addr = address , tx_amount_by_currency_id = { proposal . values [ \"currency_id\" ]: - proposal . values [ \"price\" ] }, tx_sender_fee = strategy . max_buyer_tx_fee , tx_counterparty_fee = proposal . values [ \"seller_tx_fee\" ], tx_quantities_by_good_id = {}, ledger_id = proposal . values [ \"ledger_id\" ], info = { \"dialogue_label\" : dialogue . dialogue_label . json }, tx_nonce = proposal . values . get ( \"tx_nonce\" ), ) self . context . decision_maker_message_queue . put_nowait ( tx_msg ) self . context . logger . info ( \"[ {} ]: proposing the transaction to the decision maker. Waiting for confirmation ...\" . format ( self . context . agent_name ) ) else : new_message_id = msg . message_id + 1 new_target = msg . message_id inform_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target , performative = FipaMessage . Performative . INFORM , info = { \"Done\" : \"Sending payment via bank transfer\" }, ) dialogue . outgoing_extend ( inform_msg ) self . context . outbox . put_message ( to = msg . counterparty , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( inform_msg ), ) self . context . logger . info ( \"[ {} ]: informing counterparty= {} of payment.\" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) The first thing we are checking is if we enabled our aea to transact with a ledger. If we can transact with a ledger we generate a transaction message and we propose it to the decision_maker. The decision_maker then will check the transaction message if it is acceptable, we have the funds, etc, it signs and sends the transaction to the specified ledger. Then it returns us the transaction digest. Lastly, we need to handle the inform message because this is the message that will have our data: def _handle_inform ( self , msg : FipaMessage , dialogue : Dialogue ) -> None : \"\"\" Handle the match inform. :param msg: the message :param dialogue: the dialogue object :return: None \"\"\" self . context . logger . info ( \"[ {} ]: received INFORM from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) if \"thermometer_data\" in msg . info . keys (): thermometer_data = msg . info [ \"thermometer_data\" ] self . context . logger . info ( \"[ {} ]: received the following thermometer data= {} \" . format ( self . context . agent_name , pprint . pformat ( thermometer_data ) ) ) dialogues = cast ( Dialogues , self . context . dialogues ) dialogues . dialogue_stats . add_dialogue_endstate ( Dialogue . EndState . SUCCESSFUL , dialogue . is_self_initiated ) else : self . context . logger . info ( \"[ {} ]: received no data from sender= {} \" . format ( self . context . agent_name , msg . counterparty [ - 5 :] ) ) The main difference between this handler and the my_aea handler is that in this one we create more than one handler. The reason is that we receive messages not only from the seller_aea but also from the decision_maker and the OEF search node . So we need a handler to be able to read different kinds of messages. To handle the OEF search node response on our search request adds the following code in the same file : class OEFHandler ( Handler ): \"\"\"This class scaffolds a handler.\"\"\" SUPPORTED_PROTOCOL = OefSearchMessage . protocol_id # type: Optional[ProtocolId] def setup ( self ) -> None : \"\"\"Call to setup the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" # convenience representations oef_msg = cast ( OefSearchMessage , message ) if oef_msg . type is OefSearchMessage . Performative . SEARCH_RESULT : agents = oef_msg . agents self . _handle_search ( agents ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass def _handle_search ( self , agents : List [ str ]) -> None : \"\"\" Handle the search response. :param agents: the agents returned by the search :return: None \"\"\" if len ( agents ) > 0 : self . context . logger . info ( \"[ {} ]: found agents= {} , stopping search.\" . format ( self . context . agent_name , list ( map ( lambda x : x [ - 5 :], agents )) ) ) strategy = cast ( Strategy , self . context . strategy ) # stopping search strategy . is_searching = False # pick first agent found opponent_addr = agents [ 0 ] dialogues = cast ( Dialogues , self . context . dialogues ) dialogue = dialogues . create_self_initiated ( opponent_addr , self . context . agent_address , is_seller = False ) query = strategy . get_service_query () self . context . logger . info ( \"[ {} ]: sending CFP to agent= {} \" . format ( self . context . agent_name , opponent_addr [ - 5 :] ) ) cfp_msg = FipaMessage ( message_id = FipaMessage . STARTING_MESSAGE_ID , dialogue_reference = dialogue . dialogue_label . dialogue_reference , performative = FipaMessage . Performative . CFP , target = FipaMessage . STARTING_TARGET , query = query , ) dialogue . outgoing_extend ( cfp_msg ) self . context . outbox . put_message ( to = opponent_addr , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( cfp_msg ), ) else : self . context . logger . info ( \"[ {} ]: found no agents, continue searching.\" . format ( self . context . agent_name ) ) When we receive a message from the oef of a type Search_Result, we are passing the details to the handle function. The latest calls the _handle_search function and passes as input to the agent list. There we are checking that the list contains some agents and we stop the search. We pick our first agent and we send a CFP message. The last handler we will need is the Transaction Handler. This one will handle the internal messages that we receive from the decision_maker. class MyTransactionHandler ( Handler ): \"\"\"Implement the transaction handler.\"\"\" SUPPORTED_PROTOCOL = TransactionMessage . protocol_id # type: Optional[ProtocolId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" pass def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" tx_msg_response = cast ( TransactionMessage , message ) if ( tx_msg_response is not None and tx_msg_response . performative == TransactionMessage . Performative . SUCCESSFUL_SETTLEMENT ): self . context . logger . info ( \"[ {} ]: transaction was successful.\" . format ( self . context . agent_name ) ) json_data = { \"transaction_digest\" : tx_msg_response . tx_digest } info = cast ( Dict [ str , Any ], tx_msg_response . info ) dialogue_label = DialogueLabel . from_json ( cast ( Dict [ str , str ], info . get ( \"dialogue_label\" )) ) dialogues = cast ( Dialogues , self . context . dialogues ) dialogue = dialogues . dialogues [ dialogue_label ] fipa_msg = cast ( FipaMessage , dialogue . last_incoming_message ) new_message_id = fipa_msg . message_id + 1 new_target_id = fipa_msg . message_id counterparty_addr = dialogue . dialogue_label . dialogue_opponent_addr inform_msg = FipaMessage ( message_id = new_message_id , dialogue_reference = dialogue . dialogue_label . dialogue_reference , target = new_target_id , performative = FipaMessage . Performative . INFORM , info = json_data , ) dialogue . outgoing_extend ( inform_msg ) self . context . outbox . put_message ( to = counterparty_addr , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( inform_msg ), ) self . context . logger . info ( \"[ {} ]: informing counterparty= {} of transaction digest.\" . format ( self . context . agent_name , counterparty_addr [ - 5 :] ) ) else : self . context . logger . info ( \"[ {} ]: transaction was not successful.\" . format ( self . context . agent_name ) ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" pass Remember that we send a message to the decision-maker with a transaction proposal? Here we handle the response from the decision-maker. If the message is of type SUCCESFUL_SETTLEMENT, we generate the inform_msg for the seller_aea to inform him that we completed the transaction and transferred the funds to the address that he sent us and we pass the transaction digest so the other aea can verify the transaction. Otherwise, inform us that something went wrong and the transaction was not successful.","title":"Step3: Create the handler"},{"location":"aea/thermometer-skills-step-by-step/#step4-create-the-strategy_1","text":"We are going to create the strategy that we want our AEA to follow. Rename the my_model.py file to strategy.py and paste the following code: from typing import cast from aea.helpers.search.models import Constraint , ConstraintType , Description , Query from aea.skills.base import Model DEFAULT_COUNTRY = \"UK\" SEARCH_TERM = \"country\" DEFAULT_MAX_ROW_PRICE = 5 DEFAULT_MAX_TX_FEE = 50 DEFAULT_CURRENCY_PBK = \"FET\" DEFAULT_LEDGER_ID = \"fetchai\" DEFAULT_IS_LEDGER_TX = True class Strategy ( Model ): \"\"\"This class defines a strategy for the agent.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize the strategy of the agent. :return: None \"\"\" self . _country = kwargs . pop ( \"country\" , DEFAULT_COUNTRY ) self . _max_row_price = kwargs . pop ( \"max_row_price\" , DEFAULT_MAX_ROW_PRICE ) self . max_buyer_tx_fee = kwargs . pop ( \"max_tx_fee\" , DEFAULT_MAX_TX_FEE ) self . _currency_id = kwargs . pop ( \"currency_id\" , DEFAULT_CURRENCY_PBK ) self . _ledger_id = kwargs . pop ( \"ledger_id\" , DEFAULT_LEDGER_ID ) self . is_ledger_tx = kwargs . pop ( \"is_ledger_tx\" , DEFAULT_IS_LEDGER_TX ) super () . __init__ ( ** kwargs ) self . _search_id = 0 self . is_searching = True We initialize the strategy class. We are trying to read the strategy variables from the YAML file. If this is not possible we specified some default values. The following two functions are related to the oef search service, add them under the initialization of the class: def get_next_search_id ( self ) -> int : \"\"\" Get the next search id and set the search time. :return: the next search id \"\"\" self . _search_id += 1 return self . _search_id def get_service_query ( self ) -> Query : \"\"\" Get the service query of the agent. :return: the query \"\"\" query = Query ( [ Constraint ( SEARCH_TERM , ConstraintType ( \"==\" , self . _country ))], model = None ) return query The following code block checks if the proposal that we received is acceptable based on the strategy def is_acceptable_proposal ( self , proposal : Description ) -> bool : \"\"\" Check whether it is an acceptable proposal. :return: whether it is acceptable \"\"\" result = ( ( proposal . values [ \"price\" ] - proposal . values [ \"seller_tx_fee\" ] > 0 ) and ( proposal . values [ \"price\" ] <= self . _max_row_price ) and ( proposal . values [ \"currency_id\" ] == self . _currency_id ) and ( proposal . values [ \"ledger_id\" ] == self . _ledger_id ) ) return result The is_affordable_proposal checks if we can afford the transaction based on the funds we have in our wallets based on the ledger, we would like to transact with. def is_affordable_proposal ( self , proposal : Description ) -> bool : \"\"\" Check whether it is an affordable proposal. :return: whether it is affordable \"\"\" if self . is_ledger_tx : payable = proposal . values [ \"price\" ] + self . max_buyer_tx_fee ledger_id = proposal . values [ \"ledger_id\" ] address = cast ( str , self . context . agent_addresses . get ( ledger_id )) balance = self . context . ledger_apis . token_balance ( ledger_id , address ) result = balance >= payable else : result = True return result","title":"Step4: Create the strategy"},{"location":"aea/thermometer-skills-step-by-step/#step5-create-the-dialogues_1","text":"When we are negotiating with other AEA we would like to keep track of these negotiations for various reasons. Create a new file and name it dialogues.py. Inside this file add the following code: from typing import Optional from aea.helpers.dialogue.base import DialogueLabel from aea.helpers.search.models import Description from aea.skills.base import Model from packages.fetchai.protocols.fipa.dialogues import FipaDialogue , FipaDialogues class Dialogue ( FipaDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" def __init__ ( self , dialogue_label : DialogueLabel , is_seller : bool ) -> None : \"\"\" Initialize a dialogue label. :param dialogue_label: the identifier of the dialogue :param is_seller: indicates whether the agent associated with the dialogue is a seller or buyer :return: None \"\"\" FipaDialogue . __init__ ( self , dialogue_label = dialogue_label , is_seller = is_seller ) self . proposal = None # type: Optional[Description] class Dialogues ( Model , FipaDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" Model . __init__ ( self , ** kwargs ) FipaDialogues . __init__ ( self ) The dialogues class stores dialogue with each client_aea in a list so we can have access to previous messages and enable us to identify possible communications problems between the seller_aea and the client_aea.","title":"Step5: Create the dialogues"},{"location":"aea/thermometer-skills-step-by-step/#step6-update-the-yaml-files","text":"Since we made so many changes to our aea we have to update the skill.yaml and the aea-config.yaml to contain our newly created scripts and the details that will be used from the strategy. Firstly, we will update the skill.yaml. Make sure that your skill.yaml matches with the following code name : thermometer_client author : fetchai version : 0.1.0 license : Apache-2.0 fingerprint : \"\" description : \"The thermometer client skill implements the skill to purchase temperature data.\" behaviours : search : class_name : MySearchBehaviour args : search_interval : 5 handlers : fipa : class_name : FIPAHandler args : {} oef : class_name : OEFHandler args : {} transaction : class_name : MyTransactionHandler args : {} models : strategy : class_name : Strategy args : country : UK max_row_price : 4 max_tx_fee : 2000000 currency_id : 'FET' ledger_id : 'fetchai' is_ledger_tx : True dialogues : class_name : Dialogues args : {} protocols : [ 'fetchai/fipa:0.1.0' , 'fetchai/default:0.1.0' , 'fetchai/oef_search:0.1.0' ] ledgers : [ 'fetchai' ] We must pay attention to the models and the strategy\u2019s variables. Here we can change the price we would like to buy each reading or the currency we would like to transact with. The next file we have to update is the aea-config.yaml file. You can locate this file under your agent\u2019s folder. We are going to modify this file later on before we run the aea but for now, make sure it matches the following code : aea_version : 0.2.4 agent_name : m_client author : author connections : - fetchai/stub:0.1.0 default_connection : fetchai/stub:0.1.0 default_ledger : fetchai description : '' fingerprint : '' ledger_apis : {} license : Apache-2.0 logging_config : disable_existing_loggers : false version : 1 private_key_paths : {} protocols : - fetchai/default:0.1.0 registry_path : ../packages skills : - author/thermometer_client:0.1.0 - fetchai/error:0.1.0 version : 0.1.0 Important: Do not modify the aea_version. Also if you modified the author makes sure that you changed it for the skills too. For example, if you modify the author to my_author you will have to modify the skills section to : skills : - my_authos/thermometer:0.1.0 - fetchai/error:0.1.0","title":"Step6: Update the YAML files"},{"location":"aea/thermometer-skills-step-by-step/#run-the-aeas","text":"","title":"Run the AEAs"},{"location":"aea/thermometer-skills-step-by-step/#make-sure-that-your-thermometer-sensor-is-connected-to-the-raspberrys-usb-port","text":"You can change the end point's address and port by modifying the connection's yaml file (my_aea/connection/oef/connection.yaml) Under config locate : addr : ${OEF_ADDR : 127.0.0.1} and replace it with your ip (The ip of the machine that runs the oef image.) In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json","title":"Make sure that your thermometer sensor is connected to the Raspberry's usb port."},{"location":"aea/thermometer-skills-step-by-step/#fetchai-ledger-payment","text":"Create the private key for the weather client AEA. aea generate-key fetchai aea add-key fetchai fet_private_key.txt","title":"Fetch.ai ledger payment"},{"location":"aea/thermometer-skills-step-by-step/#update-the-aea-configs","text":"Both in my_aea/aea-config.yaml and my_client/aea-config.yaml , replace ledger_apis : {} with the following. ledger_apis : fetchai : network : testnet","title":"Update the AEA configs"},{"location":"aea/thermometer-skills-step-by-step/#fund-the-temperature-client-aea","text":"Create some wealth for your weather client on the Fetch.ai testnet. (It takes a while). aea generate-wealth fetchai Run both AEAs from their respective terminals aea add connection fetchai/oef:0.1.0 aea install aea run --connections fetchai/oef:0.1.0 You will see that the AEAs negotiate and then transact using the Fetch.ai testnet.","title":"Fund the temperature client AEA"},{"location":"aea/thermometer-skills-step-by-step/#ethereum-ledger-payment","text":"A demo to run the same scenario but with a true ledger transaction on the Ethereum Ropsten testnet. This demo assumes the temperature client trusts our AEA to send the temperature data upon successful payment. Create the private key for the thermometer client AEA. aea generate-key ethereum aea add-key ethereum eth_private_key.txt","title":"Ethereum ledger payment"},{"location":"aea/thermometer-skills-step-by-step/#update-the-aea-configs_1","text":"Both in my_aea/aea-config.yaml and my_client/aea-config.yaml , replace ledger_apis: {} with the following. ledger_apis : ethereum : address : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 gas_price : 50","title":"Update the AEA configs"},{"location":"aea/thermometer-skills-step-by-step/#update-the-skill-configs","text":"In the thermometer skill config (my_aea/skills/thermometer/skill.yaml) under strategy, amend the currency_id and ledger_id as follows. currency_id : 'ETH' ledger_id : 'ethereum' is_ledger_tx : True In the temprature_client skill config (my_client/skills/temprature_client/skill.yaml) under strategy change the currency_id and ledger_id. max_buyer_tx_fee : 20000 currency_id : 'ETH' ledger_id : 'ethereum' is_ledger_tx : True","title":"Update the skill configs"},{"location":"aea/thermometer-skills-step-by-step/#fund-the-thermometer-client-aea","text":"Create some wealth for your weather client on the Ethereum Ropsten test net. Go to the MetaMask Faucet and request some test ETH for the account your weather client AEA is using (you need to first load your AEAs private key into MetaMask). Your private key is at my_client/eth_private_key.txt . Run both AEAs from their respective terminals. aea add connection fetchai/oef:0.1.0 aea install aea run --connections fetchai/oef:0.1.0 You will see that the AEAs negotiate and then transact using the Ethereum testnet.","title":"Fund the thermometer client AEA"},{"location":"aea/thermometer-skills-step-by-step/#delete-the-aeas","text":"When you're done, go up a level and delete the AEAs. cd .. aea delete my_weather_station aea delete my_weather_client","title":"Delete the AEAs"},{"location":"aea/thermometer-skills/","text":"The AEA thermometer skills demonstrate an interaction between two AEAs. The provider of thermometer data (the thermometer ). The buyer of thermometer data (the thermometer_client ). Discussion The scope of the specific demo is to demonstrate how to create a very simple AEA with the usage of the AEA framework, a Raspberry Pi, and a thermometer sensor. The thermometer AEA will read data from the sensor each time a client requests and will deliver to the client upon payment. To keep the demo simple we avoided the usage of a database since this would increase the complexity. As a result, the AEA can provide only one reading from the sensor. This demo does not utilise a smart contract. As a result, we interact with a ledger only to complete a transaction. Since the AEA framework enables us to use third-party libraries hosted on PyPI we can directly reference the external dependencies. The aea install command will install each dependency that the specific AEA needs and is listed in the skill's YAML file. The AEA must run inside a Raspberry Pi or any other Linux system, and the sensor must be connected to the USB port. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Launch an OEF search and communication node In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for all the following demos. Demo instructions: Ledger payment A demo to run the thermometer scenario with a true ledger transaction on Fetch.ai testnet or Ethereum ropsten network. This demo assumes the buyer trusts the seller AEA to send the data upon successful payment. Create the thermometer AEA Create the AEA that will provide thermometer measurements. aea create my_thermometer_aea cd my_thermometer_aea aea add connection fetchai/oef:0.1.0 aea add skill fetchai/thermometer:0.1.0 aea install Create the thermometer client In another terminal, create the AEA that will query the thermometer AEA. aea create my_thermometer_client cd my_thermometer_client aea add connection fetchai/oef:0.1.0 aea add skill fetchai/thermometer_client:0.1.0 aea install Additionally, create the private key for the weather_client AEA based on the network you want to transact. To generate and add a key for Fetch.ai use: aea generate-key fetchai aea add-key fetchai fet_private_key.txt To generate and add a key for Ethereum use: aea generate-key ethereum aea add-key ethereum eth_private_key.txt Update the AEA configs Both in my_thermometer_aea/aea-config.yaml and my_thermometer_client/aea-config.yaml , replace ledger_apis: {} with the following based on the network you want to connect. To connect to Fetchai: ledger_apis : fetchai : network : testnet To connect to Ethereum: ledger_apis : ethereum : address : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 gas_price : 50 Fund the thermometer client AEA Create some wealth for your weather client based on the network you want to transact with: On the Fetch.ai testnet network. aea generate-wealth fetchai On the Ethereum ropsten . (It takes a while). aea generate-wealth ethereum Update the skill configs In the thermometer skill config ( my_thermometer_aea/vendor/fetchai/skills/thermometer/skill.yaml ) under strategy, amend the currency_id and ledger_id as follows. | ----------------------------------------------------------------------| | FETCHAI | ETHEREUM | | -----------------------------------|----------------------------------| |models : |models : | | strategy : | strategy : | | class_name : Strategy | class_name : Strategy | | args : | args : | | price_per_row : 1 | price_per_row : 1 | | seller_tx_fee : 0 | seller_tx_fee : 0 | | currency_id : 'FET' | currency_id : 'ETH' | | ledger_id : 'fetchai' | ledger_id : 'ethereum' | | has_sensor : True | has_sensor : True | | is_ledger_tx : True | is_ledger_tx : True | | ----------------------------------------------------------------------| An other way to update the skill config is via the aea config get/set command. aea config set vendor.fetchai.skills.thermometer.models.strategy.args.currency_id ETH aea config set vendor.fetchai.skills.thermometer.models.strategy.args.ledger_id ethereum NOTE: If you are not using a Raspberry Pi make sure you set the has_sensor attribute to False In the thermometer client skill config ( my_thermometer_client/vendor/fetchai/skills/thermometer_client/skill.yaml ) under strategy change the currency_id and ledger_id . | ----------------------------------------------------------------------| | FETCHAI | ETHEREUM | | -----------------------------------|----------------------------------| |models : |models : | | strategy : | strategy : | | class_name : Strategy | class_name : Strategy | | args : | args : | | max_price : 4 | max_price : 40 | | max_buyer_tx_fee : 1 | max_buyer_tx_fee : 200000 | | currency_id : 'FET' | currency_id : 'ETH' | | ledger_id : 'fetchai' | ledger_id : 'ethereum' | | is_ledger_tx : True | is_ledger_tx : True | |ledgers : [ 'fetchai' ] |ledgers : [ 'ethereum' ] | | ----------------------------------------------------------------------| An other way to update the skill config is via the aea config get/set command. aea config set vendor.fetchai.skills.thermometer_client.models.strategy.args.max_buyer_tx_fee 10000 --type int aea config set vendor.fetchai.skills.thermometer_client.models.strategy.args.currency_id ETH aea config set vendor.fetchai.skills.thermometer_client.models.strategy.args.ledger_id ethereum Run the AEAs Important: Your thermometer AEA must run on your Raspberry Pi and the sensor must be connected to the usb. You can change the end point's address and port by modifying the connection's yaml file (my_thermometer_aea/connection/oef/connection.yaml) Under config locate : addr : ${OEF_ADDR : 127.0.0.1} and replace it with your ip (The ip of the machine that runs the oef image.) Run both AEAs from their respective terminals aea add connection fetchai/oef:0.1.0 aea install aea run --connections fetchai/oef:0.1.0 You will see that the AEAs negotiate and then transact using the Fetch.ai testnet. Delete the AEAs When you're done, go up a level and delete the AEAs. cd .. aea delete my_thermometer_aea aea delete my_thermometer_client Communication This diagram shows the communication between the various entities as data is successfully sold by the thermometer AEA to the client. sequenceDiagram participant Search participant Client_AEA participant Thermometer_AEA participant Blockchain activate Client_AEA activate Search activate Thermometer_AEA activate Blockchain Thermometer_AEA->>Search: register_service Client_AEA->>Search: search Search-->>Client_AEA: list_of_agents Client_AEA->>Thermometer_AEA: call_for_proposal Thermometer_AEA->>Client_AEA: propose Client_AEA->>Thermometer_AEA: accept Thermometer_AEA->>Client_AEA: match_accept Client_AEA->>Blockchain: transfer_funds Client_AEA->>Thermometer_AEA: send_transaction_hash Thermometer_AEA->>Blockchain: check_transaction_status Thermometer_AEA->>Client_AEA: send_data deactivate Client_AEA deactivate Search deactivate Thermometer_AEA deactivate Blockchain","title":"Thermometer skills"},{"location":"aea/thermometer-skills/#discussion","text":"The scope of the specific demo is to demonstrate how to create a very simple AEA with the usage of the AEA framework, a Raspberry Pi, and a thermometer sensor. The thermometer AEA will read data from the sensor each time a client requests and will deliver to the client upon payment. To keep the demo simple we avoided the usage of a database since this would increase the complexity. As a result, the AEA can provide only one reading from the sensor. This demo does not utilise a smart contract. As a result, we interact with a ledger only to complete a transaction. Since the AEA framework enables us to use third-party libraries hosted on PyPI we can directly reference the external dependencies. The aea install command will install each dependency that the specific AEA needs and is listed in the skill's YAML file. The AEA must run inside a Raspberry Pi or any other Linux system, and the sensor must be connected to the USB port.","title":"Discussion"},{"location":"aea/thermometer-skills/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/thermometer-skills/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/thermometer-skills/#launch-an-oef-search-and-communication-node","text":"In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for all the following demos.","title":"Launch an OEF search and communication node"},{"location":"aea/thermometer-skills/#demo-instructions-ledger-payment","text":"A demo to run the thermometer scenario with a true ledger transaction on Fetch.ai testnet or Ethereum ropsten network. This demo assumes the buyer trusts the seller AEA to send the data upon successful payment.","title":"Demo instructions: Ledger payment"},{"location":"aea/thermometer-skills/#create-the-thermometer-aea","text":"Create the AEA that will provide thermometer measurements. aea create my_thermometer_aea cd my_thermometer_aea aea add connection fetchai/oef:0.1.0 aea add skill fetchai/thermometer:0.1.0 aea install","title":"Create the thermometer AEA"},{"location":"aea/thermometer-skills/#create-the-thermometer-client","text":"In another terminal, create the AEA that will query the thermometer AEA. aea create my_thermometer_client cd my_thermometer_client aea add connection fetchai/oef:0.1.0 aea add skill fetchai/thermometer_client:0.1.0 aea install Additionally, create the private key for the weather_client AEA based on the network you want to transact. To generate and add a key for Fetch.ai use: aea generate-key fetchai aea add-key fetchai fet_private_key.txt To generate and add a key for Ethereum use: aea generate-key ethereum aea add-key ethereum eth_private_key.txt","title":"Create the thermometer client"},{"location":"aea/thermometer-skills/#update-the-aea-configs","text":"Both in my_thermometer_aea/aea-config.yaml and my_thermometer_client/aea-config.yaml , replace ledger_apis: {} with the following based on the network you want to connect. To connect to Fetchai: ledger_apis : fetchai : network : testnet To connect to Ethereum: ledger_apis : ethereum : address : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 gas_price : 50","title":"Update the AEA configs"},{"location":"aea/thermometer-skills/#fund-the-thermometer-client-aea","text":"Create some wealth for your weather client based on the network you want to transact with: On the Fetch.ai testnet network. aea generate-wealth fetchai On the Ethereum ropsten . (It takes a while). aea generate-wealth ethereum","title":"Fund the thermometer client AEA"},{"location":"aea/thermometer-skills/#update-the-skill-configs","text":"In the thermometer skill config ( my_thermometer_aea/vendor/fetchai/skills/thermometer/skill.yaml ) under strategy, amend the currency_id and ledger_id as follows. | ----------------------------------------------------------------------| | FETCHAI | ETHEREUM | | -----------------------------------|----------------------------------| |models : |models : | | strategy : | strategy : | | class_name : Strategy | class_name : Strategy | | args : | args : | | price_per_row : 1 | price_per_row : 1 | | seller_tx_fee : 0 | seller_tx_fee : 0 | | currency_id : 'FET' | currency_id : 'ETH' | | ledger_id : 'fetchai' | ledger_id : 'ethereum' | | has_sensor : True | has_sensor : True | | is_ledger_tx : True | is_ledger_tx : True | | ----------------------------------------------------------------------| An other way to update the skill config is via the aea config get/set command. aea config set vendor.fetchai.skills.thermometer.models.strategy.args.currency_id ETH aea config set vendor.fetchai.skills.thermometer.models.strategy.args.ledger_id ethereum NOTE: If you are not using a Raspberry Pi make sure you set the has_sensor attribute to False In the thermometer client skill config ( my_thermometer_client/vendor/fetchai/skills/thermometer_client/skill.yaml ) under strategy change the currency_id and ledger_id . | ----------------------------------------------------------------------| | FETCHAI | ETHEREUM | | -----------------------------------|----------------------------------| |models : |models : | | strategy : | strategy : | | class_name : Strategy | class_name : Strategy | | args : | args : | | max_price : 4 | max_price : 40 | | max_buyer_tx_fee : 1 | max_buyer_tx_fee : 200000 | | currency_id : 'FET' | currency_id : 'ETH' | | ledger_id : 'fetchai' | ledger_id : 'ethereum' | | is_ledger_tx : True | is_ledger_tx : True | |ledgers : [ 'fetchai' ] |ledgers : [ 'ethereum' ] | | ----------------------------------------------------------------------| An other way to update the skill config is via the aea config get/set command. aea config set vendor.fetchai.skills.thermometer_client.models.strategy.args.max_buyer_tx_fee 10000 --type int aea config set vendor.fetchai.skills.thermometer_client.models.strategy.args.currency_id ETH aea config set vendor.fetchai.skills.thermometer_client.models.strategy.args.ledger_id ethereum","title":"Update the skill configs"},{"location":"aea/thermometer-skills/#run-the-aeas","text":"Important: Your thermometer AEA must run on your Raspberry Pi and the sensor must be connected to the usb. You can change the end point's address and port by modifying the connection's yaml file (my_thermometer_aea/connection/oef/connection.yaml) Under config locate : addr : ${OEF_ADDR : 127.0.0.1} and replace it with your ip (The ip of the machine that runs the oef image.) Run both AEAs from their respective terminals aea add connection fetchai/oef:0.1.0 aea install aea run --connections fetchai/oef:0.1.0 You will see that the AEAs negotiate and then transact using the Fetch.ai testnet.","title":"Run the AEAs"},{"location":"aea/thermometer-skills/#delete-the-aeas","text":"When you're done, go up a level and delete the AEAs. cd .. aea delete my_thermometer_aea aea delete my_thermometer_client","title":"Delete the AEAs"},{"location":"aea/thermometer-skills/#communication","text":"This diagram shows the communication between the various entities as data is successfully sold by the thermometer AEA to the client. sequenceDiagram participant Search participant Client_AEA participant Thermometer_AEA participant Blockchain activate Client_AEA activate Search activate Thermometer_AEA activate Blockchain Thermometer_AEA->>Search: register_service Client_AEA->>Search: search Search-->>Client_AEA: list_of_agents Client_AEA->>Thermometer_AEA: call_for_proposal Thermometer_AEA->>Client_AEA: propose Client_AEA->>Thermometer_AEA: accept Thermometer_AEA->>Client_AEA: match_accept Client_AEA->>Blockchain: transfer_funds Client_AEA->>Thermometer_AEA: send_transaction_hash Thermometer_AEA->>Blockchain: check_transaction_status Thermometer_AEA->>Client_AEA: send_data deactivate Client_AEA deactivate Search deactivate Thermometer_AEA deactivate Blockchain","title":"Communication"},{"location":"aea/trust/","text":"AEA applications operate within different orders of trustlessness. For example, using the AEA weather skills demo without ledger payments means that clients must trust that any data the weather station sends is sufficient, including no data at all. Similarly, the weather station must trust the weather clients to send payment via some mechanism. A step up, if you run the weather skills demo with a ledger (Fetch.ai or Ethereum) then the clients must again trust the weather station to send sufficient data. However, all payment transactions are executed via the public ledger. This means the weather station no longer needs to trust the weather clients as it can observe the transactions taking place on the public ledger. We can expand trustlessness even further by incorporating a third-party as an arbitrator or some escrow contract. However, in the weather skills demo there are limits to trustlessness as the station ultimately offers unverifiable data. Finally, in the case of (non-fungible) token transactions where there is an atomic swap, full trustlessness is apparent. This is demonstrated in the TAC.","title":"Trust issues"},{"location":"aea/version/","text":"The current version of the Autonomous Economic Agent framework is 0.2.4 . The framework is under rapid development with frequent breaking changes. To check which version you have installed locally, run aea --version","title":"Version"},{"location":"aea/vision/","text":"The AEA framework has two commercial roles which are outlined below. Open source technology We are creating infrastructure for developers to build their own agent-based solutions. AEA users are, among others: Data scientists. Economists. Researchers (Artificial Intelligence, Machine Learning, Multi-Agent Systems). Engineers. Machine learning experts. Independent developers. Students and academics. Crypto connoisseurs and enthusiasts. Web developers. Platform for start ups By operating as a platform for start ups, we envisage the AEA framework to be in a continuous growth pattern. With start up grants we will kick start solutions while testing product-problem fit and identifying our user base.","title":"Vision"},{"location":"aea/vision/#open-source-technology","text":"We are creating infrastructure for developers to build their own agent-based solutions. AEA users are, among others: Data scientists. Economists. Researchers (Artificial Intelligence, Machine Learning, Multi-Agent Systems). Engineers. Machine learning experts. Independent developers. Students and academics. Crypto connoisseurs and enthusiasts. Web developers.","title":"Open source technology"},{"location":"aea/vision/#platform-for-start-ups","text":"By operating as a platform for start ups, we envisage the AEA framework to be in a continuous growth pattern. With start up grants we will kick start solutions while testing product-problem fit and identifying our user base.","title":"Platform for start ups"},{"location":"aea/wealth/","text":"To fund an AEA for testing on a test-net you need to request some test tokens from a faucet. Add a private key to the agent: aea generate-key fetchai aea add-key fetchai fet_private_key.txt or aea generate-key ethereum aea add-key ethereum eth_private_key.txt Ensure the ledger apis are set in the aea config: ledger_apis: fetchai: network: testnet for fetchai or ledger_apis: fetchai: host: testnet.fetch-ai.com port: 80 or ledger_apis: ethereum: address: https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id: 3 or both ledger_apis: ethereum: address: https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id: 3 fetchai: network: testnet Using a faucet website First, print the address: aea get-address fetchai or aea get-address ethereum This will print the address to the console. Copy the address into the clipboard and request test tokens from the faucet here for Fetch.ai or here for Ethereum . It will take a while for the tokens to become available. Second, after some time, check the wealth associated with the address: aea get-wealth fetchai or aea get-wealth ethereum Using the cli Simply generate wealth via the cli: aea generate-wealth fetchai or aea generate-wealth ethereum","title":"Generating wealth"},{"location":"aea/wealth/#using-a-faucet-website","text":"First, print the address: aea get-address fetchai or aea get-address ethereum This will print the address to the console. Copy the address into the clipboard and request test tokens from the faucet here for Fetch.ai or here for Ethereum . It will take a while for the tokens to become available. Second, after some time, check the wealth associated with the address: aea get-wealth fetchai or aea get-wealth ethereum","title":"Using a faucet website"},{"location":"aea/wealth/#using-the-cli","text":"Simply generate wealth via the cli: aea generate-wealth fetchai or aea generate-wealth ethereum","title":"Using the cli"},{"location":"aea/weather-skills/","text":"The AEA weather skills demonstrate an interaction between two AEAs. The provider of weather data (the weather_station ). The buyer of weather data (the weather_client ). Discussion The scope of the specific demo is to demonstrate how to create a simple AEA with the usage of the AEA framework and a database. The weather_station AEA will read data from the database, that is populated with readings from a weather station, based on the requested dates and will deliver the data to the client upon payment. This demo does not utilize a smart contract. As a result, we interact with a ledger only to complete a transaction. You can use this AEA as an example of how to read data from a database and advertise these to possible clients. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Launch an OEF search and communication node In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for all the following demos. Demo instructions 1: no ledger payment The AEAs negotiate and then transfer the data. No payment takes place. This demo serves as a demonstration of the negotiation steps. Create the weather station AEA In the root directory, create the weather station AEA. aea create my_weather_station Add the oef connection and the weather station skill cd my_weather_station aea add connection fetchai/oef:0.1.0 aea add skill fetchai/weather_station:0.1.0 aea install Update the AEA configs In the terminal change the configuration: aea config set vendor.fetchai.skills.weather_station.models.strategy.args.is_ledger_tx False --type bool The is_ledger_tx will prevent the AEA to communicate with a ledger. Run the weather station AEA aea run --connections fetchai/oef:0.1.0 Create the weather client AEA In a new terminal window, return to the root directory and create the weather client AEA. aea create my_weather_client Add the oef connection and the weather client skill cd my_weather_client aea add connection fetchai/oef:0.1.0 aea add skill fetchai/weather_client:0.1.0 aea install Update the AEA configs In the terminal change the configuration: aea config set vendor.fetchai.skills.weather_client.models.strategy.args.is_ledger_tx False --type bool The is_ledger_tx will prevent the AEA to communicate with a ledger. Run the weather client AEA aea run --connections fetchai/oef:0.1.0 Observe the logs of both AEAs To stop an AEA use CTRL + C . Delete the AEAs When you're done, go up a level and delete the AEAs. cd .. aea delete my_weather_station aea delete my_weather_client Communication This diagram shows the communication between the various entities as data is successfully sold by the car park AEA to the client. sequenceDiagram participant Search participant Client_AEA participant Weather_AEA activate Client_AEA activate Search activate Weather_AEA Weather_AEA->>Search: register_service Client_AEA->>Search: search Search-->>Client_AEA: list_of_agents Client_AEA->>Weather_AEA: call_for_proposal Weather_AEA->>Client_AEA: propose Client_AEA->>Weather_AEA: accept Weather_AEA->>Client_AEA: match_accept Client_AEA->>Weather_AEA: Inform funds transfered Weather_AEA->>Client_AEA: send_data deactivate Client_AEA deactivate Search deactivate Weather_AEA Note that the client informs the weather station that funds have been transfereed, but in this example no funds actually get transfered. Demo instructions 2: Ledger payment A demo to run the same scenario but with a true ledger transaction on Fetch.ai testnet or Ethereum ropsten network. This demo assumes the buyer trusts the seller AEA to send the data upon successful payment. Create the weather station (ledger version) Create the AEA that will provide weather measurements. aea create my_weather_station cd my_weather_station aea add connection fetchai/oef:0.1.0 aea add skill fetchai/weather_station:0.1.0 aea install Create the weather client (ledger version) In another terminal, create the AEA that will query the weather station. aea create my_weather_client cd my_weather_client aea add connection fetchai/oef:0.1.0 aea add skill fetchai/weather_client:0.1.0 aea install Additionally, create the private key for the weather_client AEA based on the network you want to transact. To generate and add a key for Fetch.ai use: aea generate-key fetchai aea add-key fetchai fet_private_key.txt To generate and add a key for Ethereum use: aea generate-key ethereum aea add-key ethereum eth_private_key.txt Update the AEA configs Both in my_seller_aea/aea-config.yaml and my_buyer_aea/aea-config.yaml , replace ledger_apis: {} with the following based on the network you want to connect. To connect to Fetch.ai: ledger_apis : fetchai : network : testnet To connect to Ethereum: ledger_apis : ethereum : address : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 gas_price : 50 Fund the weather client AEA Create some wealth for your weather client based on the network you want to transact with: On the Fetch.ai testnet network. aea generate-wealth fetchai On the Ethereum ropsten . (It takes a while). aea generate-wealth ethereum Update the skill configs In my_weather_station/vendor/fetchai/skills/weather_station/skill.yaml , under strategy amend the currency_id and ledger_id as follows: | ----------------------------------------------------------------------| | FETCHAI | ETHEREUM | | -----------------------------------|----------------------------------| |models : |models : | | strategy : | strategy : | | class_name : Strategy | class_name : Strategy | | args : | args : | | date_one : \"1/10/2019\" | date_one : \"1/10/2019\" | | date_two : \"1/12/2019\" | date_two : \"1/12/2019\" | | price_per_row : 1 | price_per_row : 1 | | seller_tx_fee : 0 | seller_tx_fee : 0 | | currency_id : 'FET' | currency_id : 'ETH' | | ledger_id : 'fetchai' | ledger_id : 'ethereum' | | is_ledger_tx : True | is_ledger_tx : True | | ----------------------------------------------------------------------| In the weather client skill config ( my_weather_client/vendor/fetchai/skills/weather_client/skill.yaml ) under strategy change the currency_id and ledger_id . | ----------------------------------------------------------------------| | FETCHAI | ETHEREUM | | -----------------------------------|----------------------------------| |models : |models : | | strategy : | strategy : | | class_name : Strategy | class_name : Strategy | | args : | args : | | max_price : 4 | max_price : 40 | | max_buyer_tx_fee : 1 | max_buyer_tx_fee : 200000 | | currency_id : 'FET' | currency_id : 'ETH' | | ledger_id : 'fetchai' | ledger_id : 'ethereum' | | is_ledger_tx : True | is_ledger_tx : True | |ledgers : [ 'fetchai' ] |ledgers : [ 'ethereum' ] | | ----------------------------------------------------------------------| An other way to update the skill config is via the aea config get/set command. aea config set vendor.fetchai.skills.weather_client.models.strategy.args.max_buyer_tx_fee 10000 --type int aea config set vendor.fetchai.skills.weather_client.models.strategy.args.currency_id ETH aea config set vendor.fetchai.skills.weather_client.models.strategy.args.ledger_id ethereum aea config set vendor.fetchai.skills.weather_client.models.strategy.args.is_ledger_tx True --type bool Run the AEAs Run both AEAs from their respective terminals. aea run --connections fetchai/oef:0.1.0 You will see that the AEAs negotiate and then transact using the Fetch.ai testnet . Delete the AEAs When you're done, go up a level and delete the AEAs. cd .. aea delete my_weather_station aea delete my_weather_client Communication This diagram shows the communication between the various entities as data is successfully sold by the weather station AEA to the client. sequenceDiagram participant Search participant Client_AEA participant Weather_AEA participant Blockchain activate Client_AEA activate Search activate Weather_AEA activate Blockchain Weather_AEA->>Search: register_service Client_AEA->>Search: search Search-->>Client_AEA: list_of_agents Client_AEA->>Weather_AEA: call_for_proposal Weather_AEA->>Client_AEA: propose Client_AEA->>Weather_AEA: accept Weather_AEA->>Client_AEA: match_accept Client_AEA->>Blockchain: transfer_funds Client_AEA->>Weather_AEA: send_transaction_hash Weather_AEA->>Blockchain: check_transaction_status Weather_AEA->>Client_AEA: send_data deactivate Client_AEA deactivate Search deactivate Weather_AEA deactivate Blockchain","title":"Weather skills"},{"location":"aea/weather-skills/#discussion","text":"The scope of the specific demo is to demonstrate how to create a simple AEA with the usage of the AEA framework and a database. The weather_station AEA will read data from the database, that is populated with readings from a weather station, based on the requested dates and will deliver the data to the client upon payment. This demo does not utilize a smart contract. As a result, we interact with a ledger only to complete a transaction. You can use this AEA as an example of how to read data from a database and advertise these to possible clients.","title":"Discussion"},{"location":"aea/weather-skills/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/weather-skills/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/weather-skills/#launch-an-oef-search-and-communication-node","text":"In a separate terminal, launch a local OEF search and communication node . python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for all the following demos.","title":"Launch an OEF search and communication node"},{"location":"aea/weather-skills/#demo-instructions-1-no-ledger-payment","text":"The AEAs negotiate and then transfer the data. No payment takes place. This demo serves as a demonstration of the negotiation steps.","title":"Demo instructions 1: no ledger payment"},{"location":"aea/weather-skills/#create-the-weather-station-aea","text":"In the root directory, create the weather station AEA. aea create my_weather_station","title":"Create the weather station AEA"},{"location":"aea/weather-skills/#add-the-oef-connection-and-the-weather-station-skill","text":"cd my_weather_station aea add connection fetchai/oef:0.1.0 aea add skill fetchai/weather_station:0.1.0 aea install","title":"Add the oef connection and the weather station skill"},{"location":"aea/weather-skills/#update-the-aea-configs","text":"In the terminal change the configuration: aea config set vendor.fetchai.skills.weather_station.models.strategy.args.is_ledger_tx False --type bool The is_ledger_tx will prevent the AEA to communicate with a ledger.","title":"Update the AEA configs"},{"location":"aea/weather-skills/#run-the-weather-station-aea","text":"aea run --connections fetchai/oef:0.1.0","title":"Run the weather station AEA"},{"location":"aea/weather-skills/#create-the-weather-client-aea","text":"In a new terminal window, return to the root directory and create the weather client AEA. aea create my_weather_client","title":"Create the weather client AEA"},{"location":"aea/weather-skills/#add-the-oef-connection-and-the-weather-client-skill","text":"cd my_weather_client aea add connection fetchai/oef:0.1.0 aea add skill fetchai/weather_client:0.1.0 aea install","title":"Add the oef connection and the weather client skill"},{"location":"aea/weather-skills/#update-the-aea-configs_1","text":"In the terminal change the configuration: aea config set vendor.fetchai.skills.weather_client.models.strategy.args.is_ledger_tx False --type bool The is_ledger_tx will prevent the AEA to communicate with a ledger.","title":"Update the AEA configs"},{"location":"aea/weather-skills/#run-the-weather-client-aea","text":"aea run --connections fetchai/oef:0.1.0","title":"Run the weather client AEA"},{"location":"aea/weather-skills/#observe-the-logs-of-both-aeas","text":"To stop an AEA use CTRL + C .","title":"Observe the logs of both AEAs"},{"location":"aea/weather-skills/#delete-the-aeas","text":"When you're done, go up a level and delete the AEAs. cd .. aea delete my_weather_station aea delete my_weather_client","title":"Delete the AEAs"},{"location":"aea/weather-skills/#communication","text":"This diagram shows the communication between the various entities as data is successfully sold by the car park AEA to the client. sequenceDiagram participant Search participant Client_AEA participant Weather_AEA activate Client_AEA activate Search activate Weather_AEA Weather_AEA->>Search: register_service Client_AEA->>Search: search Search-->>Client_AEA: list_of_agents Client_AEA->>Weather_AEA: call_for_proposal Weather_AEA->>Client_AEA: propose Client_AEA->>Weather_AEA: accept Weather_AEA->>Client_AEA: match_accept Client_AEA->>Weather_AEA: Inform funds transfered Weather_AEA->>Client_AEA: send_data deactivate Client_AEA deactivate Search deactivate Weather_AEA Note that the client informs the weather station that funds have been transfereed, but in this example no funds actually get transfered.","title":"Communication"},{"location":"aea/weather-skills/#demo-instructions-2-ledger-payment","text":"A demo to run the same scenario but with a true ledger transaction on Fetch.ai testnet or Ethereum ropsten network. This demo assumes the buyer trusts the seller AEA to send the data upon successful payment.","title":"Demo instructions 2: Ledger payment"},{"location":"aea/weather-skills/#create-the-weather-station-ledger-version","text":"Create the AEA that will provide weather measurements. aea create my_weather_station cd my_weather_station aea add connection fetchai/oef:0.1.0 aea add skill fetchai/weather_station:0.1.0 aea install","title":"Create the weather station (ledger version)"},{"location":"aea/weather-skills/#create-the-weather-client-ledger-version","text":"In another terminal, create the AEA that will query the weather station. aea create my_weather_client cd my_weather_client aea add connection fetchai/oef:0.1.0 aea add skill fetchai/weather_client:0.1.0 aea install Additionally, create the private key for the weather_client AEA based on the network you want to transact. To generate and add a key for Fetch.ai use: aea generate-key fetchai aea add-key fetchai fet_private_key.txt To generate and add a key for Ethereum use: aea generate-key ethereum aea add-key ethereum eth_private_key.txt","title":"Create the weather client (ledger version)"},{"location":"aea/weather-skills/#update-the-aea-configs_2","text":"Both in my_seller_aea/aea-config.yaml and my_buyer_aea/aea-config.yaml , replace ledger_apis: {} with the following based on the network you want to connect. To connect to Fetch.ai: ledger_apis : fetchai : network : testnet To connect to Ethereum: ledger_apis : ethereum : address : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe chain_id : 3 gas_price : 50","title":"Update the AEA configs"},{"location":"aea/weather-skills/#fund-the-weather-client-aea","text":"Create some wealth for your weather client based on the network you want to transact with: On the Fetch.ai testnet network. aea generate-wealth fetchai On the Ethereum ropsten . (It takes a while). aea generate-wealth ethereum","title":"Fund the weather client AEA"},{"location":"aea/weather-skills/#update-the-skill-configs","text":"In my_weather_station/vendor/fetchai/skills/weather_station/skill.yaml , under strategy amend the currency_id and ledger_id as follows: | ----------------------------------------------------------------------| | FETCHAI | ETHEREUM | | -----------------------------------|----------------------------------| |models : |models : | | strategy : | strategy : | | class_name : Strategy | class_name : Strategy | | args : | args : | | date_one : \"1/10/2019\" | date_one : \"1/10/2019\" | | date_two : \"1/12/2019\" | date_two : \"1/12/2019\" | | price_per_row : 1 | price_per_row : 1 | | seller_tx_fee : 0 | seller_tx_fee : 0 | | currency_id : 'FET' | currency_id : 'ETH' | | ledger_id : 'fetchai' | ledger_id : 'ethereum' | | is_ledger_tx : True | is_ledger_tx : True | | ----------------------------------------------------------------------| In the weather client skill config ( my_weather_client/vendor/fetchai/skills/weather_client/skill.yaml ) under strategy change the currency_id and ledger_id . | ----------------------------------------------------------------------| | FETCHAI | ETHEREUM | | -----------------------------------|----------------------------------| |models : |models : | | strategy : | strategy : | | class_name : Strategy | class_name : Strategy | | args : | args : | | max_price : 4 | max_price : 40 | | max_buyer_tx_fee : 1 | max_buyer_tx_fee : 200000 | | currency_id : 'FET' | currency_id : 'ETH' | | ledger_id : 'fetchai' | ledger_id : 'ethereum' | | is_ledger_tx : True | is_ledger_tx : True | |ledgers : [ 'fetchai' ] |ledgers : [ 'ethereum' ] | | ----------------------------------------------------------------------| An other way to update the skill config is via the aea config get/set command. aea config set vendor.fetchai.skills.weather_client.models.strategy.args.max_buyer_tx_fee 10000 --type int aea config set vendor.fetchai.skills.weather_client.models.strategy.args.currency_id ETH aea config set vendor.fetchai.skills.weather_client.models.strategy.args.ledger_id ethereum aea config set vendor.fetchai.skills.weather_client.models.strategy.args.is_ledger_tx True --type bool","title":"Update the skill configs"},{"location":"aea/weather-skills/#run-the-aeas","text":"Run both AEAs from their respective terminals. aea run --connections fetchai/oef:0.1.0 You will see that the AEAs negotiate and then transact using the Fetch.ai testnet .","title":"Run the AEAs"},{"location":"aea/weather-skills/#delete-the-aeas_1","text":"When you're done, go up a level and delete the AEAs. cd .. aea delete my_weather_station aea delete my_weather_client","title":"Delete the AEAs"},{"location":"aea/weather-skills/#communication_1","text":"This diagram shows the communication between the various entities as data is successfully sold by the weather station AEA to the client. sequenceDiagram participant Search participant Client_AEA participant Weather_AEA participant Blockchain activate Client_AEA activate Search activate Weather_AEA activate Blockchain Weather_AEA->>Search: register_service Client_AEA->>Search: search Search-->>Client_AEA: list_of_agents Client_AEA->>Weather_AEA: call_for_proposal Weather_AEA->>Client_AEA: propose Client_AEA->>Weather_AEA: accept Weather_AEA->>Client_AEA: match_accept Client_AEA->>Blockchain: transfer_funds Client_AEA->>Weather_AEA: send_transaction_hash Weather_AEA->>Blockchain: check_transaction_status Weather_AEA->>Client_AEA: send_data deactivate Client_AEA deactivate Search deactivate Weather_AEA deactivate Blockchain","title":"Communication"},{"location":"aea/api/aea/","text":"aea.aea This module contains the implementation of an Autonomous Economic Agent. AEA class AEA ( Agent ) This class implements an autonomous economic agent. __ init __ | __init__ ( identity : Identity , connections : List [ Connection ], wallet : Wallet , ledger_apis : LedgerApis , resources : Resources , loop : Optional [ AbstractEventLoop ] = None , timeout : float = 0.0 , is_debug : bool = False , is_programmatic : bool = True , max_reactions : int = 20 ) -> None Instantiate the agent. Arguments : identity : the identity of the agent connections : the list of connections of the agent. loop : the event loop to run the connections. wallet : the wallet of the agent. ledger_apis : the ledger apis of the agent. resources : the resources of the agent. timeout : the time in (fractions of) seconds to time out an agent between act and react is_debug : if True, run the agent in debug mode. is_programmatic : if True, run the agent in programmatic mode (skips loading of resources from directory). max_reactions : the processing rate of messages per iteration. Returns : None decision _ maker | @property | decision_maker () -> DecisionMaker Get decision maker. context | @property | context () -> AgentContext Get context. resources | @resources . setter | resources ( resources : \"Resources\" ) -> None Set resources. filter | @property | filter () -> Filter Get filter. task _ manager | @property | task_manager () -> TaskManager Get the task manager. setup | setup () -> None Set up the agent. Returns : None act | act () -> None Perform actions. Returns : None react | react () -> None React to incoming events (envelopes). Returns : None update | update () -> None Update the current state of the agent. :return None teardown | teardown () -> None Tear down the agent. Returns : None","title":"AEA"},{"location":"aea/api/aea/#aeaaea","text":"This module contains the implementation of an Autonomous Economic Agent.","title":"aea.aea"},{"location":"aea/api/aea/#aea","text":"class AEA ( Agent ) This class implements an autonomous economic agent.","title":"AEA"},{"location":"aea/api/aea/#__init__","text":"| __init__ ( identity : Identity , connections : List [ Connection ], wallet : Wallet , ledger_apis : LedgerApis , resources : Resources , loop : Optional [ AbstractEventLoop ] = None , timeout : float = 0.0 , is_debug : bool = False , is_programmatic : bool = True , max_reactions : int = 20 ) -> None Instantiate the agent. Arguments : identity : the identity of the agent connections : the list of connections of the agent. loop : the event loop to run the connections. wallet : the wallet of the agent. ledger_apis : the ledger apis of the agent. resources : the resources of the agent. timeout : the time in (fractions of) seconds to time out an agent between act and react is_debug : if True, run the agent in debug mode. is_programmatic : if True, run the agent in programmatic mode (skips loading of resources from directory). max_reactions : the processing rate of messages per iteration. Returns : None","title":"__init__"},{"location":"aea/api/aea/#decision_maker","text":"| @property | decision_maker () -> DecisionMaker Get decision maker.","title":"decision_maker"},{"location":"aea/api/aea/#context","text":"| @property | context () -> AgentContext Get context.","title":"context"},{"location":"aea/api/aea/#resources","text":"| @resources . setter | resources ( resources : \"Resources\" ) -> None Set resources.","title":"resources"},{"location":"aea/api/aea/#filter","text":"| @property | filter () -> Filter Get filter.","title":"filter"},{"location":"aea/api/aea/#task_manager","text":"| @property | task_manager () -> TaskManager Get the task manager.","title":"task_manager"},{"location":"aea/api/aea/#setup","text":"| setup () -> None Set up the agent. Returns : None","title":"setup"},{"location":"aea/api/aea/#act","text":"| act () -> None Perform actions. Returns : None","title":"act"},{"location":"aea/api/aea/#react","text":"| react () -> None React to incoming events (envelopes). Returns : None","title":"react"},{"location":"aea/api/aea/#update","text":"| update () -> None Update the current state of the agent. :return None","title":"update"},{"location":"aea/api/aea/#teardown","text":"| teardown () -> None Tear down the agent. Returns : None","title":"teardown"},{"location":"aea/api/agent/","text":"aea.agent This module contains the implementation of a template agent. AgentState class AgentState ( Enum ) Enumeration for an agent state. Liveness class Liveness () Determines the liveness of the agent. __ init __ | __init__ () Instantiate the liveness. is _ stopped | @property | is_stopped () -> bool Check whether the liveness is stopped. start | start () -> None Start the liveness. stop | stop () -> None Stop the liveness. Agent class Agent ( ABC ) This class implements a template agent. __ init __ | __init__ ( identity : Identity , connections : List [ Connection ], loop : Optional [ AbstractEventLoop ] = None , timeout : float = 1.0 , is_debug : bool = False , is_programmatic : bool = True ) -> None Instantiate the agent. Arguments : identity : the identity of the agent. connections : the list of connections of the agent. loop : the event loop to run the connections. timeout : the time in (fractions of) seconds to time out an agent between act and react is_debug : if True, run the agent in debug mode. is_programmatic : if True, run the agent in programmatic mode (skips loading of resources from directory). Returns : None identity | @property | identity () -> Identity Get the identity. multiplexer | @property | multiplexer () -> Multiplexer Get the multiplexer. inbox | @property | inbox () -> InBox Get the inbox. outbox | @property | outbox () -> OutBox Get the outbox. name | @property | name () -> str Get the agent name. liveness | @property | liveness () -> Liveness Get the liveness. tick | @property | tick () -> int Get the tick. agent _ state | @property | agent_state () -> AgentState Get the state of the agent. In particular, it can be one of the following states: - AgentState.INITIATED: when the Agent object has been created. - AgentState.CONNECTED: when the agent is connected. - AgentState.RUNNING: when the agent is running. :return the agent state. Raises : ValueError : if the state does not satisfy any of the foreseen conditions. start | start () -> None Start the agent. Returns : None stop | stop () -> None Stop the agent. Returns : None setup | @abstractmethod | setup () -> None Set up the agent. Returns : None act | @abstractmethod | act () -> None Perform actions. Returns : None react | @abstractmethod | react () -> None React to incoming events. Returns : None update | @abstractmethod | update () -> None Update the current state of the agent. :return None teardown | @abstractmethod | teardown () -> None Tear down the agent. Returns : None","title":"Agent"},{"location":"aea/api/agent/#aeaagent","text":"This module contains the implementation of a template agent.","title":"aea.agent"},{"location":"aea/api/agent/#agentstate","text":"class AgentState ( Enum ) Enumeration for an agent state.","title":"AgentState"},{"location":"aea/api/agent/#liveness","text":"class Liveness () Determines the liveness of the agent.","title":"Liveness"},{"location":"aea/api/agent/#__init__","text":"| __init__ () Instantiate the liveness.","title":"__init__"},{"location":"aea/api/agent/#is_stopped","text":"| @property | is_stopped () -> bool Check whether the liveness is stopped.","title":"is_stopped"},{"location":"aea/api/agent/#start","text":"| start () -> None Start the liveness.","title":"start"},{"location":"aea/api/agent/#stop","text":"| stop () -> None Stop the liveness.","title":"stop"},{"location":"aea/api/agent/#agent","text":"class Agent ( ABC ) This class implements a template agent.","title":"Agent"},{"location":"aea/api/agent/#__init___1","text":"| __init__ ( identity : Identity , connections : List [ Connection ], loop : Optional [ AbstractEventLoop ] = None , timeout : float = 1.0 , is_debug : bool = False , is_programmatic : bool = True ) -> None Instantiate the agent. Arguments : identity : the identity of the agent. connections : the list of connections of the agent. loop : the event loop to run the connections. timeout : the time in (fractions of) seconds to time out an agent between act and react is_debug : if True, run the agent in debug mode. is_programmatic : if True, run the agent in programmatic mode (skips loading of resources from directory). Returns : None","title":"__init__"},{"location":"aea/api/agent/#identity","text":"| @property | identity () -> Identity Get the identity.","title":"identity"},{"location":"aea/api/agent/#multiplexer","text":"| @property | multiplexer () -> Multiplexer Get the multiplexer.","title":"multiplexer"},{"location":"aea/api/agent/#inbox","text":"| @property | inbox () -> InBox Get the inbox.","title":"inbox"},{"location":"aea/api/agent/#outbox","text":"| @property | outbox () -> OutBox Get the outbox.","title":"outbox"},{"location":"aea/api/agent/#name","text":"| @property | name () -> str Get the agent name.","title":"name"},{"location":"aea/api/agent/#liveness_1","text":"| @property | liveness () -> Liveness Get the liveness.","title":"liveness"},{"location":"aea/api/agent/#tick","text":"| @property | tick () -> int Get the tick.","title":"tick"},{"location":"aea/api/agent/#agent_state","text":"| @property | agent_state () -> AgentState Get the state of the agent. In particular, it can be one of the following states: - AgentState.INITIATED: when the Agent object has been created. - AgentState.CONNECTED: when the agent is connected. - AgentState.RUNNING: when the agent is running. :return the agent state. Raises : ValueError : if the state does not satisfy any of the foreseen conditions.","title":"agent_state"},{"location":"aea/api/agent/#start_1","text":"| start () -> None Start the agent. Returns : None","title":"start"},{"location":"aea/api/agent/#stop_1","text":"| stop () -> None Stop the agent. Returns : None","title":"stop"},{"location":"aea/api/agent/#setup","text":"| @abstractmethod | setup () -> None Set up the agent. Returns : None","title":"setup"},{"location":"aea/api/agent/#act","text":"| @abstractmethod | act () -> None Perform actions. Returns : None","title":"act"},{"location":"aea/api/agent/#react","text":"| @abstractmethod | react () -> None React to incoming events. Returns : None","title":"react"},{"location":"aea/api/agent/#update","text":"| @abstractmethod | update () -> None Update the current state of the agent. :return None","title":"update"},{"location":"aea/api/agent/#teardown","text":"| @abstractmethod | teardown () -> None Tear down the agent. Returns : None","title":"teardown"},{"location":"aea/api/configurations/base/","text":"aea.configurations.base Classes to handle AEA configurations. Dependency A dependency is a dictionary with the following (optional) keys: - version: a version specifier(s) (e.g. '==0.1.0'). - index: the PyPI index where to download the package from (default: https://pypi.org) - git: the URL to the Git repository (e.g. https://github.com/fetchai/agents-aea.git) - ref: either the branch name, the tag, the commit number or a Git reference (default: 'master'.) If the 'git' field is set, the 'version' field will be ignored. They are supposed to be forwarded to the 'pip' command. Dependencies A dictionary from package name to dependency data structure (see above). The package name must satisfy the constraints on Python packages names. For details, see https://www.python.org/dev/peps/pep-0426/ name . The main advantage of having a dictionary is that we implicitly filter out dependency duplicates. We cannot have two items with the same package name since the keys of a YAML object form a set. ConfigurationType class ConfigurationType ( Enum ) Configuration types. ProtocolSpecificationParseError class ProtocolSpecificationParseError ( Exception ) Exception for parsing a protocol specification file. JSONSerializable class JSONSerializable ( ABC ) Interface for JSON-serializable objects. json | @property | @abstractmethod | json () -> Dict Compute the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict ) Build from a JSON object. Configuration class Configuration ( JSONSerializable , ABC ) Configuration class. CRUDCollection class CRUDCollection ( Generic [ T ]) Interface of a CRUD collection. __ init __ | __init__ () Instantiate a CRUD collection. create | create ( item_id : str , item : T ) -> None Add an item. Arguments : item_id : the item id. item : the item to be added. Returns : None Raises : ValueError : if the item with the same id is already in the collection. read | read ( item_id : str ) -> Optional [ T ] Get an item by its name. Arguments : item_id : the item id. Returns : the associated item, or None if the item id is not present. update | update ( item_id : str , item : T ) -> None Update an existing item. Arguments : item_id : the item id. item : the item to be added. Returns : None delete | delete ( item_id : str ) -> None Delete an item. read _ all | read_all () -> List [ Tuple [ str , T ]] Read all the items. PublicId class PublicId ( JSONSerializable ) This class implement a public identifier. A public identifier is composed of three elements: - author - name - version The concatenation of those three elements gives the public identifier: author/name:version public_id = PublicId(\"author\", \"my_package\", \"0.1.0\") assert public_id.author == \"author\" assert public_id.name == \"my_package\" assert public_id.version == \"0.1.0\" another_public_id = PublicId(\"author\", \"my_package\", \"0.1.0\") assert hash(public_id) == hash(another_public_id) assert public_id == another_public_id __ init __ | __init__ ( author : str , name : str , version : str ) Initialize the public identifier. author | @property | author () Get the author. name | @property | name () Get the name. version | @property | version () Get the version. from _ str | @classmethod | from_str ( cls , public_id_string : str ) -> \"PublicId\" Initialize the public id from the string. str(PublicId.from_str(\"author/package_name:0.1.0\")) 'author/package_name:0.1.0' A bad formatted input raises value error: PublicId.from_str(\"bad/formatted:input\") Traceback (most recent call last): ... ValueError: Input 'bad/formatted:input' is not well formatted. Arguments : public_id_string : the public id in string format. Returns : the public id object. Raises : ValueError : if the string in input is not well formatted. from _ uri _ path | @classmethod | from_uri_path ( cls , public_id_uri_path : str ) -> \"PublicId\" Initialize the public id from the string. str(PublicId.from_uri_path(\"author/package_name/0.1.0\")) 'author/package_name:0.1.0' A bad formatted input raises value error: PublicId.from_uri_path(\"bad/formatted:input\") Traceback (most recent call last): ... ValueError: Input 'bad/formatted:input' is not well formatted. Arguments : public_id_uri_path : the public id in uri path string format. Returns : the public id object. Raises : ValueError : if the string in input is not well formatted. to _ uri _ path | @property | to_uri_path () -> str Turn the public id into a uri path string. Returns : uri path string json | @property | json () -> Dict Compute the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict ) Build from a JSON object. __ hash __ | __hash__ () Get the hash. __ str __ | __str__ () Get the string representation. __ eq __ | __eq__ ( other ) Compare with another object. __ lt __ | __lt__ ( other ) Compare two public ids. PackageConfiguration class PackageConfiguration ( Configuration , ABC ) This class represent a package configuration. __ init __ | __init__ ( name : str , author : str , version : str , license : str , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None ) Initialize a package configuration. public _ id | @property | public_id () -> PublicId Get the public id. ConnectionConfig class ConnectionConfig ( PackageConfiguration ) Handle connection configuration. __ init __ | __init__ ( name : str = \"\" , author : str = \"\" , version : str = \"\" , license : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , class_name : str = \"\" , protocols : Optional [ Set [ PublicId ]] = None , restricted_to_protocols : Optional [ Set [ PublicId ]] = None , excluded_protocols : Optional [ Set [ PublicId ]] = None , dependencies : Optional [ Dependencies ] = None , description : str = \"\" , ** config ) Initialize a connection configuration object. json | @property | json () -> Dict Return the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object. ProtocolConfig class ProtocolConfig ( PackageConfiguration ) Handle protocol configuration. __ init __ | __init__ ( name : str = \"\" , author : str = \"\" , version : str = \"\" , license : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , dependencies : Optional [ Dependencies ] = None , description : str = \"\" ) Initialize a connection configuration object. json | @property | json () -> Dict Return the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object. HandlerConfig class HandlerConfig ( Configuration ) Handle a skill handler configuration. __ init __ | __init__ ( class_name : str = \"\" , ** args ) Initialize a handler configuration. json | @property | json () -> Dict Return the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object. BehaviourConfig class BehaviourConfig ( Configuration ) Handle a skill behaviour configuration. __ init __ | __init__ ( class_name : str = \"\" , ** args ) Initialize a behaviour configuration. json | @property | json () -> Dict Return the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object. ModelConfig class ModelConfig ( Configuration ) Handle a skill model configuration. __ init __ | __init__ ( class_name : str = \"\" , ** args ) Initialize a model configuration. json | @property | json () -> Dict Return the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object. SkillConfig class SkillConfig ( PackageConfiguration ) Class to represent a skill configuration file. __ init __ | __init__ ( name : str = \"\" , author : str = \"\" , version : str = \"\" , license : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , aea_version : str = \"\" , protocols : List [ PublicId ] = None , dependencies : Optional [ Dependencies ] = None , description : str = \"\" ) Initialize a skill configuration. json | @property | json () -> Dict Return the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object. AgentConfig class AgentConfig ( PackageConfiguration ) Class to represent the agent configuration file. __ init __ | __init__ ( agent_name : str = \"\" , aea_version : str = \"\" , author : str = \"\" , version : str = \"\" , license : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , registry_path : str = \"\" , description : str = \"\" , logging_config : Optional [ Dict ] = None ) Instantiate the agent configuration object. private _ key _ paths _ dict | @property | private_key_paths_dict () -> Dict [ str , str ] Dictionary version of private key paths. ledger _ apis _ dict | @property | ledger_apis_dict () -> Dict [ str , Dict [ str , Union [ str , int ]]] Dictionary version of ledger apis. default _ connection | @default_connection . setter | default_connection ( connection_id : Optional [ Union [ str , PublicId ]]) Set the default connection. Arguments : connection_id : the name of the default connection. Returns : None default _ ledger | @default_ledger . setter | default_ledger ( ledger_id : str ) Set the default ledger. Arguments : ledger_id : the id of the default ledger. Returns : None json | @property | json () -> Dict Return the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object. SpeechActContentConfig class SpeechActContentConfig ( Configuration ) Handle a speech_act content configuration. __ init __ | __init__ ( ** args ) Initialize a speech_act content configuration. json | @property | json () -> Dict Return the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object. ProtocolSpecification class ProtocolSpecification ( ProtocolConfig ) Handle protocol specification. __ init __ | __init__ ( name : str = \"\" , author : str = \"\" , version : str = \"\" , license : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , description : str = \"\" ) Initialize a protocol specification configuration object. protobuf _ snippets | @protobuf_snippets . setter | protobuf_snippets ( protobuf_snippets : Optional [ Dict ]) Set the protobuf snippets. json | @property | json () -> Dict Return the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object.","title":"Base"},{"location":"aea/api/configurations/base/#aeaconfigurationsbase","text":"Classes to handle AEA configurations.","title":"aea.configurations.base"},{"location":"aea/api/configurations/base/#dependency","text":"A dependency is a dictionary with the following (optional) keys: - version: a version specifier(s) (e.g. '==0.1.0'). - index: the PyPI index where to download the package from (default: https://pypi.org) - git: the URL to the Git repository (e.g. https://github.com/fetchai/agents-aea.git) - ref: either the branch name, the tag, the commit number or a Git reference (default: 'master'.) If the 'git' field is set, the 'version' field will be ignored. They are supposed to be forwarded to the 'pip' command.","title":"Dependency"},{"location":"aea/api/configurations/base/#dependencies","text":"A dictionary from package name to dependency data structure (see above). The package name must satisfy the constraints on Python packages names. For details, see https://www.python.org/dev/peps/pep-0426/ name . The main advantage of having a dictionary is that we implicitly filter out dependency duplicates. We cannot have two items with the same package name since the keys of a YAML object form a set.","title":"Dependencies"},{"location":"aea/api/configurations/base/#configurationtype","text":"class ConfigurationType ( Enum ) Configuration types.","title":"ConfigurationType"},{"location":"aea/api/configurations/base/#protocolspecificationparseerror","text":"class ProtocolSpecificationParseError ( Exception ) Exception for parsing a protocol specification file.","title":"ProtocolSpecificationParseError"},{"location":"aea/api/configurations/base/#jsonserializable","text":"class JSONSerializable ( ABC ) Interface for JSON-serializable objects.","title":"JSONSerializable"},{"location":"aea/api/configurations/base/#json","text":"| @property | @abstractmethod | json () -> Dict Compute the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#from_json","text":"| @classmethod | from_json ( cls , obj : Dict ) Build from a JSON object.","title":"from_json"},{"location":"aea/api/configurations/base/#configuration","text":"class Configuration ( JSONSerializable , ABC ) Configuration class.","title":"Configuration"},{"location":"aea/api/configurations/base/#crudcollection","text":"class CRUDCollection ( Generic [ T ]) Interface of a CRUD collection.","title":"CRUDCollection"},{"location":"aea/api/configurations/base/#__init__","text":"| __init__ () Instantiate a CRUD collection.","title":"__init__"},{"location":"aea/api/configurations/base/#create","text":"| create ( item_id : str , item : T ) -> None Add an item. Arguments : item_id : the item id. item : the item to be added. Returns : None Raises : ValueError : if the item with the same id is already in the collection.","title":"create"},{"location":"aea/api/configurations/base/#read","text":"| read ( item_id : str ) -> Optional [ T ] Get an item by its name. Arguments : item_id : the item id. Returns : the associated item, or None if the item id is not present.","title":"read"},{"location":"aea/api/configurations/base/#update","text":"| update ( item_id : str , item : T ) -> None Update an existing item. Arguments : item_id : the item id. item : the item to be added. Returns : None","title":"update"},{"location":"aea/api/configurations/base/#delete","text":"| delete ( item_id : str ) -> None Delete an item.","title":"delete"},{"location":"aea/api/configurations/base/#read_all","text":"| read_all () -> List [ Tuple [ str , T ]] Read all the items.","title":"read_all"},{"location":"aea/api/configurations/base/#publicid","text":"class PublicId ( JSONSerializable ) This class implement a public identifier. A public identifier is composed of three elements: - author - name - version The concatenation of those three elements gives the public identifier: author/name:version public_id = PublicId(\"author\", \"my_package\", \"0.1.0\") assert public_id.author == \"author\" assert public_id.name == \"my_package\" assert public_id.version == \"0.1.0\" another_public_id = PublicId(\"author\", \"my_package\", \"0.1.0\") assert hash(public_id) == hash(another_public_id) assert public_id == another_public_id","title":"PublicId"},{"location":"aea/api/configurations/base/#__init___1","text":"| __init__ ( author : str , name : str , version : str ) Initialize the public identifier.","title":"__init__"},{"location":"aea/api/configurations/base/#author","text":"| @property | author () Get the author.","title":"author"},{"location":"aea/api/configurations/base/#name","text":"| @property | name () Get the name.","title":"name"},{"location":"aea/api/configurations/base/#version","text":"| @property | version () Get the version.","title":"version"},{"location":"aea/api/configurations/base/#from_str","text":"| @classmethod | from_str ( cls , public_id_string : str ) -> \"PublicId\" Initialize the public id from the string. str(PublicId.from_str(\"author/package_name:0.1.0\")) 'author/package_name:0.1.0' A bad formatted input raises value error: PublicId.from_str(\"bad/formatted:input\") Traceback (most recent call last): ... ValueError: Input 'bad/formatted:input' is not well formatted. Arguments : public_id_string : the public id in string format. Returns : the public id object. Raises : ValueError : if the string in input is not well formatted.","title":"from_str"},{"location":"aea/api/configurations/base/#from_uri_path","text":"| @classmethod | from_uri_path ( cls , public_id_uri_path : str ) -> \"PublicId\" Initialize the public id from the string. str(PublicId.from_uri_path(\"author/package_name/0.1.0\")) 'author/package_name:0.1.0' A bad formatted input raises value error: PublicId.from_uri_path(\"bad/formatted:input\") Traceback (most recent call last): ... ValueError: Input 'bad/formatted:input' is not well formatted. Arguments : public_id_uri_path : the public id in uri path string format. Returns : the public id object. Raises : ValueError : if the string in input is not well formatted.","title":"from_uri_path"},{"location":"aea/api/configurations/base/#to_uri_path","text":"| @property | to_uri_path () -> str Turn the public id into a uri path string. Returns : uri path string","title":"to_uri_path"},{"location":"aea/api/configurations/base/#json_1","text":"| @property | json () -> Dict Compute the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#from_json_1","text":"| @classmethod | from_json ( cls , obj : Dict ) Build from a JSON object.","title":"from_json"},{"location":"aea/api/configurations/base/#__hash__","text":"| __hash__ () Get the hash.","title":"__hash__"},{"location":"aea/api/configurations/base/#__str__","text":"| __str__ () Get the string representation.","title":"__str__"},{"location":"aea/api/configurations/base/#__eq__","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/configurations/base/#__lt__","text":"| __lt__ ( other ) Compare two public ids.","title":"__lt__"},{"location":"aea/api/configurations/base/#packageconfiguration","text":"class PackageConfiguration ( Configuration , ABC ) This class represent a package configuration.","title":"PackageConfiguration"},{"location":"aea/api/configurations/base/#__init___2","text":"| __init__ ( name : str , author : str , version : str , license : str , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None ) Initialize a package configuration.","title":"__init__"},{"location":"aea/api/configurations/base/#public_id","text":"| @property | public_id () -> PublicId Get the public id.","title":"public_id"},{"location":"aea/api/configurations/base/#connectionconfig","text":"class ConnectionConfig ( PackageConfiguration ) Handle connection configuration.","title":"ConnectionConfig"},{"location":"aea/api/configurations/base/#__init___3","text":"| __init__ ( name : str = \"\" , author : str = \"\" , version : str = \"\" , license : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , class_name : str = \"\" , protocols : Optional [ Set [ PublicId ]] = None , restricted_to_protocols : Optional [ Set [ PublicId ]] = None , excluded_protocols : Optional [ Set [ PublicId ]] = None , dependencies : Optional [ Dependencies ] = None , description : str = \"\" , ** config ) Initialize a connection configuration object.","title":"__init__"},{"location":"aea/api/configurations/base/#json_2","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#from_json_2","text":"| @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object.","title":"from_json"},{"location":"aea/api/configurations/base/#protocolconfig","text":"class ProtocolConfig ( PackageConfiguration ) Handle protocol configuration.","title":"ProtocolConfig"},{"location":"aea/api/configurations/base/#__init___4","text":"| __init__ ( name : str = \"\" , author : str = \"\" , version : str = \"\" , license : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , dependencies : Optional [ Dependencies ] = None , description : str = \"\" ) Initialize a connection configuration object.","title":"__init__"},{"location":"aea/api/configurations/base/#json_3","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#from_json_3","text":"| @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object.","title":"from_json"},{"location":"aea/api/configurations/base/#handlerconfig","text":"class HandlerConfig ( Configuration ) Handle a skill handler configuration.","title":"HandlerConfig"},{"location":"aea/api/configurations/base/#__init___5","text":"| __init__ ( class_name : str = \"\" , ** args ) Initialize a handler configuration.","title":"__init__"},{"location":"aea/api/configurations/base/#json_4","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#from_json_4","text":"| @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object.","title":"from_json"},{"location":"aea/api/configurations/base/#behaviourconfig","text":"class BehaviourConfig ( Configuration ) Handle a skill behaviour configuration.","title":"BehaviourConfig"},{"location":"aea/api/configurations/base/#__init___6","text":"| __init__ ( class_name : str = \"\" , ** args ) Initialize a behaviour configuration.","title":"__init__"},{"location":"aea/api/configurations/base/#json_5","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#from_json_5","text":"| @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object.","title":"from_json"},{"location":"aea/api/configurations/base/#modelconfig","text":"class ModelConfig ( Configuration ) Handle a skill model configuration.","title":"ModelConfig"},{"location":"aea/api/configurations/base/#__init___7","text":"| __init__ ( class_name : str = \"\" , ** args ) Initialize a model configuration.","title":"__init__"},{"location":"aea/api/configurations/base/#json_6","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#from_json_6","text":"| @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object.","title":"from_json"},{"location":"aea/api/configurations/base/#skillconfig","text":"class SkillConfig ( PackageConfiguration ) Class to represent a skill configuration file.","title":"SkillConfig"},{"location":"aea/api/configurations/base/#__init___8","text":"| __init__ ( name : str = \"\" , author : str = \"\" , version : str = \"\" , license : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , aea_version : str = \"\" , protocols : List [ PublicId ] = None , dependencies : Optional [ Dependencies ] = None , description : str = \"\" ) Initialize a skill configuration.","title":"__init__"},{"location":"aea/api/configurations/base/#json_7","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#from_json_7","text":"| @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object.","title":"from_json"},{"location":"aea/api/configurations/base/#agentconfig","text":"class AgentConfig ( PackageConfiguration ) Class to represent the agent configuration file.","title":"AgentConfig"},{"location":"aea/api/configurations/base/#__init___9","text":"| __init__ ( agent_name : str = \"\" , aea_version : str = \"\" , author : str = \"\" , version : str = \"\" , license : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , registry_path : str = \"\" , description : str = \"\" , logging_config : Optional [ Dict ] = None ) Instantiate the agent configuration object.","title":"__init__"},{"location":"aea/api/configurations/base/#private_key_paths_dict","text":"| @property | private_key_paths_dict () -> Dict [ str , str ] Dictionary version of private key paths.","title":"private_key_paths_dict"},{"location":"aea/api/configurations/base/#ledger_apis_dict","text":"| @property | ledger_apis_dict () -> Dict [ str , Dict [ str , Union [ str , int ]]] Dictionary version of ledger apis.","title":"ledger_apis_dict"},{"location":"aea/api/configurations/base/#default_connection","text":"| @default_connection . setter | default_connection ( connection_id : Optional [ Union [ str , PublicId ]]) Set the default connection. Arguments : connection_id : the name of the default connection. Returns : None","title":"default_connection"},{"location":"aea/api/configurations/base/#default_ledger","text":"| @default_ledger . setter | default_ledger ( ledger_id : str ) Set the default ledger. Arguments : ledger_id : the id of the default ledger. Returns : None","title":"default_ledger"},{"location":"aea/api/configurations/base/#json_8","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#from_json_8","text":"| @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object.","title":"from_json"},{"location":"aea/api/configurations/base/#speechactcontentconfig","text":"class SpeechActContentConfig ( Configuration ) Handle a speech_act content configuration.","title":"SpeechActContentConfig"},{"location":"aea/api/configurations/base/#__init___10","text":"| __init__ ( ** args ) Initialize a speech_act content configuration.","title":"__init__"},{"location":"aea/api/configurations/base/#json_9","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#from_json_9","text":"| @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object.","title":"from_json"},{"location":"aea/api/configurations/base/#protocolspecification","text":"class ProtocolSpecification ( ProtocolConfig ) Handle protocol specification.","title":"ProtocolSpecification"},{"location":"aea/api/configurations/base/#__init___11","text":"| __init__ ( name : str = \"\" , author : str = \"\" , version : str = \"\" , license : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , description : str = \"\" ) Initialize a protocol specification configuration object.","title":"__init__"},{"location":"aea/api/configurations/base/#protobuf_snippets","text":"| @protobuf_snippets . setter | protobuf_snippets ( protobuf_snippets : Optional [ Dict ]) Set the protobuf snippets.","title":"protobuf_snippets"},{"location":"aea/api/configurations/base/#json_10","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#from_json_10","text":"| @classmethod | from_json ( cls , obj : Dict ) Initialize from a JSON object.","title":"from_json"},{"location":"aea/api/configurations/loader/","text":"aea.configurations.loader Implementation of the parser for configuration file. ConfigLoader class ConfigLoader ( Generic [ T ]) This class implement parsing, serialization and validation functionalities for the 'aea' configuration files. __ init __ | __init__ ( schema_filename : str , configuration_type : Type [ T ]) Initialize the parser for configuration files. Arguments : schema_filename : the path to the JSON-schema file in 'aea/configurations/schemas'. configuration_type : load _ protocol _ specification | load_protocol_specification ( file_pointer : TextIO ) -> T Load an agent configuration file. Arguments : file_pointer : the file pointer to the configuration file Returns : the configuration object. :raises load | load ( file_pointer : TextIO ) -> T Load an agent configuration file. Arguments : file_pointer : the file pointer to the configuration file Returns : the configuration object. :raises dump | dump ( configuration : T , file_pointer : TextIO ) -> None Dump a configuration. Arguments : configuration : the configuration to be dumped. file_pointer : the file pointer to the configuration file Returns : None from _ configuration _ type | @classmethod | from_configuration_type ( cls , configuration_type : Union [ ConfigurationType , str ]) -> \"ConfigLoader\" Get the configuration loader from the type.","title":"Loader"},{"location":"aea/api/configurations/loader/#aeaconfigurationsloader","text":"Implementation of the parser for configuration file.","title":"aea.configurations.loader"},{"location":"aea/api/configurations/loader/#configloader","text":"class ConfigLoader ( Generic [ T ]) This class implement parsing, serialization and validation functionalities for the 'aea' configuration files.","title":"ConfigLoader"},{"location":"aea/api/configurations/loader/#__init__","text":"| __init__ ( schema_filename : str , configuration_type : Type [ T ]) Initialize the parser for configuration files. Arguments : schema_filename : the path to the JSON-schema file in 'aea/configurations/schemas'. configuration_type :","title":"__init__"},{"location":"aea/api/configurations/loader/#load_protocol_specification","text":"| load_protocol_specification ( file_pointer : TextIO ) -> T Load an agent configuration file. Arguments : file_pointer : the file pointer to the configuration file Returns : the configuration object. :raises","title":"load_protocol_specification"},{"location":"aea/api/configurations/loader/#load","text":"| load ( file_pointer : TextIO ) -> T Load an agent configuration file. Arguments : file_pointer : the file pointer to the configuration file Returns : the configuration object. :raises","title":"load"},{"location":"aea/api/configurations/loader/#dump","text":"| dump ( configuration : T , file_pointer : TextIO ) -> None Dump a configuration. Arguments : configuration : the configuration to be dumped. file_pointer : the file pointer to the configuration file Returns : None","title":"dump"},{"location":"aea/api/configurations/loader/#from_configuration_type","text":"| @classmethod | from_configuration_type ( cls , configuration_type : Union [ ConfigurationType , str ]) -> \"ConfigLoader\" Get the configuration loader from the type.","title":"from_configuration_type"},{"location":"aea/api/connections/base/","text":"aea.connections.base The base connection package. ConnectionStatus class ConnectionStatus () The connection status class. __ init __ | __init__ () Initialize the connection status. Connection class Connection ( ABC ) Abstract definition of a connection. __ init __ | __init__ ( connection_id : Optional [ PublicId ] = None , restricted_to_protocols : Optional [ Set [ PublicId ]] = None , excluded_protocols : Optional [ Set [ PublicId ]] = None ) Initialize the connection. Arguments : connection_id : the connection identifier. restricted_to_protocols : the set of protocols ids of the only supported protocols for this connection. excluded_protocols : the set of protocols ids that we want to exclude for this connection. loop | @loop . setter | loop ( loop : AbstractEventLoop ) -> None Set the event loop. Arguments : loop : the event loop. Returns : None connection _ id | @property | connection_id () -> PublicId Get the id of the connection. restricted _ to _ protocols | @property | restricted_to_protocols () -> Set [ PublicId ] Get the restricted to protocols.. excluded _ protocols | @property | excluded_protocols () -> Set [ PublicId ] Get the restricted to protocols.. connection _ status | @property | connection_status () -> ConnectionStatus Get the connection status. connect | @abstractmethod | async connect () Set up the connection. disconnect | @abstractmethod | async disconnect () Tear down the connection. send | @abstractmethod | async send ( envelope : \"Envelope\" ) -> None Send an envelope. Arguments : envelope : the envelope to send. Returns : None receive | @abstractmethod | async receive ( * args , ** kwargs ) -> Optional [ \"Envelope\" ] Receive an envelope. Returns : the received envelope, or None if an error occurred. from _ config | @classmethod | @abstractmethod | from_config ( cls , address : \"Address\" , connection_configuration : ConnectionConfig ) -> \"Connection\" Initialize a connection instance from a configuration. Arguments : address : the address of the agent. connection_configuration : the connection configuration. Returns : an instance of the concrete connection class.","title":"Base"},{"location":"aea/api/connections/base/#aeaconnectionsbase","text":"The base connection package.","title":"aea.connections.base"},{"location":"aea/api/connections/base/#connectionstatus","text":"class ConnectionStatus () The connection status class.","title":"ConnectionStatus"},{"location":"aea/api/connections/base/#__init__","text":"| __init__ () Initialize the connection status.","title":"__init__"},{"location":"aea/api/connections/base/#connection","text":"class Connection ( ABC ) Abstract definition of a connection.","title":"Connection"},{"location":"aea/api/connections/base/#__init___1","text":"| __init__ ( connection_id : Optional [ PublicId ] = None , restricted_to_protocols : Optional [ Set [ PublicId ]] = None , excluded_protocols : Optional [ Set [ PublicId ]] = None ) Initialize the connection. Arguments : connection_id : the connection identifier. restricted_to_protocols : the set of protocols ids of the only supported protocols for this connection. excluded_protocols : the set of protocols ids that we want to exclude for this connection.","title":"__init__"},{"location":"aea/api/connections/base/#loop","text":"| @loop . setter | loop ( loop : AbstractEventLoop ) -> None Set the event loop. Arguments : loop : the event loop. Returns : None","title":"loop"},{"location":"aea/api/connections/base/#connection_id","text":"| @property | connection_id () -> PublicId Get the id of the connection.","title":"connection_id"},{"location":"aea/api/connections/base/#restricted_to_protocols","text":"| @property | restricted_to_protocols () -> Set [ PublicId ] Get the restricted to protocols..","title":"restricted_to_protocols"},{"location":"aea/api/connections/base/#excluded_protocols","text":"| @property | excluded_protocols () -> Set [ PublicId ] Get the restricted to protocols..","title":"excluded_protocols"},{"location":"aea/api/connections/base/#connection_status","text":"| @property | connection_status () -> ConnectionStatus Get the connection status.","title":"connection_status"},{"location":"aea/api/connections/base/#connect","text":"| @abstractmethod | async connect () Set up the connection.","title":"connect"},{"location":"aea/api/connections/base/#disconnect","text":"| @abstractmethod | async disconnect () Tear down the connection.","title":"disconnect"},{"location":"aea/api/connections/base/#send","text":"| @abstractmethod | async send ( envelope : \"Envelope\" ) -> None Send an envelope. Arguments : envelope : the envelope to send. Returns : None","title":"send"},{"location":"aea/api/connections/base/#receive","text":"| @abstractmethod | async receive ( * args , ** kwargs ) -> Optional [ \"Envelope\" ] Receive an envelope. Returns : the received envelope, or None if an error occurred.","title":"receive"},{"location":"aea/api/connections/base/#from_config","text":"| @classmethod | @abstractmethod | from_config ( cls , address : \"Address\" , connection_configuration : ConnectionConfig ) -> \"Connection\" Initialize a connection instance from a configuration. Arguments : address : the address of the agent. connection_configuration : the connection configuration. Returns : an instance of the concrete connection class.","title":"from_config"},{"location":"aea/api/connections/stub/connection/","text":"aea.connections.stub.connection This module contains the stub connection. __ init __ | __init__ ( input_file_path : Union [ str , Path ], output_file_path : Union [ str , Path ], * args , ** kwargs ) Initialize a stub connection. Arguments : input_file_path : the input file for the incoming messages. output_file_path : the output file for the outgoing messages. connection_id : the identifier of the connection object. restricted_to_protocols : the only supported protocols for this connection. excluded_protocols : the set of protocols ids that we want to exclude for this connection. read _ envelopes | read_envelopes () -> None Receive new envelopes, if any. receive | async receive ( * args , ** kwargs ) -> Optional [ \"Envelope\" ] Receive an envelope. connect | async connect () -> None Set up the connection. disconnect | async disconnect () -> None Disconnect from the channel. In this type of connection there's no channel to disconnect. send | async send ( envelope : Envelope ) Send messages. Returns : None from _ config | @classmethod | from_config ( cls , address : Address , connection_configuration : ConnectionConfig ) -> \"Connection\" Get the OEF connection from the connection configuration. Arguments : address : the address of the agent. connection_configuration : the connection configuration object. Returns : the connection object","title":"Stub Connection"},{"location":"aea/api/connections/stub/connection/#aeaconnectionsstubconnection","text":"This module contains the stub connection.","title":"aea.connections.stub.connection"},{"location":"aea/api/connections/stub/connection/#__init__","text":"| __init__ ( input_file_path : Union [ str , Path ], output_file_path : Union [ str , Path ], * args , ** kwargs ) Initialize a stub connection. Arguments : input_file_path : the input file for the incoming messages. output_file_path : the output file for the outgoing messages. connection_id : the identifier of the connection object. restricted_to_protocols : the only supported protocols for this connection. excluded_protocols : the set of protocols ids that we want to exclude for this connection.","title":"__init__"},{"location":"aea/api/connections/stub/connection/#read_envelopes","text":"| read_envelopes () -> None Receive new envelopes, if any.","title":"read_envelopes"},{"location":"aea/api/connections/stub/connection/#receive","text":"| async receive ( * args , ** kwargs ) -> Optional [ \"Envelope\" ] Receive an envelope.","title":"receive"},{"location":"aea/api/connections/stub/connection/#connect","text":"| async connect () -> None Set up the connection.","title":"connect"},{"location":"aea/api/connections/stub/connection/#disconnect","text":"| async disconnect () -> None Disconnect from the channel. In this type of connection there's no channel to disconnect.","title":"disconnect"},{"location":"aea/api/connections/stub/connection/#send","text":"| async send ( envelope : Envelope ) Send messages. Returns : None","title":"send"},{"location":"aea/api/connections/stub/connection/#from_config","text":"| @classmethod | from_config ( cls , address : Address , connection_configuration : ConnectionConfig ) -> \"Connection\" Get the OEF connection from the connection configuration. Arguments : address : the address of the agent. connection_configuration : the connection configuration object. Returns : the connection object","title":"from_config"},{"location":"aea/api/context/base/","text":"aea.context.base This module contains the agent context class. AgentContext class AgentContext () Provide read access to relevant data of the agent for the skills. __ init __ | __init__ ( identity : Identity , ledger_apis : LedgerApis , connection_status : ConnectionStatus , outbox : OutBox , decision_maker_message_queue : Queue , ownership_state : OwnershipState , preferences : Preferences , goal_pursuit_readiness : GoalPursuitReadiness , task_manager : TaskManager ) Initialize an agent context. Arguments : identity : the identity object ledger_apis : the ledger apis connection_status : the connection status outbox : the outbox decision_maker_message_queue : the (in) queue of the decision maker ownership_state : the ownership state of the agent preferences : the preferences of the agent goal_pursuit_readiness : ready to pursuit its goals task_manager : the task manager shared _ state | @property | shared_state () -> Dict [ str , Any ] Get the shared state dictionary. identity | @property | identity () -> Identity Get the identity. agent _ name | @property | agent_name () -> str Get agent name. addresses | @property | addresses () -> Dict [ str , Address ] Get addresses. address | @property | address () -> Address Get the default address. connection _ status | @property | connection_status () -> ConnectionStatus Get connection status. outbox | @property | outbox () -> OutBox Get outbox. decision _ maker _ message _ queue | @property | decision_maker_message_queue () -> Queue Get decision maker queue. ownership _ state | @property | ownership_state () -> OwnershipState Get the ownership state of the agent. preferences | @property | preferences () -> Preferences Get the preferences of the agent. goal _ pursuit _ readiness | @property | goal_pursuit_readiness () -> GoalPursuitReadiness Get the goal pursuit readiness. ledger _ apis | @property | ledger_apis () -> LedgerApis Get the ledger APIs. task _ manager | @property | task_manager () -> TaskManager Get the task manager. search _ service _ address | @property | search_service_address () -> Address Get the address of the search service.","title":"Context"},{"location":"aea/api/context/base/#aeacontextbase","text":"This module contains the agent context class.","title":"aea.context.base"},{"location":"aea/api/context/base/#agentcontext","text":"class AgentContext () Provide read access to relevant data of the agent for the skills.","title":"AgentContext"},{"location":"aea/api/context/base/#__init__","text":"| __init__ ( identity : Identity , ledger_apis : LedgerApis , connection_status : ConnectionStatus , outbox : OutBox , decision_maker_message_queue : Queue , ownership_state : OwnershipState , preferences : Preferences , goal_pursuit_readiness : GoalPursuitReadiness , task_manager : TaskManager ) Initialize an agent context. Arguments : identity : the identity object ledger_apis : the ledger apis connection_status : the connection status outbox : the outbox decision_maker_message_queue : the (in) queue of the decision maker ownership_state : the ownership state of the agent preferences : the preferences of the agent goal_pursuit_readiness : ready to pursuit its goals task_manager : the task manager","title":"__init__"},{"location":"aea/api/context/base/#shared_state","text":"| @property | shared_state () -> Dict [ str , Any ] Get the shared state dictionary.","title":"shared_state"},{"location":"aea/api/context/base/#identity","text":"| @property | identity () -> Identity Get the identity.","title":"identity"},{"location":"aea/api/context/base/#agent_name","text":"| @property | agent_name () -> str Get agent name.","title":"agent_name"},{"location":"aea/api/context/base/#addresses","text":"| @property | addresses () -> Dict [ str , Address ] Get addresses.","title":"addresses"},{"location":"aea/api/context/base/#address","text":"| @property | address () -> Address Get the default address.","title":"address"},{"location":"aea/api/context/base/#connection_status","text":"| @property | connection_status () -> ConnectionStatus Get connection status.","title":"connection_status"},{"location":"aea/api/context/base/#outbox","text":"| @property | outbox () -> OutBox Get outbox.","title":"outbox"},{"location":"aea/api/context/base/#decision_maker_message_queue","text":"| @property | decision_maker_message_queue () -> Queue Get decision maker queue.","title":"decision_maker_message_queue"},{"location":"aea/api/context/base/#ownership_state","text":"| @property | ownership_state () -> OwnershipState Get the ownership state of the agent.","title":"ownership_state"},{"location":"aea/api/context/base/#preferences","text":"| @property | preferences () -> Preferences Get the preferences of the agent.","title":"preferences"},{"location":"aea/api/context/base/#goal_pursuit_readiness","text":"| @property | goal_pursuit_readiness () -> GoalPursuitReadiness Get the goal pursuit readiness.","title":"goal_pursuit_readiness"},{"location":"aea/api/context/base/#ledger_apis","text":"| @property | ledger_apis () -> LedgerApis Get the ledger APIs.","title":"ledger_apis"},{"location":"aea/api/context/base/#task_manager","text":"| @property | task_manager () -> TaskManager Get the task manager.","title":"task_manager"},{"location":"aea/api/context/base/#search_service_address","text":"| @property | search_service_address () -> Address Get the address of the search service.","title":"search_service_address"},{"location":"aea/api/crypto/ethereum/","text":"aea.crypto.ethereum Ethereum module wrapping the public and private key cryptography and ledger api. EthereumCrypto class EthereumCrypto ( Crypto ) Class wrapping the Account Generation from Ethereum ledger. __ init __ | __init__ ( private_key_path : Optional [ str ] = None ) Instantiate an ethereum crypto object. Arguments : private_key_path : the private key path of the agent entity | @property | entity () -> Account Get the entity. public _ key | @property | public_key () -> str Return a public key in hex format. Returns : a public key string in hex format address | @property | address () -> str Return the address for the key pair. Returns : a display_address str sign _ message | sign_message ( message : bytes ) -> bytes Sign a message in bytes string form. Arguments : message : the message we want to send Returns : Signed message in bytes recover _ message | recover_message ( message : bytes , signature : bytes ) -> Address Recover the address from the hash. Arguments : message : the message we expect signature : the transaction signature Returns : the recovered address get _ address _ from _ public _ key | @classmethod | get_address_from_public_key ( cls , public_key : str ) -> str Get the address from the public key. Arguments : public_key : the public key Returns : str load | @classmethod | load ( cls , fp : BinaryIO ) Deserialize binary file fp (a .read() -supporting file-like object containing a private key). Arguments : fp : the input file pointer. Must be set in binary mode (mode='rb') Returns : None dump | dump ( fp : BinaryIO ) -> None Serialize crypto object as binary stream to fp (a .write() -supporting file-like object). Arguments : fp : the output file pointer. Must be set in binary mode (mode='wb') Returns : None EthereumApi class EthereumApi ( LedgerApi ) Class to interact with the Ethereum Web3 APIs. __ init __ | __init__ ( address : str , gas_price : str = DEFAULT_GAS_PRICE ) Initialize the Ethereum ledger APIs. Arguments : address : the endpoint for Web3 APIs. api | @property | api () -> Web3 Get the underlying API object. get _ balance | get_balance ( address : AddressLike ) -> int Get the balance of a given account. send _ transaction | send_transaction ( crypto : Crypto , destination_address : AddressLike , amount : int , tx_fee : int , tx_nonce : str , chain_id : int = 3 , ** kwargs ) -> Optional [ str ] Submit a transaction to the ledger. Arguments : tx_nonce : verifies the authenticity of the tx crypto : the crypto object associated to the payer. destination_address : the destination address of the payee. amount : the amount of wealth to be transferred. tx_fee : the transaction fee. chain_id : the Chain ID of the Ethereum transaction. Default is 1 (i.e. mainnet). Returns : the transaction digest, or None if not available. is _ transaction _ settled | is_transaction_settled ( tx_digest : str ) -> bool Check whether a transaction is settled or not. generate _ tx _ nonce | generate_tx_nonce ( seller : Address , client : Address ) -> str Generate a unique hash to distinguish txs with the same terms. Arguments : seller : the address of the seller. client : the address of the client. Returns : return the hash in hex. validate _ transaction | validate_transaction ( tx_digest : str , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether a transaction is valid or not. Arguments : seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. tx_digest : the transaction digest. Returns : True if the random_message is equals to tx['input']","title":"Ethereum"},{"location":"aea/api/crypto/ethereum/#aeacryptoethereum","text":"Ethereum module wrapping the public and private key cryptography and ledger api.","title":"aea.crypto.ethereum"},{"location":"aea/api/crypto/ethereum/#ethereumcrypto","text":"class EthereumCrypto ( Crypto ) Class wrapping the Account Generation from Ethereum ledger.","title":"EthereumCrypto"},{"location":"aea/api/crypto/ethereum/#__init__","text":"| __init__ ( private_key_path : Optional [ str ] = None ) Instantiate an ethereum crypto object. Arguments : private_key_path : the private key path of the agent","title":"__init__"},{"location":"aea/api/crypto/ethereum/#entity","text":"| @property | entity () -> Account Get the entity.","title":"entity"},{"location":"aea/api/crypto/ethereum/#public_key","text":"| @property | public_key () -> str Return a public key in hex format. Returns : a public key string in hex format","title":"public_key"},{"location":"aea/api/crypto/ethereum/#address","text":"| @property | address () -> str Return the address for the key pair. Returns : a display_address str","title":"address"},{"location":"aea/api/crypto/ethereum/#sign_message","text":"| sign_message ( message : bytes ) -> bytes Sign a message in bytes string form. Arguments : message : the message we want to send Returns : Signed message in bytes","title":"sign_message"},{"location":"aea/api/crypto/ethereum/#recover_message","text":"| recover_message ( message : bytes , signature : bytes ) -> Address Recover the address from the hash. Arguments : message : the message we expect signature : the transaction signature Returns : the recovered address","title":"recover_message"},{"location":"aea/api/crypto/ethereum/#get_address_from_public_key","text":"| @classmethod | get_address_from_public_key ( cls , public_key : str ) -> str Get the address from the public key. Arguments : public_key : the public key Returns : str","title":"get_address_from_public_key"},{"location":"aea/api/crypto/ethereum/#load","text":"| @classmethod | load ( cls , fp : BinaryIO ) Deserialize binary file fp (a .read() -supporting file-like object containing a private key). Arguments : fp : the input file pointer. Must be set in binary mode (mode='rb') Returns : None","title":"load"},{"location":"aea/api/crypto/ethereum/#dump","text":"| dump ( fp : BinaryIO ) -> None Serialize crypto object as binary stream to fp (a .write() -supporting file-like object). Arguments : fp : the output file pointer. Must be set in binary mode (mode='wb') Returns : None","title":"dump"},{"location":"aea/api/crypto/ethereum/#ethereumapi","text":"class EthereumApi ( LedgerApi ) Class to interact with the Ethereum Web3 APIs.","title":"EthereumApi"},{"location":"aea/api/crypto/ethereum/#__init___1","text":"| __init__ ( address : str , gas_price : str = DEFAULT_GAS_PRICE ) Initialize the Ethereum ledger APIs. Arguments : address : the endpoint for Web3 APIs.","title":"__init__"},{"location":"aea/api/crypto/ethereum/#api","text":"| @property | api () -> Web3 Get the underlying API object.","title":"api"},{"location":"aea/api/crypto/ethereum/#get_balance","text":"| get_balance ( address : AddressLike ) -> int Get the balance of a given account.","title":"get_balance"},{"location":"aea/api/crypto/ethereum/#send_transaction","text":"| send_transaction ( crypto : Crypto , destination_address : AddressLike , amount : int , tx_fee : int , tx_nonce : str , chain_id : int = 3 , ** kwargs ) -> Optional [ str ] Submit a transaction to the ledger. Arguments : tx_nonce : verifies the authenticity of the tx crypto : the crypto object associated to the payer. destination_address : the destination address of the payee. amount : the amount of wealth to be transferred. tx_fee : the transaction fee. chain_id : the Chain ID of the Ethereum transaction. Default is 1 (i.e. mainnet). Returns : the transaction digest, or None if not available.","title":"send_transaction"},{"location":"aea/api/crypto/ethereum/#is_transaction_settled","text":"| is_transaction_settled ( tx_digest : str ) -> bool Check whether a transaction is settled or not.","title":"is_transaction_settled"},{"location":"aea/api/crypto/ethereum/#generate_tx_nonce","text":"| generate_tx_nonce ( seller : Address , client : Address ) -> str Generate a unique hash to distinguish txs with the same terms. Arguments : seller : the address of the seller. client : the address of the client. Returns : return the hash in hex.","title":"generate_tx_nonce"},{"location":"aea/api/crypto/ethereum/#validate_transaction","text":"| validate_transaction ( tx_digest : str , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether a transaction is valid or not. Arguments : seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. tx_digest : the transaction digest. Returns : True if the random_message is equals to tx['input']","title":"validate_transaction"},{"location":"aea/api/crypto/fetchai/","text":"aea.crypto.fetchai Fetchai module wrapping the public and private key cryptography and ledger api. FetchAICrypto class FetchAICrypto ( Crypto ) Class wrapping the Entity Generation from Fetch.AI ledger. __ init __ | __init__ ( private_key_path : Optional [ str ] = None ) Instantiate a fetchai crypto object. Arguments : private_key_path : the private key path of the agent entity | @property | entity () -> Entity Get the entity. public _ key | @property | public_key () -> str Return a public key in hex format. Returns : a public key string in hex format address | @property | address () -> str Return the address for the key pair. Returns : a display_address str sign _ message | sign_message ( message : bytes ) -> bytes Sign a message in bytes string form. Arguments : message : the message we want to send Returns : Signed message in bytes recover _ message | recover_message ( message : bytes , signature : bytes ) -> Address Recover the address from the hash. Arguments : message : the message we expect signature : the transaction signature Returns : the recovered address get _ address _ from _ public _ key | @classmethod | get_address_from_public_key ( cls , public_key : str ) -> Address Get the address from the public key. Arguments : public_key : the public key Returns : str load | @classmethod | load ( cls , fp : BinaryIO ) Deserialize binary file fp (a .read() -supporting file-like object containing a private key). Arguments : fp : the input file pointer. Must be set in binary mode (mode='rb') Returns : None dump | dump ( fp : BinaryIO ) -> None Serialize crypto object as binary stream to fp (a .write() -supporting file-like object). Arguments : fp : the output file pointer. Must be set in binary mode (mode='wb') Returns : None FetchAIApi class FetchAIApi ( LedgerApi ) Class to interact with the Fetch ledger APIs. __ init __ | __init__ ( ** kwargs ) Initialize the Fetch.AI ledger APIs. Arguments : kwargs : key word arguments (expects either a pair of 'host' and 'port' or a 'network') api | @property | api () -> FetchaiLedgerApi Get the underlying API object. get _ balance | get_balance ( address : AddressLike ) -> int Get the balance of a given account. send _ transaction | send_transaction ( crypto : Crypto , destination_address : AddressLike , amount : int , tx_fee : int , tx_nonce : str , ** kwargs ) -> Optional [ str ] Submit a transaction to the ledger. is _ transaction _ settled | is_transaction_settled ( tx_digest : str ) -> bool Check whether a transaction is settled or not. validate _ transaction | validate_transaction ( tx_digest : str , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether a transaction is valid or not. Arguments : seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. tx_digest : the transaction digest. Returns : True if the random_message is equals to tx['input'] generate _ tx _ nonce | generate_tx_nonce ( seller : Address , client : Address ) -> str Generate a random str message. Arguments : seller : the address of the seller. client : the address of the client. Returns : return the hash in hex.","title":"Fetchai"},{"location":"aea/api/crypto/fetchai/#aeacryptofetchai","text":"Fetchai module wrapping the public and private key cryptography and ledger api.","title":"aea.crypto.fetchai"},{"location":"aea/api/crypto/fetchai/#fetchaicrypto","text":"class FetchAICrypto ( Crypto ) Class wrapping the Entity Generation from Fetch.AI ledger.","title":"FetchAICrypto"},{"location":"aea/api/crypto/fetchai/#__init__","text":"| __init__ ( private_key_path : Optional [ str ] = None ) Instantiate a fetchai crypto object. Arguments : private_key_path : the private key path of the agent","title":"__init__"},{"location":"aea/api/crypto/fetchai/#entity","text":"| @property | entity () -> Entity Get the entity.","title":"entity"},{"location":"aea/api/crypto/fetchai/#public_key","text":"| @property | public_key () -> str Return a public key in hex format. Returns : a public key string in hex format","title":"public_key"},{"location":"aea/api/crypto/fetchai/#address","text":"| @property | address () -> str Return the address for the key pair. Returns : a display_address str","title":"address"},{"location":"aea/api/crypto/fetchai/#sign_message","text":"| sign_message ( message : bytes ) -> bytes Sign a message in bytes string form. Arguments : message : the message we want to send Returns : Signed message in bytes","title":"sign_message"},{"location":"aea/api/crypto/fetchai/#recover_message","text":"| recover_message ( message : bytes , signature : bytes ) -> Address Recover the address from the hash. Arguments : message : the message we expect signature : the transaction signature Returns : the recovered address","title":"recover_message"},{"location":"aea/api/crypto/fetchai/#get_address_from_public_key","text":"| @classmethod | get_address_from_public_key ( cls , public_key : str ) -> Address Get the address from the public key. Arguments : public_key : the public key Returns : str","title":"get_address_from_public_key"},{"location":"aea/api/crypto/fetchai/#load","text":"| @classmethod | load ( cls , fp : BinaryIO ) Deserialize binary file fp (a .read() -supporting file-like object containing a private key). Arguments : fp : the input file pointer. Must be set in binary mode (mode='rb') Returns : None","title":"load"},{"location":"aea/api/crypto/fetchai/#dump","text":"| dump ( fp : BinaryIO ) -> None Serialize crypto object as binary stream to fp (a .write() -supporting file-like object). Arguments : fp : the output file pointer. Must be set in binary mode (mode='wb') Returns : None","title":"dump"},{"location":"aea/api/crypto/fetchai/#fetchaiapi","text":"class FetchAIApi ( LedgerApi ) Class to interact with the Fetch ledger APIs.","title":"FetchAIApi"},{"location":"aea/api/crypto/fetchai/#__init___1","text":"| __init__ ( ** kwargs ) Initialize the Fetch.AI ledger APIs. Arguments : kwargs : key word arguments (expects either a pair of 'host' and 'port' or a 'network')","title":"__init__"},{"location":"aea/api/crypto/fetchai/#api","text":"| @property | api () -> FetchaiLedgerApi Get the underlying API object.","title":"api"},{"location":"aea/api/crypto/fetchai/#get_balance","text":"| get_balance ( address : AddressLike ) -> int Get the balance of a given account.","title":"get_balance"},{"location":"aea/api/crypto/fetchai/#send_transaction","text":"| send_transaction ( crypto : Crypto , destination_address : AddressLike , amount : int , tx_fee : int , tx_nonce : str , ** kwargs ) -> Optional [ str ] Submit a transaction to the ledger.","title":"send_transaction"},{"location":"aea/api/crypto/fetchai/#is_transaction_settled","text":"| is_transaction_settled ( tx_digest : str ) -> bool Check whether a transaction is settled or not.","title":"is_transaction_settled"},{"location":"aea/api/crypto/fetchai/#validate_transaction","text":"| validate_transaction ( tx_digest : str , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether a transaction is valid or not. Arguments : seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. tx_digest : the transaction digest. Returns : True if the random_message is equals to tx['input']","title":"validate_transaction"},{"location":"aea/api/crypto/fetchai/#generate_tx_nonce","text":"| generate_tx_nonce ( seller : Address , client : Address ) -> str Generate a random str message. Arguments : seller : the address of the seller. client : the address of the client. Returns : return the hash in hex.","title":"generate_tx_nonce"},{"location":"aea/api/crypto/ledger_apis/","text":"aea.crypto.ledger _ apis Module wrapping all the public and private keys cryptography. LedgerApis class LedgerApis () Store all the ledger apis we initialise. __ init __ | __init__ ( ledger_api_configs : Dict [ str , Dict [ str , Union [ str , int ]]], default_ledger_id : str ) Instantiate a wallet object. Arguments : ledger_api_configs : the ledger api configs. default_ledger_id : the default ledger id. configs | @property | configs () -> Dict [ str , Dict [ str , Union [ str , int ]]] Get the configs. apis | @property | apis () -> Dict [ str , LedgerApi ] Get the apis. has _ fetchai | @property | has_fetchai () -> bool Check if it has the fetchai API. has _ ethereum | @property | has_ethereum () -> bool Check if it has the ethereum API. has _ default _ ledger | @property | has_default_ledger () -> bool Check if it has the default ledger API. last _ tx _ statuses | @property | last_tx_statuses () -> Dict [ str , str ] Get the statuses for the last transaction. default _ ledger _ id | @property | default_ledger_id () -> str Get the default ledger id. token _ balance | token_balance ( identifier : str , address : str ) -> int Get the token balance. Arguments : identifier : the identifier of the ledger address : the address to check for Returns : the token balance transfer | transfer ( crypto_object : Crypto , destination_address : str , amount : int , tx_fee : int , tx_nonce : str , ** kwargs ) -> Optional [ str ] Transfer from self to destination. Arguments : tx_nonce : verifies the authenticity of the tx crypto_object : the crypto object that contains the fucntions for signing transactions. destination_address : the address of the receive amount : the amount tx_fee : the tx fee Returns : tx digest if successful, otherwise None is _ tx _ valid | is_tx_valid ( identifier : str , tx_digest : str , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether the transaction is valid Arguments : identifier : Ledger identifier tx_digest : the transaction digest seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. Returns : True if is valid , False otherwise generate _ tx _ nonce | generate_tx_nonce ( identifier : str , seller : Address , client : Address ) -> str Generate a random str message. Arguments : identifier : ledger identifier. seller : the address of the seller. client : the address of the client. Returns : return the hash in hex.","title":"LedgerApis"},{"location":"aea/api/crypto/ledger_apis/#aeacryptoledger_apis","text":"Module wrapping all the public and private keys cryptography.","title":"aea.crypto.ledger_apis"},{"location":"aea/api/crypto/ledger_apis/#ledgerapis","text":"class LedgerApis () Store all the ledger apis we initialise.","title":"LedgerApis"},{"location":"aea/api/crypto/ledger_apis/#__init__","text":"| __init__ ( ledger_api_configs : Dict [ str , Dict [ str , Union [ str , int ]]], default_ledger_id : str ) Instantiate a wallet object. Arguments : ledger_api_configs : the ledger api configs. default_ledger_id : the default ledger id.","title":"__init__"},{"location":"aea/api/crypto/ledger_apis/#configs","text":"| @property | configs () -> Dict [ str , Dict [ str , Union [ str , int ]]] Get the configs.","title":"configs"},{"location":"aea/api/crypto/ledger_apis/#apis","text":"| @property | apis () -> Dict [ str , LedgerApi ] Get the apis.","title":"apis"},{"location":"aea/api/crypto/ledger_apis/#has_fetchai","text":"| @property | has_fetchai () -> bool Check if it has the fetchai API.","title":"has_fetchai"},{"location":"aea/api/crypto/ledger_apis/#has_ethereum","text":"| @property | has_ethereum () -> bool Check if it has the ethereum API.","title":"has_ethereum"},{"location":"aea/api/crypto/ledger_apis/#has_default_ledger","text":"| @property | has_default_ledger () -> bool Check if it has the default ledger API.","title":"has_default_ledger"},{"location":"aea/api/crypto/ledger_apis/#last_tx_statuses","text":"| @property | last_tx_statuses () -> Dict [ str , str ] Get the statuses for the last transaction.","title":"last_tx_statuses"},{"location":"aea/api/crypto/ledger_apis/#default_ledger_id","text":"| @property | default_ledger_id () -> str Get the default ledger id.","title":"default_ledger_id"},{"location":"aea/api/crypto/ledger_apis/#token_balance","text":"| token_balance ( identifier : str , address : str ) -> int Get the token balance. Arguments : identifier : the identifier of the ledger address : the address to check for Returns : the token balance","title":"token_balance"},{"location":"aea/api/crypto/ledger_apis/#transfer","text":"| transfer ( crypto_object : Crypto , destination_address : str , amount : int , tx_fee : int , tx_nonce : str , ** kwargs ) -> Optional [ str ] Transfer from self to destination. Arguments : tx_nonce : verifies the authenticity of the tx crypto_object : the crypto object that contains the fucntions for signing transactions. destination_address : the address of the receive amount : the amount tx_fee : the tx fee Returns : tx digest if successful, otherwise None","title":"transfer"},{"location":"aea/api/crypto/ledger_apis/#is_tx_valid","text":"| is_tx_valid ( identifier : str , tx_digest : str , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether the transaction is valid Arguments : identifier : Ledger identifier tx_digest : the transaction digest seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. Returns : True if is valid , False otherwise","title":"is_tx_valid"},{"location":"aea/api/crypto/ledger_apis/#generate_tx_nonce","text":"| generate_tx_nonce ( identifier : str , seller : Address , client : Address ) -> str Generate a random str message. Arguments : identifier : ledger identifier. seller : the address of the seller. client : the address of the client. Returns : return the hash in hex.","title":"generate_tx_nonce"},{"location":"aea/api/crypto/wallet/","text":"aea.crypto.wallet Module wrapping all the public and private keys cryptography. Wallet class Wallet () Store all the cryptos we initialise. __ init __ | __init__ ( private_key_paths : Dict [ str , str ]) Instantiate a wallet object. Arguments : private_key_paths : the private key paths public _ keys | @property | public_keys () Get the public_key dictionary. crypto _ objects | @property | crypto_objects () Get the crypto objects (key pair). addresses | @property | addresses () -> Dict [ str , str ] Get the crypto addresses.","title":"Wallet"},{"location":"aea/api/crypto/wallet/#aeacryptowallet","text":"Module wrapping all the public and private keys cryptography.","title":"aea.crypto.wallet"},{"location":"aea/api/crypto/wallet/#wallet","text":"class Wallet () Store all the cryptos we initialise.","title":"Wallet"},{"location":"aea/api/crypto/wallet/#__init__","text":"| __init__ ( private_key_paths : Dict [ str , str ]) Instantiate a wallet object. Arguments : private_key_paths : the private key paths","title":"__init__"},{"location":"aea/api/crypto/wallet/#public_keys","text":"| @property | public_keys () Get the public_key dictionary.","title":"public_keys"},{"location":"aea/api/crypto/wallet/#crypto_objects","text":"| @property | crypto_objects () Get the crypto objects (key pair).","title":"crypto_objects"},{"location":"aea/api/crypto/wallet/#addresses","text":"| @property | addresses () -> Dict [ str , str ] Get the crypto addresses.","title":"addresses"},{"location":"aea/api/crytpo/base/","text":"aea.crypto.base Abstract module wrapping the public and private key cryptography and ledger api. Crypto class Crypto ( ABC ) Base class for a crypto object. entity | @property | @abstractmethod | entity () -> Any Return an entity object. Returns : an entity object public _ key | @property | @abstractmethod | public_key () -> str Return a public key. Returns : a public key string address | @property | @abstractmethod | address () -> str Return the address. Returns : an address string get _ address _ from _ public _ key | @classmethod | @abstractmethod | get_address_from_public_key ( cls , public_key : str ) -> str Get the address from the public key. Arguments : public_key : the public key Returns : str sign _ message | @abstractmethod | sign_message ( message : bytes ) -> bytes Sign a message in bytes string form. Arguments : message : the message we want to send Returns : Signed message in bytes recover _ message | @abstractmethod | recover_message ( message : bytes , signature : bytes ) -> Address Recover the address from the hash. Arguments : message : the message we expect signature : the transaction signature Returns : the recovered address load | @classmethod | @abstractmethod | load ( cls , fp : BinaryIO ) -> \"Crypto\" Deserialize binary file fp (a .read() -supporting file-like object containing a private key). Arguments : fp : the input file pointer. Must be set in binary mode (mode='rb') Returns : None dump | @abstractmethod | dump ( fp : BinaryIO ) -> None Serialize crypto object as binary stream to fp (a .write() -supporting file-like object). Arguments : fp : the output file pointer. Must be set in binary mode (mode='wb') Returns : None LedgerApi class LedgerApi ( ABC ) Interface for ledger APIs. api | @property | @abstractmethod | api () -> Any Get the underlying API object. This can be used for low-level operations with the concrete ledger APIs. If there is no such object, return None. get _ balance | @abstractmethod | get_balance ( address : AddressLike ) -> int Get the balance of a given account. This usually takes the form of a web request to be waited synchronously. Arguments : address : the address. Returns : the balance. send _ transaction | @abstractmethod | send_transaction ( crypto : Crypto , destination_address : AddressLike , amount : int , tx_fee : int , tx_nonce : str , ** kwargs ) -> Optional [ str ] Submit a transaction to the ledger. If the mandatory arguments are not enough for specifying a transaction in the concrete ledger API, use keyword arguments for the additional parameters. Arguments : tx_nonce : verifies the authenticity of the tx crypto : the crypto object associated to the payer. destination_address : the destination address of the payee. amount : the amount of wealth to be transferred. tx_fee : the transaction fee. Returns : tx digest if successful, otherwise None is _ transaction _ settled | @abstractmethod | is_transaction_settled ( tx_digest : str ) -> bool Check whether a transaction is settled or not. Arguments : tx_digest : the digest associated to the transaction. Returns : True if the transaction has been settled, False o/w. validate _ transaction | @abstractmethod | validate_transaction ( tx_digest : str , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether a transaction is valid or not. Arguments : seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. tx_digest : the transaction digest. Returns : True if the transaction referenced by the tx_digest matches the terms. generate _ tx _ nonce | @abstractmethod | generate_tx_nonce ( seller : Address , client : Address ) -> str Generate a random str message. Arguments : seller : the address of the seller. client : the address of the client. Returns : return the hash in hex.","title":"Base"},{"location":"aea/api/crytpo/base/#aeacryptobase","text":"Abstract module wrapping the public and private key cryptography and ledger api.","title":"aea.crypto.base"},{"location":"aea/api/crytpo/base/#crypto","text":"class Crypto ( ABC ) Base class for a crypto object.","title":"Crypto"},{"location":"aea/api/crytpo/base/#entity","text":"| @property | @abstractmethod | entity () -> Any Return an entity object. Returns : an entity object","title":"entity"},{"location":"aea/api/crytpo/base/#public_key","text":"| @property | @abstractmethod | public_key () -> str Return a public key. Returns : a public key string","title":"public_key"},{"location":"aea/api/crytpo/base/#address","text":"| @property | @abstractmethod | address () -> str Return the address. Returns : an address string","title":"address"},{"location":"aea/api/crytpo/base/#get_address_from_public_key","text":"| @classmethod | @abstractmethod | get_address_from_public_key ( cls , public_key : str ) -> str Get the address from the public key. Arguments : public_key : the public key Returns : str","title":"get_address_from_public_key"},{"location":"aea/api/crytpo/base/#sign_message","text":"| @abstractmethod | sign_message ( message : bytes ) -> bytes Sign a message in bytes string form. Arguments : message : the message we want to send Returns : Signed message in bytes","title":"sign_message"},{"location":"aea/api/crytpo/base/#recover_message","text":"| @abstractmethod | recover_message ( message : bytes , signature : bytes ) -> Address Recover the address from the hash. Arguments : message : the message we expect signature : the transaction signature Returns : the recovered address","title":"recover_message"},{"location":"aea/api/crytpo/base/#load","text":"| @classmethod | @abstractmethod | load ( cls , fp : BinaryIO ) -> \"Crypto\" Deserialize binary file fp (a .read() -supporting file-like object containing a private key). Arguments : fp : the input file pointer. Must be set in binary mode (mode='rb') Returns : None","title":"load"},{"location":"aea/api/crytpo/base/#dump","text":"| @abstractmethod | dump ( fp : BinaryIO ) -> None Serialize crypto object as binary stream to fp (a .write() -supporting file-like object). Arguments : fp : the output file pointer. Must be set in binary mode (mode='wb') Returns : None","title":"dump"},{"location":"aea/api/crytpo/base/#ledgerapi","text":"class LedgerApi ( ABC ) Interface for ledger APIs.","title":"LedgerApi"},{"location":"aea/api/crytpo/base/#api","text":"| @property | @abstractmethod | api () -> Any Get the underlying API object. This can be used for low-level operations with the concrete ledger APIs. If there is no such object, return None.","title":"api"},{"location":"aea/api/crytpo/base/#get_balance","text":"| @abstractmethod | get_balance ( address : AddressLike ) -> int Get the balance of a given account. This usually takes the form of a web request to be waited synchronously. Arguments : address : the address. Returns : the balance.","title":"get_balance"},{"location":"aea/api/crytpo/base/#send_transaction","text":"| @abstractmethod | send_transaction ( crypto : Crypto , destination_address : AddressLike , amount : int , tx_fee : int , tx_nonce : str , ** kwargs ) -> Optional [ str ] Submit a transaction to the ledger. If the mandatory arguments are not enough for specifying a transaction in the concrete ledger API, use keyword arguments for the additional parameters. Arguments : tx_nonce : verifies the authenticity of the tx crypto : the crypto object associated to the payer. destination_address : the destination address of the payee. amount : the amount of wealth to be transferred. tx_fee : the transaction fee. Returns : tx digest if successful, otherwise None","title":"send_transaction"},{"location":"aea/api/crytpo/base/#is_transaction_settled","text":"| @abstractmethod | is_transaction_settled ( tx_digest : str ) -> bool Check whether a transaction is settled or not. Arguments : tx_digest : the digest associated to the transaction. Returns : True if the transaction has been settled, False o/w.","title":"is_transaction_settled"},{"location":"aea/api/crytpo/base/#validate_transaction","text":"| @abstractmethod | validate_transaction ( tx_digest : str , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether a transaction is valid or not. Arguments : seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. tx_digest : the transaction digest. Returns : True if the transaction referenced by the tx_digest matches the terms.","title":"validate_transaction"},{"location":"aea/api/crytpo/base/#generate_tx_nonce","text":"| @abstractmethod | generate_tx_nonce ( seller : Address , client : Address ) -> str Generate a random str message. Arguments : seller : the address of the seller. client : the address of the client. Returns : return the hash in hex.","title":"generate_tx_nonce"},{"location":"aea/api/helpers/dialogue/base/","text":"aea.helpers.dialogue.base This module contains the classes required for dialogue management. DialogueLabel: The dialogue label class acts as an identifier for dialogues. Dialogue: The dialogue class maintains state of a dialogue and manages it. Dialogues: The dialogues class keeps track of all dialogues. DialogueLabel class DialogueLabel () The dialogue label class acts as an identifier for dialogues. __ init __ | __init__ ( dialogue_reference : Tuple [ str , str ], dialogue_opponent_addr : Address , dialogue_starter_addr : Address ) -> None Initialize a dialogue label. Arguments : dialogue_reference : the reference of the dialogue. dialogue_opponent_addr : the addr of the agent with which the dialogue is kept. dialogue_starter_addr : the addr of the agent which started the dialogue. Returns : None dialogue _ reference | @property | dialogue_reference () -> Tuple [ str , str ] Get the dialogue reference. dialogue _ starter _ reference | @property | dialogue_starter_reference () -> str Get the dialogue starter reference. dialogue _ responder _ reference | @property | dialogue_responder_reference () -> str Get the dialogue responder reference. dialogue _ opponent _ addr | @property | dialogue_opponent_addr () -> str Get the address of the dialogue opponent. dialogue _ starter _ addr | @property | dialogue_starter_addr () -> str Get the address of the dialogue starter. __ eq __ | __eq__ ( other ) -> bool Check for equality between two DialogueLabel objects. __ hash __ | __hash__ () -> int Turn object into hash. json | @property | json () -> Dict Return the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict [ str , str ]) -> \"DialogueLabel\" Get dialogue label from json. __ str __ | __str__ () Get the string representation. Dialogue class Dialogue () The dialogue class maintains state of a dialogue and manages it. __ init __ | __init__ ( dialogue_label : DialogueLabel ) -> None Initialize a dialogue label. Arguments : dialogue_label : the identifier of the dialogue Returns : None dialogue _ label | @property | dialogue_label () -> DialogueLabel Get the dialogue lable. is _ self _ initiated | @property | is_self_initiated () -> bool Check whether the agent initiated the dialogue. last _ incoming _ message | @property | last_incoming_message () -> Optional [ Message ] Get the last incoming message. last _ outgoing _ message | @property | last_outgoing_message () -> Optional [ Message ] Get the last incoming message. outgoing _ extend | outgoing_extend ( message : \"Message\" ) -> None Extend the list of messages which keeps track of outgoing messages. Arguments : message : a message to be added Returns : None incoming _ extend | incoming_extend ( message : \"Message\" ) -> None Extend the list of messages which keeps track of incoming messages. Arguments : messages : a message to be added Returns : None Dialogues class Dialogues () The dialogues class keeps track of all dialogues. __ init __ | __init__ () -> None Initialize dialogues. Returns : None dialogues | @property | dialogues () -> Dict [ DialogueLabel , Dialogue ] Get dictionary of dialogues in which the agent is engaged in. is _ permitted _ for _ new _ dialogue | @abstractmethod | is_permitted_for_new_dialogue ( msg : Message ) -> bool Check whether an agent message is permitted for a new dialogue. Arguments : msg : the agent message Returns : a boolean indicating whether the message is permitted for a new dialogue is _ belonging _ to _ registered _ dialogue | @abstractmethod | is_belonging_to_registered_dialogue ( msg : Message , agent_addr : Address ) -> bool Check whether an agent message is part of a registered dialogue. Arguments : msg : the agent message agent_addr : the address of the agent Returns : boolean indicating whether the message belongs to a registered dialogue get _ dialogue | @abstractmethod | get_dialogue ( msg : Message , agent_addr : Address ) -> Dialogue Retrieve dialogue. Arguments : msg : the agent message agent_addr : the address of the agent Returns : the dialogue","title":"Base"},{"location":"aea/api/helpers/dialogue/base/#aeahelpersdialoguebase","text":"This module contains the classes required for dialogue management. DialogueLabel: The dialogue label class acts as an identifier for dialogues. Dialogue: The dialogue class maintains state of a dialogue and manages it. Dialogues: The dialogues class keeps track of all dialogues.","title":"aea.helpers.dialogue.base"},{"location":"aea/api/helpers/dialogue/base/#dialoguelabel","text":"class DialogueLabel () The dialogue label class acts as an identifier for dialogues.","title":"DialogueLabel"},{"location":"aea/api/helpers/dialogue/base/#__init__","text":"| __init__ ( dialogue_reference : Tuple [ str , str ], dialogue_opponent_addr : Address , dialogue_starter_addr : Address ) -> None Initialize a dialogue label. Arguments : dialogue_reference : the reference of the dialogue. dialogue_opponent_addr : the addr of the agent with which the dialogue is kept. dialogue_starter_addr : the addr of the agent which started the dialogue. Returns : None","title":"__init__"},{"location":"aea/api/helpers/dialogue/base/#dialogue_reference","text":"| @property | dialogue_reference () -> Tuple [ str , str ] Get the dialogue reference.","title":"dialogue_reference"},{"location":"aea/api/helpers/dialogue/base/#dialogue_starter_reference","text":"| @property | dialogue_starter_reference () -> str Get the dialogue starter reference.","title":"dialogue_starter_reference"},{"location":"aea/api/helpers/dialogue/base/#dialogue_responder_reference","text":"| @property | dialogue_responder_reference () -> str Get the dialogue responder reference.","title":"dialogue_responder_reference"},{"location":"aea/api/helpers/dialogue/base/#dialogue_opponent_addr","text":"| @property | dialogue_opponent_addr () -> str Get the address of the dialogue opponent.","title":"dialogue_opponent_addr"},{"location":"aea/api/helpers/dialogue/base/#dialogue_starter_addr","text":"| @property | dialogue_starter_addr () -> str Get the address of the dialogue starter.","title":"dialogue_starter_addr"},{"location":"aea/api/helpers/dialogue/base/#__eq__","text":"| __eq__ ( other ) -> bool Check for equality between two DialogueLabel objects.","title":"__eq__"},{"location":"aea/api/helpers/dialogue/base/#__hash__","text":"| __hash__ () -> int Turn object into hash.","title":"__hash__"},{"location":"aea/api/helpers/dialogue/base/#json","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/helpers/dialogue/base/#from_json","text":"| @classmethod | from_json ( cls , obj : Dict [ str , str ]) -> \"DialogueLabel\" Get dialogue label from json.","title":"from_json"},{"location":"aea/api/helpers/dialogue/base/#__str__","text":"| __str__ () Get the string representation.","title":"__str__"},{"location":"aea/api/helpers/dialogue/base/#dialogue","text":"class Dialogue () The dialogue class maintains state of a dialogue and manages it.","title":"Dialogue"},{"location":"aea/api/helpers/dialogue/base/#__init___1","text":"| __init__ ( dialogue_label : DialogueLabel ) -> None Initialize a dialogue label. Arguments : dialogue_label : the identifier of the dialogue Returns : None","title":"__init__"},{"location":"aea/api/helpers/dialogue/base/#dialogue_label","text":"| @property | dialogue_label () -> DialogueLabel Get the dialogue lable.","title":"dialogue_label"},{"location":"aea/api/helpers/dialogue/base/#is_self_initiated","text":"| @property | is_self_initiated () -> bool Check whether the agent initiated the dialogue.","title":"is_self_initiated"},{"location":"aea/api/helpers/dialogue/base/#last_incoming_message","text":"| @property | last_incoming_message () -> Optional [ Message ] Get the last incoming message.","title":"last_incoming_message"},{"location":"aea/api/helpers/dialogue/base/#last_outgoing_message","text":"| @property | last_outgoing_message () -> Optional [ Message ] Get the last incoming message.","title":"last_outgoing_message"},{"location":"aea/api/helpers/dialogue/base/#outgoing_extend","text":"| outgoing_extend ( message : \"Message\" ) -> None Extend the list of messages which keeps track of outgoing messages. Arguments : message : a message to be added Returns : None","title":"outgoing_extend"},{"location":"aea/api/helpers/dialogue/base/#incoming_extend","text":"| incoming_extend ( message : \"Message\" ) -> None Extend the list of messages which keeps track of incoming messages. Arguments : messages : a message to be added Returns : None","title":"incoming_extend"},{"location":"aea/api/helpers/dialogue/base/#dialogues","text":"class Dialogues () The dialogues class keeps track of all dialogues.","title":"Dialogues"},{"location":"aea/api/helpers/dialogue/base/#__init___2","text":"| __init__ () -> None Initialize dialogues. Returns : None","title":"__init__"},{"location":"aea/api/helpers/dialogue/base/#dialogues_1","text":"| @property | dialogues () -> Dict [ DialogueLabel , Dialogue ] Get dictionary of dialogues in which the agent is engaged in.","title":"dialogues"},{"location":"aea/api/helpers/dialogue/base/#is_permitted_for_new_dialogue","text":"| @abstractmethod | is_permitted_for_new_dialogue ( msg : Message ) -> bool Check whether an agent message is permitted for a new dialogue. Arguments : msg : the agent message Returns : a boolean indicating whether the message is permitted for a new dialogue","title":"is_permitted_for_new_dialogue"},{"location":"aea/api/helpers/dialogue/base/#is_belonging_to_registered_dialogue","text":"| @abstractmethod | is_belonging_to_registered_dialogue ( msg : Message , agent_addr : Address ) -> bool Check whether an agent message is part of a registered dialogue. Arguments : msg : the agent message agent_addr : the address of the agent Returns : boolean indicating whether the message belongs to a registered dialogue","title":"is_belonging_to_registered_dialogue"},{"location":"aea/api/helpers/dialogue/base/#get_dialogue","text":"| @abstractmethod | get_dialogue ( msg : Message , agent_addr : Address ) -> Dialogue Retrieve dialogue. Arguments : msg : the agent message agent_addr : the address of the agent Returns : the dialogue","title":"get_dialogue"},{"location":"aea/api/helpers/search/generic/","text":"aea.helpers.search.generic This module contains a generic data model. GenericDataModel class GenericDataModel ( DataModel ) Data model for the generic seller aea. __ init __ | __init__ ( data_model_name : str , data_model_attributes : Dict [ str , Any ]) Initialise the dataModel.","title":"Generic"},{"location":"aea/api/helpers/search/generic/#aeahelperssearchgeneric","text":"This module contains a generic data model.","title":"aea.helpers.search.generic"},{"location":"aea/api/helpers/search/generic/#genericdatamodel","text":"class GenericDataModel ( DataModel ) Data model for the generic seller aea.","title":"GenericDataModel"},{"location":"aea/api/helpers/search/generic/#__init__","text":"| __init__ ( data_model_name : str , data_model_attributes : Dict [ str , Any ]) Initialise the dataModel.","title":"__init__"},{"location":"aea/api/helpers/search/models/","text":"aea.helpers.search.models Useful classes for the OEF search. Attribute class Attribute () Implements an attribute for an OEF data model. __ init __ | __init__ ( name : str , type : Type [ ATTRIBUTE_TYPES ], is_required : bool , description : str = \"\" ) Initialize an attribute. Arguments : name : the name of the attribute. type : the type of the attribute. is_required : whether the attribute is required by the data model. description : an (optional) human-readable description for the attribute. __ eq __ | __eq__ ( other ) Compare with another object. DataModel class DataModel () Implements an OEF data model. __ init __ | __init__ ( name : str , attributes : List [ Attribute ], description : str = \"\" ) Initialize a data model. Arguments : name : the name of the data model. attributes : the attributes of the data model. __ eq __ | __eq__ ( other ) -> bool Compare with another object. Description class Description () Implements an OEF description. __ init __ | __init__ ( values : Dict , data_model : Optional [ DataModel ] = None ) Initialize the description object. Arguments : values : the values in the description. __ eq __ | __eq__ ( other ) -> bool Compare with another object. __ iter __ | __iter__ () Create an iterator. encode | @classmethod | encode ( cls , performative_content , description_from_message : \"Description\" ) -> None Encode an instance of this class into the protocol buffer object. The content in the 'performative_content' argument must be matched with the message content in the 'description_from_message' argument. Arguments : performative_content : the performative protocol buffer object containing a content whose type is this class. description_from_message : the message content to be encoded in the protocol buffer object. Returns : None decode | @classmethod | decode ( cls , description_from_pb2 ) -> \"Description\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the content in the 'description_from_pb2' argument. Arguments : description_from_pb2 : the protocol buffer content object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'description_from_pb2' argument. ConstraintTypes class ConstraintTypes ( Enum ) Types of constraint. __ str __ | __str__ () Get the string representation. ConstraintType class ConstraintType () Type of constraint. Used with the Constraint class, this class allows to specify constraint over attributes. Examples : Equal to three equal_3 = ConstraintType(ConstraintTypes.EQUAL, 3) You can also specify a type of constraint by using its string representation, e.g.: equal_3 = ConstraintType(\"==\", 3) not_equal_london = ConstraintType(\"!=\", \"London\") less_than_pi = ConstraintType(\"<\", 3.14) within_range = ConstraintType(\"within\", (-10.0, 10.0)) in_a_set = ConstraintType(\"in\", [1, 2, 3]) not_in_a_set = ConstraintType(\"not_in\", {\"C\", \"Java\", \"Python\"}) __ init __ | __init__ ( type : Union [ ConstraintTypes , str ], value : Any ) Initialize a constraint type. Arguments : type : the type of the constraint. | Either an instance of the ConstraintTypes enum, | or a string representation associated with the type. value : the value that defines the constraint. Raises : ValueError : if the type of the constraint is not check | check ( value : ATTRIBUTE_TYPES ) -> bool Check if an attribute value satisfies the constraint. The implementation depends on the constraint type. Arguments : value : the value to check. Returns : True if the value satisfy the constraint, False otherwise. Raises : ValueError : if the constraint type is not recognized. __ eq __ | __eq__ ( other ) Check equality with another object. ConstraintExpr class ConstraintExpr ( ABC ) Implementation of the constraint language to query the OEF node. check | @abstractmethod | check ( description : Description ) -> bool Check if a description satisfies the constraint expression. Arguments : description : the description to check. Returns : True if the description satisfy the constraint expression, False otherwise. And class And ( ConstraintExpr ) Implementation of the 'And' constraint expression. __ init __ | __init__ ( constraints : List [ ConstraintExpr ]) Initialize an 'And' expression. Arguments : constraints : the list of constraints expression (in conjunction). check | check ( description : Description ) -> bool Check if a value satisfies the 'And' constraint expression. Arguments : description : the description to check. Returns : True if the description satisfy the constraint expression, False otherwise. __ eq __ | __eq__ ( other ) Compare with another object. Or class Or ( ConstraintExpr ) Implementation of the 'Or' constraint expression. __ init __ | __init__ ( constraints : List [ ConstraintExpr ]) Initialize an 'Or' expression. Arguments : constraints : the list of constraints expressions (in disjunction). check | check ( description : Description ) -> bool Check if a value satisfies the 'Or' constraint expression. Arguments : description : the description to check. Returns : True if the description satisfy the constraint expression, False otherwise. __ eq __ | __eq__ ( other ) Compare with another object. Not class Not ( ConstraintExpr ) Implementation of the 'Not' constraint expression. __ init __ | __init__ ( constraint : ConstraintExpr ) Initialize a 'Not' expression. Arguments : constraint : the constraint expression to negate. check | check ( description : Description ) -> bool Check if a value satisfies the 'Not; constraint expression. Arguments : description : the description to check. Returns : True if the description satisfy the constraint expression, False otherwise. __ eq __ | __eq__ ( other ) Compare with another object. Constraint class Constraint ( ConstraintExpr ) The atomic component of a constraint expression. __ init __ | __init__ ( attribute_name : str , constraint_type : ConstraintType ) Initialize a constraint. Arguments : attribute_name : the name of the attribute to be constrained. constraint_type : the constraint type. check | check ( description : Description ) -> bool Check if a description satisfies the constraint. The implementation depends on the type of the constraint. Arguments : description : the description to check. Returns : True if the description satisfies the constraint, False otherwise. Examples: attr_author = Attribute(\"author\" , str, True, \"The author of the book.\") attr_year = Attribute(\"year\", int, True, \"The year of publication of the book.\") attr_genre = Attribute(\"genre\", str, True, \"The genre of the book.\") c1 = Constraint(\"author\", ConstraintType(\"==\", \"Stephen King\")) c2 = Constraint(\"year\", ConstraintType(\">\", 1990)) c3 = Constraint(\"genre\", ConstraintType(\"in\", {\"horror\", \"science_fiction\"})) book_1 = Description({\"author\": \"Stephen King\", \"year\": 1991, \"genre\": \"horror\"}) book_2 = Description({\"author\": \"George Orwell\", \"year\": 1948, \"genre\": \"horror\"}) The \"author\" attribute instantiation satisfies the constraint, so the result is True. c1.check(book_1) True Here, the \"author\" does not satisfy the constraints. Hence, the result is False. c1.check(book_2) False In this case, there is a missing field specified by the query, that is \"year\" So the result is False, even in the case it is not required by the schema: c2.check(Description({\"author\": \"Stephen King\"})) False If the type of some attribute of the description is not correct, the result is False. In this case, the field \"year\" has a string instead of an integer: c2.check(Description({\"author\": \"Stephen King\", \"year\": \"1991\"})) False c3.check(Description({\"author\": \"Stephen King\", \"genre\": False})) False __ eq __ | __eq__ ( other ) Compare with another object. Query class Query () This class lets you build a query for the OEF. __ init __ | __init__ ( constraints : List [ ConstraintExpr ], model : Optional [ DataModel ] = None ) -> None Initialize a query. Arguments : constraints : a list of constraint expressions. model : the data model that the query refers to. check | check ( description : Description ) -> bool Check if a description satisfies the constraints of the query. The constraints are interpreted as conjunction. Arguments : description : the description to check. Returns : True if the description satisfies all the constraints, False otherwise. __ eq __ | __eq__ ( other ) Compare with another object. encode | @classmethod | encode ( cls , performative_content , query_from_message : \"Query\" ) -> None Encode an instance of this class into the protocol buffer object. The content in the 'performative_content' argument must be matched with the message content in the 'query_from_message' argument. Arguments : performative_content : the performative protocol buffer object containing a content whose type is this class. query_from_message : the message content to be encoded in the protocol buffer object. Returns : None decode | @classmethod | decode ( cls , query_from_pb2 ) -> \"Query\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the content in the 'query_from_pb2' argument. Arguments : query_from_pb2 : the protocol buffer content object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'query_from_pb2' argument.","title":"Models"},{"location":"aea/api/helpers/search/models/#aeahelperssearchmodels","text":"Useful classes for the OEF search.","title":"aea.helpers.search.models"},{"location":"aea/api/helpers/search/models/#attribute","text":"class Attribute () Implements an attribute for an OEF data model.","title":"Attribute"},{"location":"aea/api/helpers/search/models/#__init__","text":"| __init__ ( name : str , type : Type [ ATTRIBUTE_TYPES ], is_required : bool , description : str = \"\" ) Initialize an attribute. Arguments : name : the name of the attribute. type : the type of the attribute. is_required : whether the attribute is required by the data model. description : an (optional) human-readable description for the attribute.","title":"__init__"},{"location":"aea/api/helpers/search/models/#__eq__","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#datamodel","text":"class DataModel () Implements an OEF data model.","title":"DataModel"},{"location":"aea/api/helpers/search/models/#__init___1","text":"| __init__ ( name : str , attributes : List [ Attribute ], description : str = \"\" ) Initialize a data model. Arguments : name : the name of the data model. attributes : the attributes of the data model.","title":"__init__"},{"location":"aea/api/helpers/search/models/#__eq___1","text":"| __eq__ ( other ) -> bool Compare with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#description","text":"class Description () Implements an OEF description.","title":"Description"},{"location":"aea/api/helpers/search/models/#__init___2","text":"| __init__ ( values : Dict , data_model : Optional [ DataModel ] = None ) Initialize the description object. Arguments : values : the values in the description.","title":"__init__"},{"location":"aea/api/helpers/search/models/#__eq___2","text":"| __eq__ ( other ) -> bool Compare with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#__iter__","text":"| __iter__ () Create an iterator.","title":"__iter__"},{"location":"aea/api/helpers/search/models/#encode","text":"| @classmethod | encode ( cls , performative_content , description_from_message : \"Description\" ) -> None Encode an instance of this class into the protocol buffer object. The content in the 'performative_content' argument must be matched with the message content in the 'description_from_message' argument. Arguments : performative_content : the performative protocol buffer object containing a content whose type is this class. description_from_message : the message content to be encoded in the protocol buffer object. Returns : None","title":"encode"},{"location":"aea/api/helpers/search/models/#decode","text":"| @classmethod | decode ( cls , description_from_pb2 ) -> \"Description\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the content in the 'description_from_pb2' argument. Arguments : description_from_pb2 : the protocol buffer content object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'description_from_pb2' argument.","title":"decode"},{"location":"aea/api/helpers/search/models/#constrainttypes","text":"class ConstraintTypes ( Enum ) Types of constraint.","title":"ConstraintTypes"},{"location":"aea/api/helpers/search/models/#__str__","text":"| __str__ () Get the string representation.","title":"__str__"},{"location":"aea/api/helpers/search/models/#constrainttype","text":"class ConstraintType () Type of constraint. Used with the Constraint class, this class allows to specify constraint over attributes. Examples : Equal to three equal_3 = ConstraintType(ConstraintTypes.EQUAL, 3) You can also specify a type of constraint by using its string representation, e.g.: equal_3 = ConstraintType(\"==\", 3) not_equal_london = ConstraintType(\"!=\", \"London\") less_than_pi = ConstraintType(\"<\", 3.14) within_range = ConstraintType(\"within\", (-10.0, 10.0)) in_a_set = ConstraintType(\"in\", [1, 2, 3]) not_in_a_set = ConstraintType(\"not_in\", {\"C\", \"Java\", \"Python\"})","title":"ConstraintType"},{"location":"aea/api/helpers/search/models/#__init___3","text":"| __init__ ( type : Union [ ConstraintTypes , str ], value : Any ) Initialize a constraint type. Arguments : type : the type of the constraint. | Either an instance of the ConstraintTypes enum, | or a string representation associated with the type. value : the value that defines the constraint. Raises : ValueError : if the type of the constraint is not","title":"__init__"},{"location":"aea/api/helpers/search/models/#check","text":"| check ( value : ATTRIBUTE_TYPES ) -> bool Check if an attribute value satisfies the constraint. The implementation depends on the constraint type. Arguments : value : the value to check. Returns : True if the value satisfy the constraint, False otherwise. Raises : ValueError : if the constraint type is not recognized.","title":"check"},{"location":"aea/api/helpers/search/models/#__eq___3","text":"| __eq__ ( other ) Check equality with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#constraintexpr","text":"class ConstraintExpr ( ABC ) Implementation of the constraint language to query the OEF node.","title":"ConstraintExpr"},{"location":"aea/api/helpers/search/models/#check_1","text":"| @abstractmethod | check ( description : Description ) -> bool Check if a description satisfies the constraint expression. Arguments : description : the description to check. Returns : True if the description satisfy the constraint expression, False otherwise.","title":"check"},{"location":"aea/api/helpers/search/models/#and","text":"class And ( ConstraintExpr ) Implementation of the 'And' constraint expression.","title":"And"},{"location":"aea/api/helpers/search/models/#__init___4","text":"| __init__ ( constraints : List [ ConstraintExpr ]) Initialize an 'And' expression. Arguments : constraints : the list of constraints expression (in conjunction).","title":"__init__"},{"location":"aea/api/helpers/search/models/#check_2","text":"| check ( description : Description ) -> bool Check if a value satisfies the 'And' constraint expression. Arguments : description : the description to check. Returns : True if the description satisfy the constraint expression, False otherwise.","title":"check"},{"location":"aea/api/helpers/search/models/#__eq___4","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#or","text":"class Or ( ConstraintExpr ) Implementation of the 'Or' constraint expression.","title":"Or"},{"location":"aea/api/helpers/search/models/#__init___5","text":"| __init__ ( constraints : List [ ConstraintExpr ]) Initialize an 'Or' expression. Arguments : constraints : the list of constraints expressions (in disjunction).","title":"__init__"},{"location":"aea/api/helpers/search/models/#check_3","text":"| check ( description : Description ) -> bool Check if a value satisfies the 'Or' constraint expression. Arguments : description : the description to check. Returns : True if the description satisfy the constraint expression, False otherwise.","title":"check"},{"location":"aea/api/helpers/search/models/#__eq___5","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#not","text":"class Not ( ConstraintExpr ) Implementation of the 'Not' constraint expression.","title":"Not"},{"location":"aea/api/helpers/search/models/#__init___6","text":"| __init__ ( constraint : ConstraintExpr ) Initialize a 'Not' expression. Arguments : constraint : the constraint expression to negate.","title":"__init__"},{"location":"aea/api/helpers/search/models/#check_4","text":"| check ( description : Description ) -> bool Check if a value satisfies the 'Not; constraint expression. Arguments : description : the description to check. Returns : True if the description satisfy the constraint expression, False otherwise.","title":"check"},{"location":"aea/api/helpers/search/models/#__eq___6","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#constraint","text":"class Constraint ( ConstraintExpr ) The atomic component of a constraint expression.","title":"Constraint"},{"location":"aea/api/helpers/search/models/#__init___7","text":"| __init__ ( attribute_name : str , constraint_type : ConstraintType ) Initialize a constraint. Arguments : attribute_name : the name of the attribute to be constrained. constraint_type : the constraint type.","title":"__init__"},{"location":"aea/api/helpers/search/models/#check_5","text":"| check ( description : Description ) -> bool Check if a description satisfies the constraint. The implementation depends on the type of the constraint. Arguments : description : the description to check. Returns : True if the description satisfies the constraint, False otherwise. Examples: attr_author = Attribute(\"author\" , str, True, \"The author of the book.\") attr_year = Attribute(\"year\", int, True, \"The year of publication of the book.\") attr_genre = Attribute(\"genre\", str, True, \"The genre of the book.\") c1 = Constraint(\"author\", ConstraintType(\"==\", \"Stephen King\")) c2 = Constraint(\"year\", ConstraintType(\">\", 1990)) c3 = Constraint(\"genre\", ConstraintType(\"in\", {\"horror\", \"science_fiction\"})) book_1 = Description({\"author\": \"Stephen King\", \"year\": 1991, \"genre\": \"horror\"}) book_2 = Description({\"author\": \"George Orwell\", \"year\": 1948, \"genre\": \"horror\"}) The \"author\" attribute instantiation satisfies the constraint, so the result is True. c1.check(book_1) True Here, the \"author\" does not satisfy the constraints. Hence, the result is False. c1.check(book_2) False In this case, there is a missing field specified by the query, that is \"year\" So the result is False, even in the case it is not required by the schema: c2.check(Description({\"author\": \"Stephen King\"})) False If the type of some attribute of the description is not correct, the result is False. In this case, the field \"year\" has a string instead of an integer: c2.check(Description({\"author\": \"Stephen King\", \"year\": \"1991\"})) False c3.check(Description({\"author\": \"Stephen King\", \"genre\": False})) False","title":"check"},{"location":"aea/api/helpers/search/models/#__eq___7","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#query","text":"class Query () This class lets you build a query for the OEF.","title":"Query"},{"location":"aea/api/helpers/search/models/#__init___8","text":"| __init__ ( constraints : List [ ConstraintExpr ], model : Optional [ DataModel ] = None ) -> None Initialize a query. Arguments : constraints : a list of constraint expressions. model : the data model that the query refers to.","title":"__init__"},{"location":"aea/api/helpers/search/models/#check_6","text":"| check ( description : Description ) -> bool Check if a description satisfies the constraints of the query. The constraints are interpreted as conjunction. Arguments : description : the description to check. Returns : True if the description satisfies all the constraints, False otherwise.","title":"check"},{"location":"aea/api/helpers/search/models/#__eq___8","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#encode_1","text":"| @classmethod | encode ( cls , performative_content , query_from_message : \"Query\" ) -> None Encode an instance of this class into the protocol buffer object. The content in the 'performative_content' argument must be matched with the message content in the 'query_from_message' argument. Arguments : performative_content : the performative protocol buffer object containing a content whose type is this class. query_from_message : the message content to be encoded in the protocol buffer object. Returns : None","title":"encode"},{"location":"aea/api/helpers/search/models/#decode_1","text":"| @classmethod | decode ( cls , query_from_pb2 ) -> \"Query\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the content in the 'query_from_pb2' argument. Arguments : query_from_pb2 : the protocol buffer content object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'query_from_pb2' argument.","title":"decode"},{"location":"aea/api/identity/base/","text":"aea.identity.base This module contains the identity class. Identity class Identity () An identity are the public elements identifying an agent. It can include: - the agent name - the addresses __ init __ | __init__ ( name : str , address : Optional [ str ] = None , addresses : Optional [ Dict [ str , Address ]] = None , default_address_key : str = DEFAULT_ADDRESS_KEY ) Instantiate the identity. Arguments : name : the name of the agent. addresses : the addresses of the agent. default_address_key : the key for the default address name | @property | name () -> str Get the agent name. addresses | @property | addresses () -> Dict [ str , Address ] Get the addresses. address | @property | address () -> Address Get the default address.","title":"Base"},{"location":"aea/api/identity/base/#aeaidentitybase","text":"This module contains the identity class.","title":"aea.identity.base"},{"location":"aea/api/identity/base/#identity","text":"class Identity () An identity are the public elements identifying an agent. It can include: - the agent name - the addresses","title":"Identity"},{"location":"aea/api/identity/base/#__init__","text":"| __init__ ( name : str , address : Optional [ str ] = None , addresses : Optional [ Dict [ str , Address ]] = None , default_address_key : str = DEFAULT_ADDRESS_KEY ) Instantiate the identity. Arguments : name : the name of the agent. addresses : the addresses of the agent. default_address_key : the key for the default address","title":"__init__"},{"location":"aea/api/identity/base/#name","text":"| @property | name () -> str Get the agent name.","title":"name"},{"location":"aea/api/identity/base/#addresses","text":"| @property | addresses () -> Dict [ str , Address ] Get the addresses.","title":"addresses"},{"location":"aea/api/identity/base/#address","text":"| @property | address () -> Address Get the default address.","title":"address"},{"location":"aea/api/mail/base/","text":"aea.mail.base Mail module abstract base classes. AEAConnectionError class AEAConnectionError ( Exception ) Exception class for connection errors. Empty class Empty ( Exception ) Exception for when the inbox is empty. URI class URI () URI following RFC3986. __ init __ | __init__ ( uri_raw : str ) Initialize the URI. Arguments : uri_raw : the raw form uri Raises : ValueError : if uri_raw is not RFC3986 compliant scheme | @property | scheme () -> str Get the scheme. netloc | @property | netloc () -> str Get the netloc. path | @property | path () -> str Get the path. params | @property | params () -> str Get the params. query | @property | query () -> str Get the query. fragment | @property | fragment () -> str Get the fragment. username | @property | username () -> Optional [ str ] Get the username. password | @property | password () -> Optional [ str ] Get the password. host | @property | host () -> Optional [ str ] Get the host. port | @property | port () -> Optional [ int ] Get the port. __ str __ | __str__ () Get string representation. __ eq __ | __eq__ ( other ) Compare with another object. EnvelopeContext class EnvelopeContext () Extra information for the handling of an envelope. __ init __ | __init__ ( connection_id : Optional [ PublicId ] = None , uri : Optional [ URI ] = None ) Initialize the envelope context. uri _ raw | @property | uri_raw () -> str Get uri in string format. __ eq __ | __eq__ ( other ) Compare with another object. EnvelopeSerializer class EnvelopeSerializer ( ABC ) This abstract class let the devloper to specify serialization layer for the envelope. encode | @abstractmethod | encode ( envelope : \"Envelope\" ) -> bytes Encode the envelope. decode | @abstractmethod | decode ( envelope_bytes : bytes ) -> \"Envelope\" Decode the envelope. ProtobufEnvelopeSerializer class ProtobufEnvelopeSerializer ( EnvelopeSerializer ) Envelope serializer using Protobuf. encode | encode ( envelope : \"Envelope\" ) -> bytes Encode the envelope. decode | decode ( envelope_bytes : bytes ) -> \"Envelope\" Decode the envelope. Envelope class Envelope () The top level message class. __ init __ | __init__ ( to : Address , sender : Address , protocol_id : ProtocolId , message : bytes , context : Optional [ EnvelopeContext ] = None ) Initialize a Message object. Arguments : to : the address of the receiver. sender : the address of the sender. protocol_id : the protocol id. message : the protocol-specific message to | @to . setter | to ( to : Address ) -> None Set address of receiver. sender | @sender . setter | sender ( sender : Address ) -> None Set address of sender. protocol _ id | @protocol_id . setter | protocol_id ( protocol_id : ProtocolId ) -> None Set the protocol id. message | @message . setter | message ( message : bytes ) -> None Set the message. context | @property | context () -> Optional [ EnvelopeContext ] Get the envelope context. __ eq __ | __eq__ ( other ) Compare with another object. encode | encode ( serializer : Optional [ EnvelopeSerializer ] = None ) -> bytes Encode the envelope. Arguments : serializer : the serializer that implements the encoding procedure. Returns : the encoded envelope. decode | @classmethod | decode ( cls , envelope_bytes : bytes , serializer : Optional [ EnvelopeSerializer ] = None ) -> \"Envelope\" Decode the envelope. Arguments : envelope_bytes : the bytes to be decoded. serializer : the serializer that implements the decoding procedure. Returns : the decoded envelope. __ str __ | __str__ () Get the string representation of an envelope. Multiplexer class Multiplexer () This class can handle multiple connections at once. __ init __ | __init__ ( connections : Sequence [ \"Connection\" ], default_connection_index : int = 0 , loop : Optional [ AbstractEventLoop ] = None ) Initialize the connection multiplexer. Arguments : connections : a sequence of connections. default_connection_index : the index of the connection to use as default. | this information is used for envelopes which | don't specify any routing context. loop : the event loop to run the multiplexer. If None, a new event loop is created. in _ queue | @property | in_queue () -> queue . Queue Get the in queue. out _ queue | @property | out_queue () -> asyncio . Queue Get the out queue. connections | @property | connections () -> Tuple [ \"Connection\" ] Get the connections. is _ connected | @property | is_connected () -> bool Check whether the multiplexer is processing messages. connection _ status | @property | connection_status () -> ConnectionStatus Get the connection status. connect | connect () -> None Connect the multiplexer. disconnect | disconnect () -> None Disconnect the multiplexer. get | get ( block : bool = False , timeout : Optional [ float ] = None ) -> Optional [ Envelope ] Get an envelope within a timeout. Arguments : block : make the call blocking (ignore the timeout). timeout : the timeout to wait until an envelope is received. Returns : the envelope, or None if no envelope is available within a timeout. put | put ( envelope : Envelope ) -> None Schedule an envelope for sending it. Notice that the output queue is an asyncio.Queue which uses an event loop running on a different thread than the one used in this function. Arguments : envelope : the envelope to be sent. Returns : None InBox class InBox () A queue from where you can only consume messages. __ init __ | __init__ ( multiplexer : Multiplexer ) Initialize the inbox. Arguments : multiplexer : the multiplexer empty | empty () -> bool Check for a envelope on the in queue. Returns : boolean indicating whether there is a message or not get | get ( block : bool = False , timeout : Optional [ float ] = None ) -> Envelope Check for a envelope on the in queue. Arguments : block : make the call blocking (ignore the timeout). timeout : times out the block after timeout seconds. Returns : the envelope object. Raises : Empty : if the attempt to get a message fails. get _ nowait | get_nowait () -> Optional [ Envelope ] Check for a envelope on the in queue and wait for no time. Returns : the envelope object OutBox class OutBox () A queue from where you can only enqueue messages. __ init __ | __init__ ( multiplexer : Multiplexer ) Initialize the outbox. Arguments : multiplexer : the multiplexer empty | empty () -> bool Check for a envelope on the in queue. Returns : boolean indicating whether there is a message or not put | put ( envelope : Envelope ) -> None Put an envelope into the queue. Arguments : envelope : the envelope. Returns : None put _ message | put_message ( to : Address , sender : Address , protocol_id : ProtocolId , message : bytes ) -> None Put a message in the outbox. Arguments : to : the recipient of the message. sender : the sender of the message. protocol_id : the protocol id. message : the content of the message. Returns : None","title":"Base"},{"location":"aea/api/mail/base/#aeamailbase","text":"Mail module abstract base classes.","title":"aea.mail.base"},{"location":"aea/api/mail/base/#aeaconnectionerror","text":"class AEAConnectionError ( Exception ) Exception class for connection errors.","title":"AEAConnectionError"},{"location":"aea/api/mail/base/#empty","text":"class Empty ( Exception ) Exception for when the inbox is empty.","title":"Empty"},{"location":"aea/api/mail/base/#uri","text":"class URI () URI following RFC3986.","title":"URI"},{"location":"aea/api/mail/base/#__init__","text":"| __init__ ( uri_raw : str ) Initialize the URI. Arguments : uri_raw : the raw form uri Raises : ValueError : if uri_raw is not RFC3986 compliant","title":"__init__"},{"location":"aea/api/mail/base/#scheme","text":"| @property | scheme () -> str Get the scheme.","title":"scheme"},{"location":"aea/api/mail/base/#netloc","text":"| @property | netloc () -> str Get the netloc.","title":"netloc"},{"location":"aea/api/mail/base/#path","text":"| @property | path () -> str Get the path.","title":"path"},{"location":"aea/api/mail/base/#params","text":"| @property | params () -> str Get the params.","title":"params"},{"location":"aea/api/mail/base/#query","text":"| @property | query () -> str Get the query.","title":"query"},{"location":"aea/api/mail/base/#fragment","text":"| @property | fragment () -> str Get the fragment.","title":"fragment"},{"location":"aea/api/mail/base/#username","text":"| @property | username () -> Optional [ str ] Get the username.","title":"username"},{"location":"aea/api/mail/base/#password","text":"| @property | password () -> Optional [ str ] Get the password.","title":"password"},{"location":"aea/api/mail/base/#host","text":"| @property | host () -> Optional [ str ] Get the host.","title":"host"},{"location":"aea/api/mail/base/#port","text":"| @property | port () -> Optional [ int ] Get the port.","title":"port"},{"location":"aea/api/mail/base/#__str__","text":"| __str__ () Get string representation.","title":"__str__"},{"location":"aea/api/mail/base/#__eq__","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/mail/base/#envelopecontext","text":"class EnvelopeContext () Extra information for the handling of an envelope.","title":"EnvelopeContext"},{"location":"aea/api/mail/base/#__init___1","text":"| __init__ ( connection_id : Optional [ PublicId ] = None , uri : Optional [ URI ] = None ) Initialize the envelope context.","title":"__init__"},{"location":"aea/api/mail/base/#uri_raw","text":"| @property | uri_raw () -> str Get uri in string format.","title":"uri_raw"},{"location":"aea/api/mail/base/#__eq___1","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/mail/base/#envelopeserializer","text":"class EnvelopeSerializer ( ABC ) This abstract class let the devloper to specify serialization layer for the envelope.","title":"EnvelopeSerializer"},{"location":"aea/api/mail/base/#encode","text":"| @abstractmethod | encode ( envelope : \"Envelope\" ) -> bytes Encode the envelope.","title":"encode"},{"location":"aea/api/mail/base/#decode","text":"| @abstractmethod | decode ( envelope_bytes : bytes ) -> \"Envelope\" Decode the envelope.","title":"decode"},{"location":"aea/api/mail/base/#protobufenvelopeserializer","text":"class ProtobufEnvelopeSerializer ( EnvelopeSerializer ) Envelope serializer using Protobuf.","title":"ProtobufEnvelopeSerializer"},{"location":"aea/api/mail/base/#encode_1","text":"| encode ( envelope : \"Envelope\" ) -> bytes Encode the envelope.","title":"encode"},{"location":"aea/api/mail/base/#decode_1","text":"| decode ( envelope_bytes : bytes ) -> \"Envelope\" Decode the envelope.","title":"decode"},{"location":"aea/api/mail/base/#envelope","text":"class Envelope () The top level message class.","title":"Envelope"},{"location":"aea/api/mail/base/#__init___2","text":"| __init__ ( to : Address , sender : Address , protocol_id : ProtocolId , message : bytes , context : Optional [ EnvelopeContext ] = None ) Initialize a Message object. Arguments : to : the address of the receiver. sender : the address of the sender. protocol_id : the protocol id. message : the protocol-specific message","title":"__init__"},{"location":"aea/api/mail/base/#to","text":"| @to . setter | to ( to : Address ) -> None Set address of receiver.","title":"to"},{"location":"aea/api/mail/base/#sender","text":"| @sender . setter | sender ( sender : Address ) -> None Set address of sender.","title":"sender"},{"location":"aea/api/mail/base/#protocol_id","text":"| @protocol_id . setter | protocol_id ( protocol_id : ProtocolId ) -> None Set the protocol id.","title":"protocol_id"},{"location":"aea/api/mail/base/#message","text":"| @message . setter | message ( message : bytes ) -> None Set the message.","title":"message"},{"location":"aea/api/mail/base/#context","text":"| @property | context () -> Optional [ EnvelopeContext ] Get the envelope context.","title":"context"},{"location":"aea/api/mail/base/#__eq___2","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/mail/base/#encode_2","text":"| encode ( serializer : Optional [ EnvelopeSerializer ] = None ) -> bytes Encode the envelope. Arguments : serializer : the serializer that implements the encoding procedure. Returns : the encoded envelope.","title":"encode"},{"location":"aea/api/mail/base/#decode_2","text":"| @classmethod | decode ( cls , envelope_bytes : bytes , serializer : Optional [ EnvelopeSerializer ] = None ) -> \"Envelope\" Decode the envelope. Arguments : envelope_bytes : the bytes to be decoded. serializer : the serializer that implements the decoding procedure. Returns : the decoded envelope.","title":"decode"},{"location":"aea/api/mail/base/#__str___1","text":"| __str__ () Get the string representation of an envelope.","title":"__str__"},{"location":"aea/api/mail/base/#multiplexer","text":"class Multiplexer () This class can handle multiple connections at once.","title":"Multiplexer"},{"location":"aea/api/mail/base/#__init___3","text":"| __init__ ( connections : Sequence [ \"Connection\" ], default_connection_index : int = 0 , loop : Optional [ AbstractEventLoop ] = None ) Initialize the connection multiplexer. Arguments : connections : a sequence of connections. default_connection_index : the index of the connection to use as default. | this information is used for envelopes which | don't specify any routing context. loop : the event loop to run the multiplexer. If None, a new event loop is created.","title":"__init__"},{"location":"aea/api/mail/base/#in_queue","text":"| @property | in_queue () -> queue . Queue Get the in queue.","title":"in_queue"},{"location":"aea/api/mail/base/#out_queue","text":"| @property | out_queue () -> asyncio . Queue Get the out queue.","title":"out_queue"},{"location":"aea/api/mail/base/#connections","text":"| @property | connections () -> Tuple [ \"Connection\" ] Get the connections.","title":"connections"},{"location":"aea/api/mail/base/#is_connected","text":"| @property | is_connected () -> bool Check whether the multiplexer is processing messages.","title":"is_connected"},{"location":"aea/api/mail/base/#connection_status","text":"| @property | connection_status () -> ConnectionStatus Get the connection status.","title":"connection_status"},{"location":"aea/api/mail/base/#connect","text":"| connect () -> None Connect the multiplexer.","title":"connect"},{"location":"aea/api/mail/base/#disconnect","text":"| disconnect () -> None Disconnect the multiplexer.","title":"disconnect"},{"location":"aea/api/mail/base/#get","text":"| get ( block : bool = False , timeout : Optional [ float ] = None ) -> Optional [ Envelope ] Get an envelope within a timeout. Arguments : block : make the call blocking (ignore the timeout). timeout : the timeout to wait until an envelope is received. Returns : the envelope, or None if no envelope is available within a timeout.","title":"get"},{"location":"aea/api/mail/base/#put","text":"| put ( envelope : Envelope ) -> None Schedule an envelope for sending it. Notice that the output queue is an asyncio.Queue which uses an event loop running on a different thread than the one used in this function. Arguments : envelope : the envelope to be sent. Returns : None","title":"put"},{"location":"aea/api/mail/base/#inbox","text":"class InBox () A queue from where you can only consume messages.","title":"InBox"},{"location":"aea/api/mail/base/#__init___4","text":"| __init__ ( multiplexer : Multiplexer ) Initialize the inbox. Arguments : multiplexer : the multiplexer","title":"__init__"},{"location":"aea/api/mail/base/#empty_1","text":"| empty () -> bool Check for a envelope on the in queue. Returns : boolean indicating whether there is a message or not","title":"empty"},{"location":"aea/api/mail/base/#get_1","text":"| get ( block : bool = False , timeout : Optional [ float ] = None ) -> Envelope Check for a envelope on the in queue. Arguments : block : make the call blocking (ignore the timeout). timeout : times out the block after timeout seconds. Returns : the envelope object. Raises : Empty : if the attempt to get a message fails.","title":"get"},{"location":"aea/api/mail/base/#get_nowait","text":"| get_nowait () -> Optional [ Envelope ] Check for a envelope on the in queue and wait for no time. Returns : the envelope object","title":"get_nowait"},{"location":"aea/api/mail/base/#outbox","text":"class OutBox () A queue from where you can only enqueue messages.","title":"OutBox"},{"location":"aea/api/mail/base/#__init___5","text":"| __init__ ( multiplexer : Multiplexer ) Initialize the outbox. Arguments : multiplexer : the multiplexer","title":"__init__"},{"location":"aea/api/mail/base/#empty_2","text":"| empty () -> bool Check for a envelope on the in queue. Returns : boolean indicating whether there is a message or not","title":"empty"},{"location":"aea/api/mail/base/#put_1","text":"| put ( envelope : Envelope ) -> None Put an envelope into the queue. Arguments : envelope : the envelope. Returns : None","title":"put"},{"location":"aea/api/mail/base/#put_message","text":"| put_message ( to : Address , sender : Address , protocol_id : ProtocolId , message : bytes ) -> None Put a message in the outbox. Arguments : to : the recipient of the message. sender : the sender of the message. protocol_id : the protocol id. message : the content of the message. Returns : None","title":"put_message"},{"location":"aea/api/protocols/base/","text":"aea.protocols.base This module contains the base message and serialization definition. Message class Message () This class implements a message. __ init __ | __init__ ( body : Optional [ Dict ] = None , ** kwargs ) Initialize a Message object. Arguments : body : the dictionary of values to hold. kwargs : any additional value to add to the body. It will overwrite the body values. counterparty | @counterparty . setter | counterparty ( counterparty : Address ) -> None Set the counterparty of the message. body | @body . setter | body ( body : Dict ) -> None Set the body of hte message. Arguments : body : the body. Returns : None set | set ( key : str , value : Any ) -> None Set key and value pair. Arguments : key : the key. value : the value. Returns : None get | get ( key : str ) -> Optional [ Any ] Get value for key. unset | unset ( key : str ) -> None Unset valye for key. is _ set | is_set ( key : str ) -> bool Check value is set for key. __ eq __ | __eq__ ( other ) Compare with another object. __ str __ | __str__ () Get the string representation of the message. Encoder class Encoder ( ABC ) Encoder interface. encode | @abstractmethod | encode ( msg : Message ) -> bytes Encode a message. Arguments : msg : the message to be encoded. Returns : the encoded message. Decoder class Decoder ( ABC ) Decoder interface. decode | @abstractmethod | decode ( obj : bytes ) -> Message Decode a message. Arguments : obj : the sequence of bytes to be decoded. Returns : the decoded message. Serializer class Serializer ( Encoder , Decoder , ABC ) The implementations of this class defines a serialization layer for a protocol. ProtobufSerializer class ProtobufSerializer ( Serializer ) Default Protobuf serializer. It assumes that the Message contains a JSON-serializable body. encode | encode ( msg : Message ) -> bytes Encode a message into bytes using Protobuf. decode | decode ( obj : bytes ) -> Message Decode bytes into a message using Protobuf. JSONSerializer class JSONSerializer ( Serializer ) Default serialization in JSON for the Message object. It assumes that the Message contains a JSON-serializable body. encode | encode ( msg : Message ) -> bytes Encode a message into bytes using JSON format. Arguments : msg : the message to be encoded. Returns : the serialized message. decode | decode ( obj : bytes ) -> Message Decode bytes into a message using JSON. Arguments : obj : the serialized message. Returns : the decoded message. Protocol class Protocol ( ABC ) This class implements a specifications for a protocol. It includes a serializer to encode/decode a message. __ init __ | __init__ ( protocol_id : ProtocolId , serializer : Serializer , config : ProtocolConfig ) Initialize the protocol manager. Arguments : protocol_id : the protocol id. serializer : the serializer. config : the protocol configurations. id | @property | id () -> ProtocolId Get the name. serializer | @property | serializer () -> Serializer Get the serializer. config | @property | config () -> ProtocolConfig Get the configuration. from _ dir | @classmethod | from_dir ( cls , directory : str ) -> \"Protocol\" Load a protocol from a directory. Arguments : directory : the skill directory. agent_context : the agent's context Returns : the Protocol object. Raises : Exception : if the parsing failed.","title":"Base"},{"location":"aea/api/protocols/base/#aeaprotocolsbase","text":"This module contains the base message and serialization definition.","title":"aea.protocols.base"},{"location":"aea/api/protocols/base/#message","text":"class Message () This class implements a message.","title":"Message"},{"location":"aea/api/protocols/base/#__init__","text":"| __init__ ( body : Optional [ Dict ] = None , ** kwargs ) Initialize a Message object. Arguments : body : the dictionary of values to hold. kwargs : any additional value to add to the body. It will overwrite the body values.","title":"__init__"},{"location":"aea/api/protocols/base/#counterparty","text":"| @counterparty . setter | counterparty ( counterparty : Address ) -> None Set the counterparty of the message.","title":"counterparty"},{"location":"aea/api/protocols/base/#body","text":"| @body . setter | body ( body : Dict ) -> None Set the body of hte message. Arguments : body : the body. Returns : None","title":"body"},{"location":"aea/api/protocols/base/#set","text":"| set ( key : str , value : Any ) -> None Set key and value pair. Arguments : key : the key. value : the value. Returns : None","title":"set"},{"location":"aea/api/protocols/base/#get","text":"| get ( key : str ) -> Optional [ Any ] Get value for key.","title":"get"},{"location":"aea/api/protocols/base/#unset","text":"| unset ( key : str ) -> None Unset valye for key.","title":"unset"},{"location":"aea/api/protocols/base/#is_set","text":"| is_set ( key : str ) -> bool Check value is set for key.","title":"is_set"},{"location":"aea/api/protocols/base/#__eq__","text":"| __eq__ ( other ) Compare with another object.","title":"__eq__"},{"location":"aea/api/protocols/base/#__str__","text":"| __str__ () Get the string representation of the message.","title":"__str__"},{"location":"aea/api/protocols/base/#encoder","text":"class Encoder ( ABC ) Encoder interface.","title":"Encoder"},{"location":"aea/api/protocols/base/#encode","text":"| @abstractmethod | encode ( msg : Message ) -> bytes Encode a message. Arguments : msg : the message to be encoded. Returns : the encoded message.","title":"encode"},{"location":"aea/api/protocols/base/#decoder","text":"class Decoder ( ABC ) Decoder interface.","title":"Decoder"},{"location":"aea/api/protocols/base/#decode","text":"| @abstractmethod | decode ( obj : bytes ) -> Message Decode a message. Arguments : obj : the sequence of bytes to be decoded. Returns : the decoded message.","title":"decode"},{"location":"aea/api/protocols/base/#serializer","text":"class Serializer ( Encoder , Decoder , ABC ) The implementations of this class defines a serialization layer for a protocol.","title":"Serializer"},{"location":"aea/api/protocols/base/#protobufserializer","text":"class ProtobufSerializer ( Serializer ) Default Protobuf serializer. It assumes that the Message contains a JSON-serializable body.","title":"ProtobufSerializer"},{"location":"aea/api/protocols/base/#encode_1","text":"| encode ( msg : Message ) -> bytes Encode a message into bytes using Protobuf.","title":"encode"},{"location":"aea/api/protocols/base/#decode_1","text":"| decode ( obj : bytes ) -> Message Decode bytes into a message using Protobuf.","title":"decode"},{"location":"aea/api/protocols/base/#jsonserializer","text":"class JSONSerializer ( Serializer ) Default serialization in JSON for the Message object. It assumes that the Message contains a JSON-serializable body.","title":"JSONSerializer"},{"location":"aea/api/protocols/base/#encode_2","text":"| encode ( msg : Message ) -> bytes Encode a message into bytes using JSON format. Arguments : msg : the message to be encoded. Returns : the serialized message.","title":"encode"},{"location":"aea/api/protocols/base/#decode_2","text":"| decode ( obj : bytes ) -> Message Decode bytes into a message using JSON. Arguments : obj : the serialized message. Returns : the decoded message.","title":"decode"},{"location":"aea/api/protocols/base/#protocol","text":"class Protocol ( ABC ) This class implements a specifications for a protocol. It includes a serializer to encode/decode a message.","title":"Protocol"},{"location":"aea/api/protocols/base/#__init___1","text":"| __init__ ( protocol_id : ProtocolId , serializer : Serializer , config : ProtocolConfig ) Initialize the protocol manager. Arguments : protocol_id : the protocol id. serializer : the serializer. config : the protocol configurations.","title":"__init__"},{"location":"aea/api/protocols/base/#id","text":"| @property | id () -> ProtocolId Get the name.","title":"id"},{"location":"aea/api/protocols/base/#serializer_1","text":"| @property | serializer () -> Serializer Get the serializer.","title":"serializer"},{"location":"aea/api/protocols/base/#config","text":"| @property | config () -> ProtocolConfig Get the configuration.","title":"config"},{"location":"aea/api/protocols/base/#from_dir","text":"| @classmethod | from_dir ( cls , directory : str ) -> \"Protocol\" Load a protocol from a directory. Arguments : directory : the skill directory. agent_context : the agent's context Returns : the Protocol object. Raises : Exception : if the parsing failed.","title":"from_dir"},{"location":"aea/api/protocols/default/message/","text":"aea.protocols.default.message This module contains default's message definition. DefaultMessage class DefaultMessage ( Message ) A protocol for exchanging any bytes message. Performative class Performative ( Enum ) Performatives for the default protocol. __ str __ | __str__ () Get the string representation. __ init __ | __init__ ( dialogue_reference : Tuple [ str , str ], message_id : int , target : int , performative : Performative , ** kwargs , ,) Initialise an instance of DefaultMessage. Arguments : message_id : the message id. dialogue_reference : the dialogue reference. target : the message target. performative : the message performative. valid _ performatives | @property | valid_performatives () -> Set [ str ] Get valid performatives. dialogue _ reference | @property | dialogue_reference () -> Tuple [ str , str ] Get the dialogue_reference of the message. message _ id | @property | message_id () -> int Get the message_id of the message. performative | @property | performative () -> Performative Get the performative of the message. target | @property | target () -> int Get the target of the message. content | @property | content () -> bytes Get the 'content' content from the message. error _ code | @property | error_code () -> CustomErrorCode Get the 'error_code' content from the message. error _ data | @property | error_data () -> Dict [ str , bytes ] Get the 'error_data' content from the message. error _ msg | @property | error_msg () -> str Get the 'error_msg' content from the message.","title":"Message"},{"location":"aea/api/protocols/default/message/#aeaprotocolsdefaultmessage","text":"This module contains default's message definition.","title":"aea.protocols.default.message"},{"location":"aea/api/protocols/default/message/#defaultmessage","text":"class DefaultMessage ( Message ) A protocol for exchanging any bytes message.","title":"DefaultMessage"},{"location":"aea/api/protocols/default/message/#performative","text":"class Performative ( Enum ) Performatives for the default protocol.","title":"Performative"},{"location":"aea/api/protocols/default/message/#__str__","text":"| __str__ () Get the string representation.","title":"__str__"},{"location":"aea/api/protocols/default/message/#__init__","text":"| __init__ ( dialogue_reference : Tuple [ str , str ], message_id : int , target : int , performative : Performative , ** kwargs , ,) Initialise an instance of DefaultMessage. Arguments : message_id : the message id. dialogue_reference : the dialogue reference. target : the message target. performative : the message performative.","title":"__init__"},{"location":"aea/api/protocols/default/message/#valid_performatives","text":"| @property | valid_performatives () -> Set [ str ] Get valid performatives.","title":"valid_performatives"},{"location":"aea/api/protocols/default/message/#dialogue_reference","text":"| @property | dialogue_reference () -> Tuple [ str , str ] Get the dialogue_reference of the message.","title":"dialogue_reference"},{"location":"aea/api/protocols/default/message/#message_id","text":"| @property | message_id () -> int Get the message_id of the message.","title":"message_id"},{"location":"aea/api/protocols/default/message/#performative_1","text":"| @property | performative () -> Performative Get the performative of the message.","title":"performative"},{"location":"aea/api/protocols/default/message/#target","text":"| @property | target () -> int Get the target of the message.","title":"target"},{"location":"aea/api/protocols/default/message/#content","text":"| @property | content () -> bytes Get the 'content' content from the message.","title":"content"},{"location":"aea/api/protocols/default/message/#error_code","text":"| @property | error_code () -> CustomErrorCode Get the 'error_code' content from the message.","title":"error_code"},{"location":"aea/api/protocols/default/message/#error_data","text":"| @property | error_data () -> Dict [ str , bytes ] Get the 'error_data' content from the message.","title":"error_data"},{"location":"aea/api/protocols/default/message/#error_msg","text":"| @property | error_msg () -> str Get the 'error_msg' content from the message.","title":"error_msg"},{"location":"aea/api/protocols/default/serialization/","text":"aea.protocols.default.serialization Serialization module for default protocol. DefaultSerializer class DefaultSerializer ( Serializer ) Serialization for the 'default' protocol. encode | encode ( msg : Message ) -> bytes Encode a 'Default' message into bytes. Arguments : msg : the message object. Returns : the bytes. decode | decode ( obj : bytes ) -> Message Decode bytes into a 'Default' message. Arguments : obj : the bytes object. Returns : the 'Default' message.","title":"Serialization"},{"location":"aea/api/protocols/default/serialization/#aeaprotocolsdefaultserialization","text":"Serialization module for default protocol.","title":"aea.protocols.default.serialization"},{"location":"aea/api/protocols/default/serialization/#defaultserializer","text":"class DefaultSerializer ( Serializer ) Serialization for the 'default' protocol.","title":"DefaultSerializer"},{"location":"aea/api/protocols/default/serialization/#encode","text":"| encode ( msg : Message ) -> bytes Encode a 'Default' message into bytes. Arguments : msg : the message object. Returns : the bytes.","title":"encode"},{"location":"aea/api/protocols/default/serialization/#decode","text":"| decode ( obj : bytes ) -> Message Decode bytes into a 'Default' message. Arguments : obj : the bytes object. Returns : the 'Default' message.","title":"decode"},{"location":"aea/api/registries/base/","text":"aea.registries.base This module contains registries. Registry class Registry ( Generic [ ItemId , Item ], ABC ) This class implements an abstract registry. register | @abstractmethod | register ( item_id : ItemId , item : Item ) -> None Register an item. Arguments : item_id : the public id of the item. item : the item. Returns : None :raises: ValueError if an item is already registered with that item id. unregister | @abstractmethod | unregister ( item_id : ItemId ) -> None Unregister an item. Arguments : item_id : the public id of the item. Returns : None :raises: ValueError if no item registered with that item id. fetch | @abstractmethod | fetch ( item_id : ItemId ) -> Optional [ Item ] Fetch an item. Arguments : item_id : the public id of the item. Returns : the Item fetch _ all | @abstractmethod | fetch_all () -> List [ Item ] Fetch all the items. Returns : the list of items. setup | @abstractmethod | setup () -> None Set up registry. Returns : None teardown | @abstractmethod | teardown () -> None Teardown the registry. Returns : None ProtocolRegistry class ProtocolRegistry ( Registry [ PublicId , Protocol ]) This class implements the handlers registry. __ init __ | __init__ () -> None Instantiate the registry. Returns : None register | register ( item_id : PublicId , protocol : Protocol ) -> None Register a protocol. Arguments : item_id : the public id of the protocol. protocol : the protocol object. unregister | unregister ( protocol_id : ProtocolId ) -> None Unregister a protocol. fetch | fetch ( protocol_id : ProtocolId ) -> Optional [ Protocol ] Fetch the protocol for the envelope. Arguments : protocol_id : the protocol id Returns : the protocol id or None if the protocol is not registered fetch _ all | fetch_all () -> List [ Protocol ] Fetch all the protocols. populate | populate ( directory : str , allowed_protocols : Optional [ Set [ PublicId ]] = None ) -> None Load the handlers as specified in the config and apply consistency checks. Arguments : directory : the filepath to the agent's resource directory. allowed_protocols : an optional set of allowed protocols (public ids_. If None, every protocol is allowed. Returns : None setup | setup () -> None Set up the registry. Returns : None teardown | teardown () -> None Teardown the registry. Returns : None ComponentRegistry class ComponentRegistry ( Registry [ Tuple [ SkillId , str ], SkillComponentType ], Generic [ SkillComponentType ]) This class implements a generic registry for skill components. __ init __ | __init__ () -> None Instantiate the registry. Returns : None register | register ( item_id : Tuple [ SkillId , str ], item : SkillComponentType ) -> None Register a item. Arguments : item_id : a pair (skill id, item name). item : the item to register. Returns : None :raises: ValueError if an item is already registered with that item id. unregister | unregister ( item_id : Tuple [ SkillId , str ]) -> None Unregister a item. Arguments : item_id : a pair (skill id, item name). Returns : None :raises: ValueError if no item registered with that item id. fetch | fetch ( item_id : Tuple [ SkillId , str ]) -> Optional [ SkillComponentType ] Fetch an item. Arguments : item_id : the public id of the item. Returns : the Item fetch _ by _ skill | fetch_by_skill ( skill_id : SkillId ) -> List [ Item ] Fetch all the items of a given skill. fetch _ all | fetch_all () -> List [ SkillComponentType ] Fetch all the items. unregister _ by _ skill | unregister_by_skill ( skill_id : SkillId ) -> None Unregister all the components by skill. setup | setup () -> None Set up the items in the registry. Returns : None teardown | teardown () -> None Teardown the registry. Returns : None HandlerRegistry class HandlerRegistry ( ComponentRegistry [ Handler ]) This class implements the handlers registry. __ init __ | __init__ () -> None Instantiate the registry. Returns : None register | register ( item_id : Tuple [ SkillId , str ], item : Handler ) -> None Register a handler. Arguments : item_id : the item id. item : the handler. Returns : None Raises : ValueError : if the protocol is None, or an item with pair (skill_id, protocol_id_ already exists. unregister | unregister ( item_id : Tuple [ SkillId , str ]) -> None Unregister a item. Arguments : item_id : a pair (skill id, item name). Returns : None :raises: ValueError if no item is registered with that item id. unregister _ by _ skill | unregister_by_skill ( skill_id : SkillId ) -> None Unregister all the components by skill. fetch _ by _ protocol | fetch_by_protocol ( protocol_id : ProtocolId ) -> List [ Handler ] Fetch the handler by the pair protocol id and skill id. Arguments : protocol_id : the protocol id Returns : the handlers registered for the protocol_id and skill_id fetch _ by _ protocol _ and _ skill | fetch_by_protocol_and_skill ( protocol_id : ProtocolId , skill_id : SkillId ) -> Optional [ Handler ] Fetch the handler by the pair protocol id and skill id. Arguments : protocol_id : the protocol id skill_id : the skill id. Returns : the handlers registered for the protocol_id and skill_id fetch _ internal _ handler | fetch_internal_handler ( skill_id : SkillId ) -> Optional [ Handler ] Fetch the internal handler. Arguments : skill_id : the skill id Returns : the internal handler registered for the skill id Resources class Resources () This class implements the resources of an AEA. __ init __ | __init__ ( directory : Optional [ Union [ str , os . PathLike ]] = None ) Instantiate the resources. directory | @property | directory () -> str Get the directory. load | load ( agent_context : AgentContext ) -> None Load all the resources. populate _ skills | populate_skills ( directory : str , agent_context : AgentContext , allowed_skills : Optional [ Set [ PublicId ]] = None ) -> None Populate skills. Arguments : directory : the agent's resources directory. agent_context : the agent's context object allowed_skills : an optional set of allowed skills (public ids). If None, every skill is allowed. Returns : None add _ skill | add_skill ( skill : Skill ) Add a skill to the set of resources. add _ protocol | add_protocol ( protocol : Protocol ) Add a protocol to the set of resources. get _ skill | get_skill ( skill_id : SkillId ) -> Optional [ Skill ] Get the skill. get _ all _ skills | get_all_skills () -> List [ Skill ] Get the list of all the skills. Returns : the list of skills. remove _ skill | remove_skill ( skill_id : SkillId ) Remove a skill from the set of resources. setup | setup () Set up the resources. Returns : None teardown | teardown () Teardown the resources. Returns : None Filter class Filter () This class implements the filter of an AEA. __ init __ | __init__ ( resources : Resources , decision_maker_out_queue : Queue ) Instantiate the filter. Arguments : resources : the resources decision_maker_out_queue : the decision maker queue resources | @property | resources () -> Resources Get resources. decision _ maker _ out _ queue | @property | decision_maker_out_queue () -> Queue Get decision maker (out) queue. get _ active _ handlers | get_active_handlers ( protocol_id : PublicId , envelope_context : Optional [ EnvelopeContext ]) -> List [ Handler ] Get active handlers. Arguments : protocol_id : the protocol id :param envelope context: the envelope context Returns : the list of handlers currently active get _ active _ behaviours | get_active_behaviours () -> List [ Behaviour ] Get the active behaviours. Returns : the list of behaviours currently active handle _ internal _ messages | handle_internal_messages () -> None Handle the messages from the decision maker. Returns : None","title":"Base"},{"location":"aea/api/registries/base/#aearegistriesbase","text":"This module contains registries.","title":"aea.registries.base"},{"location":"aea/api/registries/base/#registry","text":"class Registry ( Generic [ ItemId , Item ], ABC ) This class implements an abstract registry.","title":"Registry"},{"location":"aea/api/registries/base/#register","text":"| @abstractmethod | register ( item_id : ItemId , item : Item ) -> None Register an item. Arguments : item_id : the public id of the item. item : the item. Returns : None :raises: ValueError if an item is already registered with that item id.","title":"register"},{"location":"aea/api/registries/base/#unregister","text":"| @abstractmethod | unregister ( item_id : ItemId ) -> None Unregister an item. Arguments : item_id : the public id of the item. Returns : None :raises: ValueError if no item registered with that item id.","title":"unregister"},{"location":"aea/api/registries/base/#fetch","text":"| @abstractmethod | fetch ( item_id : ItemId ) -> Optional [ Item ] Fetch an item. Arguments : item_id : the public id of the item. Returns : the Item","title":"fetch"},{"location":"aea/api/registries/base/#fetch_all","text":"| @abstractmethod | fetch_all () -> List [ Item ] Fetch all the items. Returns : the list of items.","title":"fetch_all"},{"location":"aea/api/registries/base/#setup","text":"| @abstractmethod | setup () -> None Set up registry. Returns : None","title":"setup"},{"location":"aea/api/registries/base/#teardown","text":"| @abstractmethod | teardown () -> None Teardown the registry. Returns : None","title":"teardown"},{"location":"aea/api/registries/base/#protocolregistry","text":"class ProtocolRegistry ( Registry [ PublicId , Protocol ]) This class implements the handlers registry.","title":"ProtocolRegistry"},{"location":"aea/api/registries/base/#__init__","text":"| __init__ () -> None Instantiate the registry. Returns : None","title":"__init__"},{"location":"aea/api/registries/base/#register_1","text":"| register ( item_id : PublicId , protocol : Protocol ) -> None Register a protocol. Arguments : item_id : the public id of the protocol. protocol : the protocol object.","title":"register"},{"location":"aea/api/registries/base/#unregister_1","text":"| unregister ( protocol_id : ProtocolId ) -> None Unregister a protocol.","title":"unregister"},{"location":"aea/api/registries/base/#fetch_1","text":"| fetch ( protocol_id : ProtocolId ) -> Optional [ Protocol ] Fetch the protocol for the envelope. Arguments : protocol_id : the protocol id Returns : the protocol id or None if the protocol is not registered","title":"fetch"},{"location":"aea/api/registries/base/#fetch_all_1","text":"| fetch_all () -> List [ Protocol ] Fetch all the protocols.","title":"fetch_all"},{"location":"aea/api/registries/base/#populate","text":"| populate ( directory : str , allowed_protocols : Optional [ Set [ PublicId ]] = None ) -> None Load the handlers as specified in the config and apply consistency checks. Arguments : directory : the filepath to the agent's resource directory. allowed_protocols : an optional set of allowed protocols (public ids_. If None, every protocol is allowed. Returns : None","title":"populate"},{"location":"aea/api/registries/base/#setup_1","text":"| setup () -> None Set up the registry. Returns : None","title":"setup"},{"location":"aea/api/registries/base/#teardown_1","text":"| teardown () -> None Teardown the registry. Returns : None","title":"teardown"},{"location":"aea/api/registries/base/#componentregistry","text":"class ComponentRegistry ( Registry [ Tuple [ SkillId , str ], SkillComponentType ], Generic [ SkillComponentType ]) This class implements a generic registry for skill components.","title":"ComponentRegistry"},{"location":"aea/api/registries/base/#__init___1","text":"| __init__ () -> None Instantiate the registry. Returns : None","title":"__init__"},{"location":"aea/api/registries/base/#register_2","text":"| register ( item_id : Tuple [ SkillId , str ], item : SkillComponentType ) -> None Register a item. Arguments : item_id : a pair (skill id, item name). item : the item to register. Returns : None :raises: ValueError if an item is already registered with that item id.","title":"register"},{"location":"aea/api/registries/base/#unregister_2","text":"| unregister ( item_id : Tuple [ SkillId , str ]) -> None Unregister a item. Arguments : item_id : a pair (skill id, item name). Returns : None :raises: ValueError if no item registered with that item id.","title":"unregister"},{"location":"aea/api/registries/base/#fetch_2","text":"| fetch ( item_id : Tuple [ SkillId , str ]) -> Optional [ SkillComponentType ] Fetch an item. Arguments : item_id : the public id of the item. Returns : the Item","title":"fetch"},{"location":"aea/api/registries/base/#fetch_by_skill","text":"| fetch_by_skill ( skill_id : SkillId ) -> List [ Item ] Fetch all the items of a given skill.","title":"fetch_by_skill"},{"location":"aea/api/registries/base/#fetch_all_2","text":"| fetch_all () -> List [ SkillComponentType ] Fetch all the items.","title":"fetch_all"},{"location":"aea/api/registries/base/#unregister_by_skill","text":"| unregister_by_skill ( skill_id : SkillId ) -> None Unregister all the components by skill.","title":"unregister_by_skill"},{"location":"aea/api/registries/base/#setup_2","text":"| setup () -> None Set up the items in the registry. Returns : None","title":"setup"},{"location":"aea/api/registries/base/#teardown_2","text":"| teardown () -> None Teardown the registry. Returns : None","title":"teardown"},{"location":"aea/api/registries/base/#handlerregistry","text":"class HandlerRegistry ( ComponentRegistry [ Handler ]) This class implements the handlers registry.","title":"HandlerRegistry"},{"location":"aea/api/registries/base/#__init___2","text":"| __init__ () -> None Instantiate the registry. Returns : None","title":"__init__"},{"location":"aea/api/registries/base/#register_3","text":"| register ( item_id : Tuple [ SkillId , str ], item : Handler ) -> None Register a handler. Arguments : item_id : the item id. item : the handler. Returns : None Raises : ValueError : if the protocol is None, or an item with pair (skill_id, protocol_id_ already exists.","title":"register"},{"location":"aea/api/registries/base/#unregister_3","text":"| unregister ( item_id : Tuple [ SkillId , str ]) -> None Unregister a item. Arguments : item_id : a pair (skill id, item name). Returns : None :raises: ValueError if no item is registered with that item id.","title":"unregister"},{"location":"aea/api/registries/base/#unregister_by_skill_1","text":"| unregister_by_skill ( skill_id : SkillId ) -> None Unregister all the components by skill.","title":"unregister_by_skill"},{"location":"aea/api/registries/base/#fetch_by_protocol","text":"| fetch_by_protocol ( protocol_id : ProtocolId ) -> List [ Handler ] Fetch the handler by the pair protocol id and skill id. Arguments : protocol_id : the protocol id Returns : the handlers registered for the protocol_id and skill_id","title":"fetch_by_protocol"},{"location":"aea/api/registries/base/#fetch_by_protocol_and_skill","text":"| fetch_by_protocol_and_skill ( protocol_id : ProtocolId , skill_id : SkillId ) -> Optional [ Handler ] Fetch the handler by the pair protocol id and skill id. Arguments : protocol_id : the protocol id skill_id : the skill id. Returns : the handlers registered for the protocol_id and skill_id","title":"fetch_by_protocol_and_skill"},{"location":"aea/api/registries/base/#fetch_internal_handler","text":"| fetch_internal_handler ( skill_id : SkillId ) -> Optional [ Handler ] Fetch the internal handler. Arguments : skill_id : the skill id Returns : the internal handler registered for the skill id","title":"fetch_internal_handler"},{"location":"aea/api/registries/base/#resources","text":"class Resources () This class implements the resources of an AEA.","title":"Resources"},{"location":"aea/api/registries/base/#__init___3","text":"| __init__ ( directory : Optional [ Union [ str , os . PathLike ]] = None ) Instantiate the resources.","title":"__init__"},{"location":"aea/api/registries/base/#directory","text":"| @property | directory () -> str Get the directory.","title":"directory"},{"location":"aea/api/registries/base/#load","text":"| load ( agent_context : AgentContext ) -> None Load all the resources.","title":"load"},{"location":"aea/api/registries/base/#populate_skills","text":"| populate_skills ( directory : str , agent_context : AgentContext , allowed_skills : Optional [ Set [ PublicId ]] = None ) -> None Populate skills. Arguments : directory : the agent's resources directory. agent_context : the agent's context object allowed_skills : an optional set of allowed skills (public ids). If None, every skill is allowed. Returns : None","title":"populate_skills"},{"location":"aea/api/registries/base/#add_skill","text":"| add_skill ( skill : Skill ) Add a skill to the set of resources.","title":"add_skill"},{"location":"aea/api/registries/base/#add_protocol","text":"| add_protocol ( protocol : Protocol ) Add a protocol to the set of resources.","title":"add_protocol"},{"location":"aea/api/registries/base/#get_skill","text":"| get_skill ( skill_id : SkillId ) -> Optional [ Skill ] Get the skill.","title":"get_skill"},{"location":"aea/api/registries/base/#get_all_skills","text":"| get_all_skills () -> List [ Skill ] Get the list of all the skills. Returns : the list of skills.","title":"get_all_skills"},{"location":"aea/api/registries/base/#remove_skill","text":"| remove_skill ( skill_id : SkillId ) Remove a skill from the set of resources.","title":"remove_skill"},{"location":"aea/api/registries/base/#setup_3","text":"| setup () Set up the resources. Returns : None","title":"setup"},{"location":"aea/api/registries/base/#teardown_3","text":"| teardown () Teardown the resources. Returns : None","title":"teardown"},{"location":"aea/api/registries/base/#filter","text":"class Filter () This class implements the filter of an AEA.","title":"Filter"},{"location":"aea/api/registries/base/#__init___4","text":"| __init__ ( resources : Resources , decision_maker_out_queue : Queue ) Instantiate the filter. Arguments : resources : the resources decision_maker_out_queue : the decision maker queue","title":"__init__"},{"location":"aea/api/registries/base/#resources_1","text":"| @property | resources () -> Resources Get resources.","title":"resources"},{"location":"aea/api/registries/base/#decision_maker_out_queue","text":"| @property | decision_maker_out_queue () -> Queue Get decision maker (out) queue.","title":"decision_maker_out_queue"},{"location":"aea/api/registries/base/#get_active_handlers","text":"| get_active_handlers ( protocol_id : PublicId , envelope_context : Optional [ EnvelopeContext ]) -> List [ Handler ] Get active handlers. Arguments : protocol_id : the protocol id :param envelope context: the envelope context Returns : the list of handlers currently active","title":"get_active_handlers"},{"location":"aea/api/registries/base/#get_active_behaviours","text":"| get_active_behaviours () -> List [ Behaviour ] Get the active behaviours. Returns : the list of behaviours currently active","title":"get_active_behaviours"},{"location":"aea/api/registries/base/#handle_internal_messages","text":"| handle_internal_messages () -> None Handle the messages from the decision maker. Returns : None","title":"handle_internal_messages"},{"location":"aea/api/skills/base/","text":"aea.skills.base This module contains the base classes for the skills. SkillContext class SkillContext () This class implements the context of a skill. __ init __ | __init__ ( agent_context : AgentContext ) Initialize a skill context. Arguments : agent_context : the agent's context shared _ state | @property | shared_state () -> Dict [ str , Any ] Get the shared state dictionary. agent _ name | @property | agent_name () -> str Get agent name. skill _ id | @property | skill_id () Get the skill id of the skill context. is _ active | @is_active . setter | is_active ( value : bool ) Set the status of the skill (active/not active). new _ behaviours | @property | new_behaviours () -> Queue The queue for the new behaviours. This queue can be used to send messages to the framework to request the registration of a behaviour. :return the queue of new behaviours. agent _ addresses | @property | agent_addresses () -> Dict [ str , str ] Get addresses. agent _ address | @property | agent_address () -> str Get address. connection _ status | @property | connection_status () -> ConnectionStatus Get connection status. outbox | @property | outbox () -> OutBox Get outbox. message _ in _ queue | @property | message_in_queue () -> Queue Get message in queue. decision _ maker _ message _ queue | @property | decision_maker_message_queue () -> Queue Get message queue of decision maker. agent _ ownership _ state | @property | agent_ownership_state () -> OwnershipState Get ownership state. agent _ preferences | @property | agent_preferences () -> Preferences Get preferences. agent _ goal _ pursuit _ readiness | @property | agent_goal_pursuit_readiness () -> GoalPursuitReadiness Get the goal pursuit readiness. task _ manager | @property | task_manager () -> TaskManager Get behaviours of the skill. ledger _ apis | @property | ledger_apis () -> LedgerApis Get ledger APIs. search _ service _ address | @property | search_service_address () -> Address Get the address of the search service. handlers | @property | handlers () -> SimpleNamespace Get handlers of the skill. behaviours | @property | behaviours () -> SimpleNamespace Get behaviours of the skill. logger | @property | logger () -> Logger Get the logger. __ getattr __ | __getattr__ ( item ) -> Any Get attribute. SkillComponent class SkillComponent ( ABC ) This class defines an abstract interface for skill component classes. __ init __ | __init__ ( ** kwargs ) Initialize a behaviour. Arguments : skill_context : the skill context kwargs : keyword arguments name | @property | name () -> str Get the name of the skill component. context | @property | context () -> SkillContext Get the context of the behaviour. skill _ id | @property | skill_id () -> PublicId Get the skill id of the skill component. config | @property | config () -> Dict [ Any , Any ] Get the config of the behaviour. setup | @abstractmethod | setup () -> None Implement the behaviour setup. Returns : None teardown | @abstractmethod | teardown () -> None Implement the behaviour teardown. Returns : None parse _ module | @classmethod | @abstractmethod | parse_module ( cls , path : str , configs : Dict [ str , Any ], skill_context : SkillContext ) Parse the component module. Behaviour class Behaviour ( SkillComponent ) This class implements an abstract behaviour. __ init __ | __init__ ( ** kwargs ) Initialize a behaviour. act | @abstractmethod | act () -> None Implement the behaviour. Returns : None is _ done | is_done () -> bool Return True if the behaviour is terminated, False otherwise. act _ wrapper | act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework. parse _ module | @classmethod | parse_module ( cls , path : str , behaviour_configs : Dict [ str , BehaviourConfig ], skill_context : SkillContext ) -> Dict [ str , \"Behaviour\" ] Parse the behaviours module. Arguments : path : path to the Python module containing the Behaviour classes. behaviour_configs : a list of behaviour configurations. skill_context : the skill context Returns : a list of Behaviour. Handler class Handler ( SkillComponent ) This class implements an abstract behaviour. __ init __ | __init__ ( ** kwargs ) Initialize a handler object. handle | @abstractmethod | handle ( message : Message ) -> None Implement the reaction to a message. Arguments : message : the message Returns : None parse _ module | @classmethod | parse_module ( cls , path : str , handler_configs : Dict [ str , HandlerConfig ], skill_context : SkillContext ) -> Dict [ str , \"Handler\" ] Parse the handler module. Arguments : path : path to the Python module containing the Handler class. handler_configs : the list of handler configurations. skill_context : the skill context Returns : an handler, or None if the parsing fails. Model class Model ( SkillComponent ) This class implements an abstract model. __ init __ | __init__ ( ** kwargs ) Initialize a model. Arguments : kwargs : keyword arguments. setup | setup () -> None Set the class up. teardown | teardown () -> None Tear the class down. parse _ module | @classmethod | parse_module ( cls , path : str , model_configs : Dict [ str , ModelConfig ], skill_context : SkillContext ) -> Dict [ str , \"Model\" ] Parse the tasks module. Arguments : path : path to the Python skill module. model_configs : a list of model configurations. skill_context : the skill context Returns : a list of Model. Skill class Skill () This class implements a skill. __ init __ | __init__ ( config : SkillConfig , skill_context : SkillContext , handlers : Optional [ Dict [ str , Handler ]], behaviours : Optional [ Dict [ str , Behaviour ]], models : Optional [ Dict [ str , Model ]]) Initialize a skill. Arguments : config : the skill configuration. handlers : the list of handlers to handle incoming envelopes. behaviours : the list of behaviours that defines the proactive component of the agent. models : the list of models shared across tasks, behaviours and from _ dir | @classmethod | from_dir ( cls , directory : str , agent_context : AgentContext ) -> \"Skill\" Load a skill from a directory. Arguments : directory : the skill directory. agent_context : the agent's context Returns : the Skill object. Raises : Exception : if the parsing failed.","title":"Base"},{"location":"aea/api/skills/base/#aeaskillsbase","text":"This module contains the base classes for the skills.","title":"aea.skills.base"},{"location":"aea/api/skills/base/#skillcontext","text":"class SkillContext () This class implements the context of a skill.","title":"SkillContext"},{"location":"aea/api/skills/base/#__init__","text":"| __init__ ( agent_context : AgentContext ) Initialize a skill context. Arguments : agent_context : the agent's context","title":"__init__"},{"location":"aea/api/skills/base/#shared_state","text":"| @property | shared_state () -> Dict [ str , Any ] Get the shared state dictionary.","title":"shared_state"},{"location":"aea/api/skills/base/#agent_name","text":"| @property | agent_name () -> str Get agent name.","title":"agent_name"},{"location":"aea/api/skills/base/#skill_id","text":"| @property | skill_id () Get the skill id of the skill context.","title":"skill_id"},{"location":"aea/api/skills/base/#is_active","text":"| @is_active . setter | is_active ( value : bool ) Set the status of the skill (active/not active).","title":"is_active"},{"location":"aea/api/skills/base/#new_behaviours","text":"| @property | new_behaviours () -> Queue The queue for the new behaviours. This queue can be used to send messages to the framework to request the registration of a behaviour. :return the queue of new behaviours.","title":"new_behaviours"},{"location":"aea/api/skills/base/#agent_addresses","text":"| @property | agent_addresses () -> Dict [ str , str ] Get addresses.","title":"agent_addresses"},{"location":"aea/api/skills/base/#agent_address","text":"| @property | agent_address () -> str Get address.","title":"agent_address"},{"location":"aea/api/skills/base/#connection_status","text":"| @property | connection_status () -> ConnectionStatus Get connection status.","title":"connection_status"},{"location":"aea/api/skills/base/#outbox","text":"| @property | outbox () -> OutBox Get outbox.","title":"outbox"},{"location":"aea/api/skills/base/#message_in_queue","text":"| @property | message_in_queue () -> Queue Get message in queue.","title":"message_in_queue"},{"location":"aea/api/skills/base/#decision_maker_message_queue","text":"| @property | decision_maker_message_queue () -> Queue Get message queue of decision maker.","title":"decision_maker_message_queue"},{"location":"aea/api/skills/base/#agent_ownership_state","text":"| @property | agent_ownership_state () -> OwnershipState Get ownership state.","title":"agent_ownership_state"},{"location":"aea/api/skills/base/#agent_preferences","text":"| @property | agent_preferences () -> Preferences Get preferences.","title":"agent_preferences"},{"location":"aea/api/skills/base/#agent_goal_pursuit_readiness","text":"| @property | agent_goal_pursuit_readiness () -> GoalPursuitReadiness Get the goal pursuit readiness.","title":"agent_goal_pursuit_readiness"},{"location":"aea/api/skills/base/#task_manager","text":"| @property | task_manager () -> TaskManager Get behaviours of the skill.","title":"task_manager"},{"location":"aea/api/skills/base/#ledger_apis","text":"| @property | ledger_apis () -> LedgerApis Get ledger APIs.","title":"ledger_apis"},{"location":"aea/api/skills/base/#search_service_address","text":"| @property | search_service_address () -> Address Get the address of the search service.","title":"search_service_address"},{"location":"aea/api/skills/base/#handlers","text":"| @property | handlers () -> SimpleNamespace Get handlers of the skill.","title":"handlers"},{"location":"aea/api/skills/base/#behaviours","text":"| @property | behaviours () -> SimpleNamespace Get behaviours of the skill.","title":"behaviours"},{"location":"aea/api/skills/base/#logger","text":"| @property | logger () -> Logger Get the logger.","title":"logger"},{"location":"aea/api/skills/base/#__getattr__","text":"| __getattr__ ( item ) -> Any Get attribute.","title":"__getattr__"},{"location":"aea/api/skills/base/#skillcomponent","text":"class SkillComponent ( ABC ) This class defines an abstract interface for skill component classes.","title":"SkillComponent"},{"location":"aea/api/skills/base/#__init___1","text":"| __init__ ( ** kwargs ) Initialize a behaviour. Arguments : skill_context : the skill context kwargs : keyword arguments","title":"__init__"},{"location":"aea/api/skills/base/#name","text":"| @property | name () -> str Get the name of the skill component.","title":"name"},{"location":"aea/api/skills/base/#context","text":"| @property | context () -> SkillContext Get the context of the behaviour.","title":"context"},{"location":"aea/api/skills/base/#skill_id_1","text":"| @property | skill_id () -> PublicId Get the skill id of the skill component.","title":"skill_id"},{"location":"aea/api/skills/base/#config","text":"| @property | config () -> Dict [ Any , Any ] Get the config of the behaviour.","title":"config"},{"location":"aea/api/skills/base/#setup","text":"| @abstractmethod | setup () -> None Implement the behaviour setup. Returns : None","title":"setup"},{"location":"aea/api/skills/base/#teardown","text":"| @abstractmethod | teardown () -> None Implement the behaviour teardown. Returns : None","title":"teardown"},{"location":"aea/api/skills/base/#parse_module","text":"| @classmethod | @abstractmethod | parse_module ( cls , path : str , configs : Dict [ str , Any ], skill_context : SkillContext ) Parse the component module.","title":"parse_module"},{"location":"aea/api/skills/base/#behaviour","text":"class Behaviour ( SkillComponent ) This class implements an abstract behaviour.","title":"Behaviour"},{"location":"aea/api/skills/base/#__init___2","text":"| __init__ ( ** kwargs ) Initialize a behaviour.","title":"__init__"},{"location":"aea/api/skills/base/#act","text":"| @abstractmethod | act () -> None Implement the behaviour. Returns : None","title":"act"},{"location":"aea/api/skills/base/#is_done","text":"| is_done () -> bool Return True if the behaviour is terminated, False otherwise.","title":"is_done"},{"location":"aea/api/skills/base/#act_wrapper","text":"| act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework.","title":"act_wrapper"},{"location":"aea/api/skills/base/#parse_module_1","text":"| @classmethod | parse_module ( cls , path : str , behaviour_configs : Dict [ str , BehaviourConfig ], skill_context : SkillContext ) -> Dict [ str , \"Behaviour\" ] Parse the behaviours module. Arguments : path : path to the Python module containing the Behaviour classes. behaviour_configs : a list of behaviour configurations. skill_context : the skill context Returns : a list of Behaviour.","title":"parse_module"},{"location":"aea/api/skills/base/#handler","text":"class Handler ( SkillComponent ) This class implements an abstract behaviour.","title":"Handler"},{"location":"aea/api/skills/base/#__init___3","text":"| __init__ ( ** kwargs ) Initialize a handler object.","title":"__init__"},{"location":"aea/api/skills/base/#handle","text":"| @abstractmethod | handle ( message : Message ) -> None Implement the reaction to a message. Arguments : message : the message Returns : None","title":"handle"},{"location":"aea/api/skills/base/#parse_module_2","text":"| @classmethod | parse_module ( cls , path : str , handler_configs : Dict [ str , HandlerConfig ], skill_context : SkillContext ) -> Dict [ str , \"Handler\" ] Parse the handler module. Arguments : path : path to the Python module containing the Handler class. handler_configs : the list of handler configurations. skill_context : the skill context Returns : an handler, or None if the parsing fails.","title":"parse_module"},{"location":"aea/api/skills/base/#model","text":"class Model ( SkillComponent ) This class implements an abstract model.","title":"Model"},{"location":"aea/api/skills/base/#__init___4","text":"| __init__ ( ** kwargs ) Initialize a model. Arguments : kwargs : keyword arguments.","title":"__init__"},{"location":"aea/api/skills/base/#setup_1","text":"| setup () -> None Set the class up.","title":"setup"},{"location":"aea/api/skills/base/#teardown_1","text":"| teardown () -> None Tear the class down.","title":"teardown"},{"location":"aea/api/skills/base/#parse_module_3","text":"| @classmethod | parse_module ( cls , path : str , model_configs : Dict [ str , ModelConfig ], skill_context : SkillContext ) -> Dict [ str , \"Model\" ] Parse the tasks module. Arguments : path : path to the Python skill module. model_configs : a list of model configurations. skill_context : the skill context Returns : a list of Model.","title":"parse_module"},{"location":"aea/api/skills/base/#skill","text":"class Skill () This class implements a skill.","title":"Skill"},{"location":"aea/api/skills/base/#__init___5","text":"| __init__ ( config : SkillConfig , skill_context : SkillContext , handlers : Optional [ Dict [ str , Handler ]], behaviours : Optional [ Dict [ str , Behaviour ]], models : Optional [ Dict [ str , Model ]]) Initialize a skill. Arguments : config : the skill configuration. handlers : the list of handlers to handle incoming envelopes. behaviours : the list of behaviours that defines the proactive component of the agent. models : the list of models shared across tasks, behaviours and","title":"__init__"},{"location":"aea/api/skills/base/#from_dir","text":"| @classmethod | from_dir ( cls , directory : str , agent_context : AgentContext ) -> \"Skill\" Load a skill from a directory. Arguments : directory : the skill directory. agent_context : the agent's context Returns : the Skill object. Raises : Exception : if the parsing failed.","title":"from_dir"},{"location":"aea/api/skills/behaviours/","text":"aea.skills.behaviours This module contains the classes for specific behaviours. SimpleBehaviour class SimpleBehaviour ( Behaviour , ABC ) This class implements a simple behaviour. __ init __ | __init__ ( act : Optional [ Callable [[], None ]] = None , ** kwargs ) Initialize a simple behaviour. Arguments : act : the act callable. kwargs : the keyword arguments to be passed to the parent class. setup | setup () -> None Set the behaviour up. act | act () -> None Do the action. teardown | teardown () -> None Tear the behaviour down. CompositeBehaviour class CompositeBehaviour ( Behaviour , ABC ) This class implements a composite behaviour. CyclicBehaviour class CyclicBehaviour ( SimpleBehaviour , ABC ) This behaviour is executed until the agent is stopped. __ init __ | __init__ ( ** kwargs ) Initialize the cyclic behaviour. act _ wrapper | act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework. is _ done | is_done () -> bool Return True if the behaviour is terminated, False otherwise. The user should implement it properly to determine the stopping condition. OneShotBehaviour class OneShotBehaviour ( SimpleBehaviour , ABC ) This behaviour is executed only once. __ init __ | __init__ ( ** kwargs ) Initialize the cyclic behaviour. is _ done | is_done () -> bool Return True if the behaviour is terminated, False otherwise. act _ wrapper | act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework. TickerBehaviour class TickerBehaviour ( SimpleBehaviour , ABC ) This behaviour is executed periodically with an interval. __ init __ | __init__ ( tick_interval : float = 1.0 , start_at : Optional [ datetime . datetime ] = None , ** kwargs ) Initialize the ticker behaviour. Arguments : tick_interval : interval of the behaviour in seconds. start_at : whether to start the behaviour with an offset. tick _ interval | @property | tick_interval () -> float Get the tick_interval in seconds. start _ at | @property | start_at () -> datetime . datetime Get the start time. last _ act _ time | @property | last_act_time () -> datetime . datetime Get the last time the act method has been called. act _ wrapper | act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework. is _ time _ to _ act | is_time_to_act () -> bool Check whether it is time to act, according to the tick_interval constraint and the 'start at' constraint. Returns : True if it is time to act, false otherwise. SequenceBehaviour class SequenceBehaviour ( CompositeBehaviour , ABC ) This behaviour executes sub-behaviour serially. __ init __ | __init__ ( behaviour_sequence : List [ Behaviour ], ** kwargs ) Initialize the sequence behaviour. Arguments : behaviour_sequence : the sequence of behaviour. kwargs : current _ behaviour | @property | current_behaviour () -> Optional [ Behaviour ] Get the current behaviour. If None, the sequence behaviour can be considered done. act | act () -> None Implement the behaviour. is _ done | is_done () -> bool Return True if the behaviour is terminated, False otherwise. State class State ( SimpleBehaviour , ABC ) A state of a FSMBehaviour. A State behaviour is a simple behaviour with a special property 'event' that is opportunely set by the implementer. The event is read by the framework when the behaviour is done in order to pick the transition to trigger. __ init __ | __init__ ( ** kwargs ) Initialize a state of the state machine. event | @property | event () -> Optional [ str ] Get the event to be triggered at the end of the behaviour. is _ done | @abstractmethod | is_done () -> bool Return True if the behaviour is terminated, False otherwise. reset | reset () -> None Reset initial conditions. FSMBehaviour class FSMBehaviour ( CompositeBehaviour , ABC ) This class implements a finite-state machine behaviour. __ init __ | __init__ ( ** kwargs ) Initialize the finite-state machine behaviour. is _ started | @property | is_started () -> bool Check if the behaviour is started. register _ state | register_state ( name : str , state : State , initial : bool = False ) -> None Register a state. Arguments : name : the name of the state. state : the behaviour in that state. initial : whether the state is an initial state. Returns : None Raises : ValueError : if a state with the provided name already exists. register _ final _ state | register_final_state ( name : str , state : State ) -> None Register a final state. Arguments : name : the name of the state. state : the state. Returns : None Raises : ValueError : if a state with the provided name already exists. unregister _ state | unregister_state ( name : str ) -> None Unregister a state. Arguments : name : the state name to unregister. Returns : None Raises : ValueError : if the state is not registered. states | @property | states () -> Set [ str ] Get all the state names. initial _ state | @initial_state . setter | initial_state ( name : str ) Set the initial state. final _ states | @property | final_states () -> Set [ str ] Get the final state names. get _ state | get_state ( name ) -> Optional [ State ] Get a state from its name. act | act () Implement the behaviour. is _ done | is_done () -> bool Return True if the behaviour is terminated, False otherwise. register _ transition | register_transition ( source : str , destination : str , event : Optional [ str ] = None ) Register a transition. No sanity check is done. Arguments : source : the source state name. destination : the destination state name. event : the event. Returns : None Raises : ValueError : if a transition from source with event is already present. unregister _ transition | unregister_transition ( source : str , destination : str , event : Optional [ str ] = None ) Unregister a transition. Arguments : source : the source state name. destination : the destination state name. event : the event. Returns : None Raises : ValueError : if a transition from source with event is not present.","title":"Behaviors"},{"location":"aea/api/skills/behaviours/#aeaskillsbehaviours","text":"This module contains the classes for specific behaviours.","title":"aea.skills.behaviours"},{"location":"aea/api/skills/behaviours/#simplebehaviour","text":"class SimpleBehaviour ( Behaviour , ABC ) This class implements a simple behaviour.","title":"SimpleBehaviour"},{"location":"aea/api/skills/behaviours/#__init__","text":"| __init__ ( act : Optional [ Callable [[], None ]] = None , ** kwargs ) Initialize a simple behaviour. Arguments : act : the act callable. kwargs : the keyword arguments to be passed to the parent class.","title":"__init__"},{"location":"aea/api/skills/behaviours/#setup","text":"| setup () -> None Set the behaviour up.","title":"setup"},{"location":"aea/api/skills/behaviours/#act","text":"| act () -> None Do the action.","title":"act"},{"location":"aea/api/skills/behaviours/#teardown","text":"| teardown () -> None Tear the behaviour down.","title":"teardown"},{"location":"aea/api/skills/behaviours/#compositebehaviour","text":"class CompositeBehaviour ( Behaviour , ABC ) This class implements a composite behaviour.","title":"CompositeBehaviour"},{"location":"aea/api/skills/behaviours/#cyclicbehaviour","text":"class CyclicBehaviour ( SimpleBehaviour , ABC ) This behaviour is executed until the agent is stopped.","title":"CyclicBehaviour"},{"location":"aea/api/skills/behaviours/#__init___1","text":"| __init__ ( ** kwargs ) Initialize the cyclic behaviour.","title":"__init__"},{"location":"aea/api/skills/behaviours/#act_wrapper","text":"| act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework.","title":"act_wrapper"},{"location":"aea/api/skills/behaviours/#is_done","text":"| is_done () -> bool Return True if the behaviour is terminated, False otherwise. The user should implement it properly to determine the stopping condition.","title":"is_done"},{"location":"aea/api/skills/behaviours/#oneshotbehaviour","text":"class OneShotBehaviour ( SimpleBehaviour , ABC ) This behaviour is executed only once.","title":"OneShotBehaviour"},{"location":"aea/api/skills/behaviours/#__init___2","text":"| __init__ ( ** kwargs ) Initialize the cyclic behaviour.","title":"__init__"},{"location":"aea/api/skills/behaviours/#is_done_1","text":"| is_done () -> bool Return True if the behaviour is terminated, False otherwise.","title":"is_done"},{"location":"aea/api/skills/behaviours/#act_wrapper_1","text":"| act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework.","title":"act_wrapper"},{"location":"aea/api/skills/behaviours/#tickerbehaviour","text":"class TickerBehaviour ( SimpleBehaviour , ABC ) This behaviour is executed periodically with an interval.","title":"TickerBehaviour"},{"location":"aea/api/skills/behaviours/#__init___3","text":"| __init__ ( tick_interval : float = 1.0 , start_at : Optional [ datetime . datetime ] = None , ** kwargs ) Initialize the ticker behaviour. Arguments : tick_interval : interval of the behaviour in seconds. start_at : whether to start the behaviour with an offset.","title":"__init__"},{"location":"aea/api/skills/behaviours/#tick_interval","text":"| @property | tick_interval () -> float Get the tick_interval in seconds.","title":"tick_interval"},{"location":"aea/api/skills/behaviours/#start_at","text":"| @property | start_at () -> datetime . datetime Get the start time.","title":"start_at"},{"location":"aea/api/skills/behaviours/#last_act_time","text":"| @property | last_act_time () -> datetime . datetime Get the last time the act method has been called.","title":"last_act_time"},{"location":"aea/api/skills/behaviours/#act_wrapper_2","text":"| act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework.","title":"act_wrapper"},{"location":"aea/api/skills/behaviours/#is_time_to_act","text":"| is_time_to_act () -> bool Check whether it is time to act, according to the tick_interval constraint and the 'start at' constraint. Returns : True if it is time to act, false otherwise.","title":"is_time_to_act"},{"location":"aea/api/skills/behaviours/#sequencebehaviour","text":"class SequenceBehaviour ( CompositeBehaviour , ABC ) This behaviour executes sub-behaviour serially.","title":"SequenceBehaviour"},{"location":"aea/api/skills/behaviours/#__init___4","text":"| __init__ ( behaviour_sequence : List [ Behaviour ], ** kwargs ) Initialize the sequence behaviour. Arguments : behaviour_sequence : the sequence of behaviour. kwargs :","title":"__init__"},{"location":"aea/api/skills/behaviours/#current_behaviour","text":"| @property | current_behaviour () -> Optional [ Behaviour ] Get the current behaviour. If None, the sequence behaviour can be considered done.","title":"current_behaviour"},{"location":"aea/api/skills/behaviours/#act_1","text":"| act () -> None Implement the behaviour.","title":"act"},{"location":"aea/api/skills/behaviours/#is_done_2","text":"| is_done () -> bool Return True if the behaviour is terminated, False otherwise.","title":"is_done"},{"location":"aea/api/skills/behaviours/#state","text":"class State ( SimpleBehaviour , ABC ) A state of a FSMBehaviour. A State behaviour is a simple behaviour with a special property 'event' that is opportunely set by the implementer. The event is read by the framework when the behaviour is done in order to pick the transition to trigger.","title":"State"},{"location":"aea/api/skills/behaviours/#__init___5","text":"| __init__ ( ** kwargs ) Initialize a state of the state machine.","title":"__init__"},{"location":"aea/api/skills/behaviours/#event","text":"| @property | event () -> Optional [ str ] Get the event to be triggered at the end of the behaviour.","title":"event"},{"location":"aea/api/skills/behaviours/#is_done_3","text":"| @abstractmethod | is_done () -> bool Return True if the behaviour is terminated, False otherwise.","title":"is_done"},{"location":"aea/api/skills/behaviours/#reset","text":"| reset () -> None Reset initial conditions.","title":"reset"},{"location":"aea/api/skills/behaviours/#fsmbehaviour","text":"class FSMBehaviour ( CompositeBehaviour , ABC ) This class implements a finite-state machine behaviour.","title":"FSMBehaviour"},{"location":"aea/api/skills/behaviours/#__init___6","text":"| __init__ ( ** kwargs ) Initialize the finite-state machine behaviour.","title":"__init__"},{"location":"aea/api/skills/behaviours/#is_started","text":"| @property | is_started () -> bool Check if the behaviour is started.","title":"is_started"},{"location":"aea/api/skills/behaviours/#register_state","text":"| register_state ( name : str , state : State , initial : bool = False ) -> None Register a state. Arguments : name : the name of the state. state : the behaviour in that state. initial : whether the state is an initial state. Returns : None Raises : ValueError : if a state with the provided name already exists.","title":"register_state"},{"location":"aea/api/skills/behaviours/#register_final_state","text":"| register_final_state ( name : str , state : State ) -> None Register a final state. Arguments : name : the name of the state. state : the state. Returns : None Raises : ValueError : if a state with the provided name already exists.","title":"register_final_state"},{"location":"aea/api/skills/behaviours/#unregister_state","text":"| unregister_state ( name : str ) -> None Unregister a state. Arguments : name : the state name to unregister. Returns : None Raises : ValueError : if the state is not registered.","title":"unregister_state"},{"location":"aea/api/skills/behaviours/#states","text":"| @property | states () -> Set [ str ] Get all the state names.","title":"states"},{"location":"aea/api/skills/behaviours/#initial_state","text":"| @initial_state . setter | initial_state ( name : str ) Set the initial state.","title":"initial_state"},{"location":"aea/api/skills/behaviours/#final_states","text":"| @property | final_states () -> Set [ str ] Get the final state names.","title":"final_states"},{"location":"aea/api/skills/behaviours/#get_state","text":"| get_state ( name ) -> Optional [ State ] Get a state from its name.","title":"get_state"},{"location":"aea/api/skills/behaviours/#act_2","text":"| act () Implement the behaviour.","title":"act"},{"location":"aea/api/skills/behaviours/#is_done_4","text":"| is_done () -> bool Return True if the behaviour is terminated, False otherwise.","title":"is_done"},{"location":"aea/api/skills/behaviours/#register_transition","text":"| register_transition ( source : str , destination : str , event : Optional [ str ] = None ) Register a transition. No sanity check is done. Arguments : source : the source state name. destination : the destination state name. event : the event. Returns : None Raises : ValueError : if a transition from source with event is already present.","title":"register_transition"},{"location":"aea/api/skills/behaviours/#unregister_transition","text":"| unregister_transition ( source : str , destination : str , event : Optional [ str ] = None ) Unregister a transition. Arguments : source : the source state name. destination : the destination state name. event : the event. Returns : None Raises : ValueError : if a transition from source with event is not present.","title":"unregister_transition"},{"location":"aea/api/skills/tasks/","text":"aea.skills.tasks This module contains the classes for tasks. Task class Task () This class implements an abstract task. __ init __ | __init__ ( ** kwargs ) Initialize a task. __ call __ | __call__ ( * args , ** kwargs ) Execute the task. Arguments : args : positional arguments forwarded to the 'execute' method. kwargs : keyword arguments forwarded to the 'execute' method. :return the task instance Raises : ValueError : if the task has already been executed. is _ executed | @property | is_executed () -> bool Check if the task has already been executed. result | @property | result () -> Any Get the result. :return the result from the execute method. Raises : ValueError : if the task has not been executed yet. setup | @abstractmethod | setup () -> None Implement the behaviour setup. Returns : None execute | @abstractmethod | execute ( * args , ** kwargs ) -> None Run the task logic. Returns : None teardown | @abstractmethod | teardown () -> None Implement the behaviour teardown. Returns : None init _ worker init_worker () Initialize a worker. Disable the SIGINT handler. Related to a well-known bug: https://bugs.python.org/issue8296 TaskManager class TaskManager () A Task manager. __ init __ | __init__ ( nb_workers : int = 5 ) Initialize the task manager. Arguments : nb_workers : the number of worker processes. nb _ workers | @property | nb_workers () -> int Get the number of workers. enqueue _ task | enqueue_task ( func : Callable , args : Sequence = (), kwds : Optional [ Dict [ str , Any ]] = None ) -> int Enqueue a task with the executor. Arguments : func : the callable instance to be enqueued args : the positional arguments to be passed to the function. kwds : the keyword arguments to be passed to the function. :return the task id to get the the result. Raises : ValueError : if the task manager is not running. get _ task _ result | get_task_result ( task_id : int ) -> AsyncResult Get the result from a task. start | start () -> None Start the task manager. stop | stop () -> None Stop the task manager.","title":"Task"},{"location":"aea/api/skills/tasks/#aeaskillstasks","text":"This module contains the classes for tasks.","title":"aea.skills.tasks"},{"location":"aea/api/skills/tasks/#task","text":"class Task () This class implements an abstract task.","title":"Task"},{"location":"aea/api/skills/tasks/#__init__","text":"| __init__ ( ** kwargs ) Initialize a task.","title":"__init__"},{"location":"aea/api/skills/tasks/#__call__","text":"| __call__ ( * args , ** kwargs ) Execute the task. Arguments : args : positional arguments forwarded to the 'execute' method. kwargs : keyword arguments forwarded to the 'execute' method. :return the task instance Raises : ValueError : if the task has already been executed.","title":"__call__"},{"location":"aea/api/skills/tasks/#is_executed","text":"| @property | is_executed () -> bool Check if the task has already been executed.","title":"is_executed"},{"location":"aea/api/skills/tasks/#result","text":"| @property | result () -> Any Get the result. :return the result from the execute method. Raises : ValueError : if the task has not been executed yet.","title":"result"},{"location":"aea/api/skills/tasks/#setup","text":"| @abstractmethod | setup () -> None Implement the behaviour setup. Returns : None","title":"setup"},{"location":"aea/api/skills/tasks/#execute","text":"| @abstractmethod | execute ( * args , ** kwargs ) -> None Run the task logic. Returns : None","title":"execute"},{"location":"aea/api/skills/tasks/#teardown","text":"| @abstractmethod | teardown () -> None Implement the behaviour teardown. Returns : None","title":"teardown"},{"location":"aea/api/skills/tasks/#init_worker","text":"init_worker () Initialize a worker. Disable the SIGINT handler. Related to a well-known bug: https://bugs.python.org/issue8296","title":"init_worker"},{"location":"aea/api/skills/tasks/#taskmanager","text":"class TaskManager () A Task manager.","title":"TaskManager"},{"location":"aea/api/skills/tasks/#__init___1","text":"| __init__ ( nb_workers : int = 5 ) Initialize the task manager. Arguments : nb_workers : the number of worker processes.","title":"__init__"},{"location":"aea/api/skills/tasks/#nb_workers","text":"| @property | nb_workers () -> int Get the number of workers.","title":"nb_workers"},{"location":"aea/api/skills/tasks/#enqueue_task","text":"| enqueue_task ( func : Callable , args : Sequence = (), kwds : Optional [ Dict [ str , Any ]] = None ) -> int Enqueue a task with the executor. Arguments : func : the callable instance to be enqueued args : the positional arguments to be passed to the function. kwds : the keyword arguments to be passed to the function. :return the task id to get the the result. Raises : ValueError : if the task manager is not running.","title":"enqueue_task"},{"location":"aea/api/skills/tasks/#get_task_result","text":"| get_task_result ( task_id : int ) -> AsyncResult Get the result from a task.","title":"get_task_result"},{"location":"aea/api/skills/tasks/#start","text":"| start () -> None Start the task manager.","title":"start"},{"location":"aea/api/skills/tasks/#stop","text":"| stop () -> None Stop the task manager.","title":"stop"},{"location":"aea/api/skills/error/handlers/","text":"aea.skills.error.handlers This package contains the implementation of the handler for the 'default' protocol. ErrorHandler class ErrorHandler ( Handler ) This class implements the error handler. setup | setup () -> None Implement the setup. Returns : None handle | handle ( message : Message ) -> None Implement the reaction to an envelope. Arguments : message : the message teardown | teardown () -> None Implement the handler teardown. Returns : None send _ unsupported _ protocol | send_unsupported_protocol ( envelope : Envelope ) -> None Handle the received envelope in case the protocol is not supported. Arguments : envelope : the envelope Returns : None send _ decoding _ error | send_decoding_error ( envelope : Envelope ) -> None Handle a decoding error. Arguments : envelope : the envelope Returns : None send _ invalid _ message | send_invalid_message ( envelope : Envelope ) -> None Handle an message that is invalid wrt a protocol. Arguments : envelope : the envelope Returns : None send _ unsupported _ skill | send_unsupported_skill ( envelope : Envelope ) -> None Handle the received envelope in case the skill is not supported. Arguments : envelope : the envelope Returns : None","title":"Error Skill"},{"location":"aea/api/skills/error/handlers/#aeaskillserrorhandlers","text":"This package contains the implementation of the handler for the 'default' protocol.","title":"aea.skills.error.handlers"},{"location":"aea/api/skills/error/handlers/#errorhandler","text":"class ErrorHandler ( Handler ) This class implements the error handler.","title":"ErrorHandler"},{"location":"aea/api/skills/error/handlers/#setup","text":"| setup () -> None Implement the setup. Returns : None","title":"setup"},{"location":"aea/api/skills/error/handlers/#handle","text":"| handle ( message : Message ) -> None Implement the reaction to an envelope. Arguments : message : the message","title":"handle"},{"location":"aea/api/skills/error/handlers/#teardown","text":"| teardown () -> None Implement the handler teardown. Returns : None","title":"teardown"},{"location":"aea/api/skills/error/handlers/#send_unsupported_protocol","text":"| send_unsupported_protocol ( envelope : Envelope ) -> None Handle the received envelope in case the protocol is not supported. Arguments : envelope : the envelope Returns : None","title":"send_unsupported_protocol"},{"location":"aea/api/skills/error/handlers/#send_decoding_error","text":"| send_decoding_error ( envelope : Envelope ) -> None Handle a decoding error. Arguments : envelope : the envelope Returns : None","title":"send_decoding_error"},{"location":"aea/api/skills/error/handlers/#send_invalid_message","text":"| send_invalid_message ( envelope : Envelope ) -> None Handle an message that is invalid wrt a protocol. Arguments : envelope : the envelope Returns : None","title":"send_invalid_message"},{"location":"aea/api/skills/error/handlers/#send_unsupported_skill","text":"| send_unsupported_skill ( envelope : Envelope ) -> None Handle the received envelope in case the skill is not supported. Arguments : envelope : the envelope Returns : None","title":"send_unsupported_skill"},{"location":"ledger/","text":"Fetch.ai ledger The ledger serves as the foundations for the rest of the Fetch.ai platform. There are several reasons that lead us to develop a new ledger, some of which are listed below. Increased rate of transactions per second The origin of the limited throughput of Bitcoin and other conventional distributed ledger technologies is the sequential organization of blocks in a chain. All full processing nodes must keep a copy of the ledger, and blocks must be distributed across the peer-to-peer network in their entirety. Although the serial nature of blockchains limits their throughput, it is also crucial for security purposes. To succeed in inserting a conflicting event into the global consensus, the attacker must potentially re-write the entire history of the ledger, which becomes more difficult as time progresses. In order to increase throughput, while still preserving the consistency that prevents double-spending attacks, the Fetch.ai ledger relaxes the requirement on sequential execution by partitioning resources into mutually disjoint subsets called resource groups . Transactions that affect resources from different groups are then handled by separate resource lanes . Resource lanes are a novel componentof the Fetch.ai ledger architecture and you can read more about them here . Custom consensus algorithm The blockchain trilemma states that scalable blockchains cannot achieve both security and decentralisation, but our protocol aims to overcome said trilemma by forcing block producers to behave in a very restricted way and have limited flexibility. Critically, individual nodes have little control over which transactions go into the blockchain. These features give the ledger security and performance characteristics to match centralised systems. The protocol uses a Proof-of-Stake mechanism to construct a blockchain, a Decentralised Random Beacon to elect a group of nodes that collaboratively build and decide upon the next block that will be entered into the ledger, and a Directed Acyclic Graph for coordination and notarization. For better understanding of our consensus protocol, please read this blog post and the whitepaper . Support for on-chain ML and AI operations Coming soon.","title":"Introduction"},{"location":"ledger/#fetchai-ledger","text":"The ledger serves as the foundations for the rest of the Fetch.ai platform. There are several reasons that lead us to develop a new ledger, some of which are listed below.","title":"Fetch.ai ledger"},{"location":"ledger/#increased-rate-of-transactions-per-second","text":"The origin of the limited throughput of Bitcoin and other conventional distributed ledger technologies is the sequential organization of blocks in a chain. All full processing nodes must keep a copy of the ledger, and blocks must be distributed across the peer-to-peer network in their entirety. Although the serial nature of blockchains limits their throughput, it is also crucial for security purposes. To succeed in inserting a conflicting event into the global consensus, the attacker must potentially re-write the entire history of the ledger, which becomes more difficult as time progresses. In order to increase throughput, while still preserving the consistency that prevents double-spending attacks, the Fetch.ai ledger relaxes the requirement on sequential execution by partitioning resources into mutually disjoint subsets called resource groups . Transactions that affect resources from different groups are then handled by separate resource lanes . Resource lanes are a novel componentof the Fetch.ai ledger architecture and you can read more about them here .","title":"Increased rate of transactions per second"},{"location":"ledger/#custom-consensus-algorithm","text":"The blockchain trilemma states that scalable blockchains cannot achieve both security and decentralisation, but our protocol aims to overcome said trilemma by forcing block producers to behave in a very restricted way and have limited flexibility. Critically, individual nodes have little control over which transactions go into the blockchain. These features give the ledger security and performance characteristics to match centralised systems. The protocol uses a Proof-of-Stake mechanism to construct a blockchain, a Decentralised Random Beacon to elect a group of nodes that collaboratively build and decide upon the next block that will be entered into the ledger, and a Directed Acyclic Graph for coordination and notarization. For better understanding of our consensus protocol, please read this blog post and the whitepaper .","title":"Custom consensus algorithm"},{"location":"ledger/#support-for-on-chain-ml-and-ai-operations","text":"Coming soon.","title":"Support for on-chain ML and AI operations"},{"location":"ledger/architecture/","text":"Architecture This section describes at a high level how the Fetch.ai ledger operates; for full understanding of the ledger architecture please read the yellow paper . We assume the reader is comfortable with concepts that underpin blockchain technology such as public key cryptography, consensus and smart contracts. Note This is work in progress. The following diagram gives a high level overview of the components a node consists of. The entry point is the Constellation application; every time a node is deployed in the network, an instance of this application is created. Please read this section for more information about how to run a node. The block coordinator inside each node is responsible for adding new blocks to its copy of the chain, while preserving its consistency. In order to do so, it advances along the chain to find the longest/heaviest branch, and drops the ones that are not. After reaching the heaviest block, the block coordinator asks the executor(s) and consensus for help to add a new block, which contains a set of transactions. Consensus is responsible for building a block that will be considered correct, e.g. with a timestamp greater than that of the heaviest block in the chain. The executor takes said block, iterates through all the transactions packed within it, and for each of them: It determines if the transaction is valid, has paid the required fees, etc. Since conceptually a transaction is a state change in blockchain, it updates the state accordingly. Blocks are then exchanged between nodes via a block synchronization protocol . Consensus is also responsible for verifying that blocks received this way are correct. Sharding In order to prevent attacks such as double spending , transactions in a blockchain are executed in a strict, sequential order, thus ensuring that access to any given resource is strictly sequential. On a traditional decentralized ledger, this ordering of transactions must be identical across all the nodes that replicate the process. The Fetch.ai ledger relaxes the requirement on sequential execution by partitioning resources into mutually disjoint subsets called resource groups . Transactions that affect resources from different groups are then handled by separate resource lanes . The ledger defines a complete ordering of transactions belonging to a given lane, but not across lanes. A strict temporal ordering of transactions, including simultaneous execution of non-conflicting events, is achieved by entering transactions into a novel block structure. In order to understand better how resources lanes work, let's take a look at the following example: Dashed horizontal lines represent resource lanes. Vertical cyan bars denote transactions that involve resources (magenta circles) from one or more lanes. Groups of compatible transactions are arranged into block slices, demarcated by vertical lines, and can be executed simultaneously. For example, in the first block slice, the transaction involving resource groups 1 and 2 can be executed at the same time as the transaction that involves groups 3 and 5. This feature allows the ledger to scale its throughput to accommodate an arbitrary number of transactions. The bold vertical lines represent the putative boundaries of blocks that are to be entered into the blockchain. Each block contains a fixed number of slices, which we refer to as the slice number. The lane number, which specifies the other dimension of the block undergoes a doubling after the boundary of the second block, leading to a concomitant doubling of the transaction throughput. As a consequence of this design, the size of a block can vary by increasing or decreasing the number of shards. This allows the network to balance block sizes against economic incentives, for example. This blockchain sharding design speeds up the network as contracts can execute concurrently, providing a solution to the blockchain scalability problem. Furthermore, resource lanes serve a similar purpose as sharding in conventional databases, and reduce the minimum storage requirements on the smallest processing node on the network. The number of lanes can also be adjusted according to the transaction load. HTTP pages and API Note Coming soon Networking Note Coming soon","title":"Architecture"},{"location":"ledger/architecture/#architecture","text":"This section describes at a high level how the Fetch.ai ledger operates; for full understanding of the ledger architecture please read the yellow paper . We assume the reader is comfortable with concepts that underpin blockchain technology such as public key cryptography, consensus and smart contracts. Note This is work in progress. The following diagram gives a high level overview of the components a node consists of. The entry point is the Constellation application; every time a node is deployed in the network, an instance of this application is created. Please read this section for more information about how to run a node. The block coordinator inside each node is responsible for adding new blocks to its copy of the chain, while preserving its consistency. In order to do so, it advances along the chain to find the longest/heaviest branch, and drops the ones that are not. After reaching the heaviest block, the block coordinator asks the executor(s) and consensus for help to add a new block, which contains a set of transactions. Consensus is responsible for building a block that will be considered correct, e.g. with a timestamp greater than that of the heaviest block in the chain. The executor takes said block, iterates through all the transactions packed within it, and for each of them: It determines if the transaction is valid, has paid the required fees, etc. Since conceptually a transaction is a state change in blockchain, it updates the state accordingly. Blocks are then exchanged between nodes via a block synchronization protocol . Consensus is also responsible for verifying that blocks received this way are correct.","title":"Architecture"},{"location":"ledger/architecture/#sharding","text":"In order to prevent attacks such as double spending , transactions in a blockchain are executed in a strict, sequential order, thus ensuring that access to any given resource is strictly sequential. On a traditional decentralized ledger, this ordering of transactions must be identical across all the nodes that replicate the process. The Fetch.ai ledger relaxes the requirement on sequential execution by partitioning resources into mutually disjoint subsets called resource groups . Transactions that affect resources from different groups are then handled by separate resource lanes . The ledger defines a complete ordering of transactions belonging to a given lane, but not across lanes. A strict temporal ordering of transactions, including simultaneous execution of non-conflicting events, is achieved by entering transactions into a novel block structure. In order to understand better how resources lanes work, let's take a look at the following example: Dashed horizontal lines represent resource lanes. Vertical cyan bars denote transactions that involve resources (magenta circles) from one or more lanes. Groups of compatible transactions are arranged into block slices, demarcated by vertical lines, and can be executed simultaneously. For example, in the first block slice, the transaction involving resource groups 1 and 2 can be executed at the same time as the transaction that involves groups 3 and 5. This feature allows the ledger to scale its throughput to accommodate an arbitrary number of transactions. The bold vertical lines represent the putative boundaries of blocks that are to be entered into the blockchain. Each block contains a fixed number of slices, which we refer to as the slice number. The lane number, which specifies the other dimension of the block undergoes a doubling after the boundary of the second block, leading to a concomitant doubling of the transaction throughput. As a consequence of this design, the size of a block can vary by increasing or decreasing the number of shards. This allows the network to balance block sizes against economic incentives, for example. This blockchain sharding design speeds up the network as contracts can execute concurrently, providing a solution to the blockchain scalability problem. Furthermore, resource lanes serve a similar purpose as sharding in conventional databases, and reduce the minimum storage requirements on the smallest processing node on the network. The number of lanes can also be adjusted according to the transaction load.","title":"Sharding"},{"location":"ledger/architecture/#http-pages-and-api","text":"Note Coming soon","title":"HTTP pages and API"},{"location":"ledger/architecture/#networking","text":"Note Coming soon","title":"Networking"},{"location":"ledger/block-number/","text":"Run the following Python script and embedded smart contract to test the getBlockNumber() function. You need to run this against a running node on localhost port 8100 . Details for running a node are here . from fetchai . ledger . api import LedgerApi from fetchai . ledger . contract import SmartContract from fetchai . ledger . crypto import Entity , Address CONTRACT_TEXT = \"\"\" @ action function set_block_number_state () State < UInt64 > ( ' block_number_state ' ). set ( getBlockNumber ()); endfunction @ query function query_block_number_state () : UInt64 return State < UInt64 > ( ' block_number_state ' ). get ( 0u64 ); endfunction \"\"\" def main () : entity1 = Entity () # build the ledger API api = LedgerApi ( ' 127.0.0.1 ' , 8100 ) # create wealth so that we have the funds to be able to create contracts on the network api . sync ( api . tokens . wealth ( entity1 , 100000 )) # create the smart contract contract = SmartContract ( CONTRACT_TEXT ) # deploy the contract to the network api . sync ( api . contracts . create ( entity1 , contract , 2000 )) api . sync ( contract . action ( api , ' set_block_number_state ' , 400 , [ entity1 ])) print ( contract . query ( api , ' query_block_number_state ' )) if __name__ == ' __main__ ' : main ()","title":"Block number"},{"location":"ledger/maths-lib-overview/","text":"etch mathematics and machine learning operations are supported by a header-only fully-templated C++ library. Detailed developer documentation for the C++ implementation of the maths libraries will be available in the Fetch Ledger section in due course. Developers should be comfortable with SFINAE. Architecture A core component of the maths library is the tensor.hpp class which handles N-dimensional array mathematics. This is crucial for the machine learning library but can also be used for any generalised matrix algebra. The remainder of the library contains templated free functions that can be called with the following types: Built-in C++ types such as double , int , float , etc. C++ tensors of built-in types such as Tensor<double> . etch types such as Fixed32 . etch tensors types such as Tensor<Fixed32> . The header file fundamental_operators.hpp contains common operations Add , Subtract , Multiply , and Divide . The file matrix_operations.hpp contains Max , ArgMax , Product , Sum , Dot , etc. The standard_functions directory contains header files for additional standard operations. The following block diagram gives a rough indication of the library structure. Advice This is work in progress. Tensor A Tensor is a wrapper for a data_ object which is, by default, a SharedArray managed by the vectorise library. This library manages the vectorisation/SIMD on the underlying data. Tensor objects provide interfaces for manipulating arrays at a mathematical/algebraic level while allowing implementations to be efficient and vectorisable. Tensors have related helper classes such as TensorIterator , TensorBroadcast , and TensorSlice that permit efficient and convenient manipulation such as accessing, transposing, and slicing. Check out the available mathematical functions in etch here . Working with the maths library When working with the C++ maths library, take note of the following: Functions should have two interfaces: one that takes a reference to the return object, and one that creates the return object internally. Function design decisions should follow Numpy conventions where possible.","title":"Maths library"},{"location":"ledger/maths-lib-overview/#architecture","text":"A core component of the maths library is the tensor.hpp class which handles N-dimensional array mathematics. This is crucial for the machine learning library but can also be used for any generalised matrix algebra. The remainder of the library contains templated free functions that can be called with the following types: Built-in C++ types such as double , int , float , etc. C++ tensors of built-in types such as Tensor<double> . etch types such as Fixed32 . etch tensors types such as Tensor<Fixed32> . The header file fundamental_operators.hpp contains common operations Add , Subtract , Multiply , and Divide . The file matrix_operations.hpp contains Max , ArgMax , Product , Sum , Dot , etc. The standard_functions directory contains header files for additional standard operations. The following block diagram gives a rough indication of the library structure. Advice This is work in progress.","title":"Architecture"},{"location":"ledger/maths-lib-overview/#tensor","text":"A Tensor is a wrapper for a data_ object which is, by default, a SharedArray managed by the vectorise library. This library manages the vectorisation/SIMD on the underlying data. Tensor objects provide interfaces for manipulating arrays at a mathematical/algebraic level while allowing implementations to be efficient and vectorisable. Tensors have related helper classes such as TensorIterator , TensorBroadcast , and TensorSlice that permit efficient and convenient manipulation such as accessing, transposing, and slicing. Check out the available mathematical functions in etch here .","title":"Tensor"},{"location":"ledger/maths-lib-overview/#working-with-the-maths-library","text":"When working with the C++ maths library, take note of the following: Functions should have two interfaces: one that takes a reference to the return object, and one that creates the return object internally. Function design decisions should follow Numpy conventions where possible.","title":"Working with the maths library"},{"location":"ledger/running-a-constellation/","text":"Local node From the build folder, navigate to the constellation app folder: cd apps/constellation Create a genesis_file.json : Create a file saved as genesis_file.json and is saved in the constellation root dir, paste in the below code: { \"version\": 4, \"accounts\": [ { \"address\": \"Your base64 address\", \"balance\": 1152997575, \"stake\": 0 } ] } Start a standalone test node: ./constellation -block-interval 4000 -standalone -genesis-file-location genesis_file.json You should see output like this: \u25a0 \u25a0 \u25a0 . \u25a0 \u25a0 . . \u25a0 . . . . . . . Constellation v1.1.0-alpha19-8-g4cd13f999 Copyright 2018 -2019 ( c ) Fetch AI Ltd. [ I ] 2020 /01/10 10 :01:19 | main : Configuration: lanes................: 1 slices...............: 500 block-interval.......: 4000 standalone...........: Yes private-network......: No db-prefix............: node_storage port.................: 8000 peers................: external.............: 127 .0.0.1 config...............: max-peers............: 3 transient-peers......: 1 peers-update-cycle-ms: 0 disable-signing......: No kademlia-routing.....: Yes bootstrap............: No discoverable.........: No host-name............: network..............: token................: processor-threads....: 12 verifier-threads.....: 12 executors............: 1 genesis-file-location: genesis_file.json experimental.........: pos..................: No max-cabinet-size.....: 10 stake-delay-period...: 5 aeon-period..........: 25 graceful-failure.....: No fault-tolerant.......: No enable-agents........: No messenger-port.......: 9010 - Network Mode.........: Standalone Num Lanes............: 1 Num Slices...........: 500 Num Executors........: 1 DB Prefix............: 1 Processor Threads....: 12 Verification Threads.: 12 Max Peers............: 3 Transient Peers......: 1 Block Internal.......: 4000ms Max Cabinet Size.....: 10 Stake Delay Period...: 5 Aeon Period..........: 25 Kad Routing..........: 1 Proof of Stake.......: 0 Agents...............: 0 Messenger Port.......: 9010 Mailbox Port.........: 0 When you see the following message... [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] CORE URI: tcp://127.0.0.1:8101 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Num Initial Peers: 0 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Starting P2PService... [ 2019 -06-15 15 :24:39.484, # 5 INFO : HTTPServer ] Starting HTTPServer on http://127.0.0.1:8100 [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.525, # 7 INFO : BlockCoordinator ] Chain Sync complete on 0x780bbb1c050cd3d5c20fce89fa6f4e61c884315efeb44c54ceb956a50563683a (block: 0 prev: 0xd3efbefbefbefbefbefbefbefbe19e9deb22b3efbefbefbefbefbefbefbefbed) [ 2019 -06-15 15 :24:40.487, # 1 INFO : constellation ] Startup complete ...your node is running and you will be able to test smart contracts and autonomous agents. Connect to a node on testnet From the same build/apps/constellation folder, run the following. . / constellation - bootstrap - network testnet Compiler flags The following compiler flags run the constellation in various modes. -lanes : how many lanes to use. -slices : how many slices to use. -block-interval : block interval in milliseconds. -standalone : signal the network to run in standalone mode. -private-network : signal the network to run as part of a private network. -db-prefix : database prefix. -port : starting port for ledger services. -peers : comma separated list of addresses for initial connection. -external : global IP address or hostname for the node. -config : path to the manifest configuration. -max-peers : maximum number of peers to connect to. -transient-peers : random number of peers given in answer to peer requests. -peers-update-cycle-ms : speed of peer updates in milliseconds. -disable-signing : disable signing of all network messages. -bootstrap : signal to connect to the bootstrap server. -discoverable : signal that node can be advertised on the bootstrap server. -host-name : hostname or identifier for the node. -network : name of the bootstrap network to connect to. -token : the authentication token to talk to bootstrap. -processor-threads : number of processor threads. -verifier-threads : number of verifier threads. -executors : number of transaction executors. -experimental : comma separated list of experimental features to enable.","title":"Running a node"},{"location":"ledger/running-a-constellation/#local-node","text":"From the build folder, navigate to the constellation app folder: cd apps/constellation Create a genesis_file.json : Create a file saved as genesis_file.json and is saved in the constellation root dir, paste in the below code: { \"version\": 4, \"accounts\": [ { \"address\": \"Your base64 address\", \"balance\": 1152997575, \"stake\": 0 } ] } Start a standalone test node: ./constellation -block-interval 4000 -standalone -genesis-file-location genesis_file.json You should see output like this: \u25a0 \u25a0 \u25a0 . \u25a0 \u25a0 . . \u25a0 . . . . . . . Constellation v1.1.0-alpha19-8-g4cd13f999 Copyright 2018 -2019 ( c ) Fetch AI Ltd. [ I ] 2020 /01/10 10 :01:19 | main : Configuration: lanes................: 1 slices...............: 500 block-interval.......: 4000 standalone...........: Yes private-network......: No db-prefix............: node_storage port.................: 8000 peers................: external.............: 127 .0.0.1 config...............: max-peers............: 3 transient-peers......: 1 peers-update-cycle-ms: 0 disable-signing......: No kademlia-routing.....: Yes bootstrap............: No discoverable.........: No host-name............: network..............: token................: processor-threads....: 12 verifier-threads.....: 12 executors............: 1 genesis-file-location: genesis_file.json experimental.........: pos..................: No max-cabinet-size.....: 10 stake-delay-period...: 5 aeon-period..........: 25 graceful-failure.....: No fault-tolerant.......: No enable-agents........: No messenger-port.......: 9010 - Network Mode.........: Standalone Num Lanes............: 1 Num Slices...........: 500 Num Executors........: 1 DB Prefix............: 1 Processor Threads....: 12 Verification Threads.: 12 Max Peers............: 3 Transient Peers......: 1 Block Internal.......: 4000ms Max Cabinet Size.....: 10 Stake Delay Period...: 5 Aeon Period..........: 25 Kad Routing..........: 1 Proof of Stake.......: 0 Agents...............: 0 Messenger Port.......: 9010 Mailbox Port.........: 0 When you see the following message... [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] CORE URI: tcp://127.0.0.1:8101 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Num Initial Peers: 0 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Starting P2PService... [ 2019 -06-15 15 :24:39.484, # 5 INFO : HTTPServer ] Starting HTTPServer on http://127.0.0.1:8100 [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.525, # 7 INFO : BlockCoordinator ] Chain Sync complete on 0x780bbb1c050cd3d5c20fce89fa6f4e61c884315efeb44c54ceb956a50563683a (block: 0 prev: 0xd3efbefbefbefbefbefbefbefbe19e9deb22b3efbefbefbefbefbefbefbefbed) [ 2019 -06-15 15 :24:40.487, # 1 INFO : constellation ] Startup complete ...your node is running and you will be able to test smart contracts and autonomous agents.","title":"Local node"},{"location":"ledger/running-a-constellation/#connect-to-a-node-on-testnet","text":"From the same build/apps/constellation folder, run the following. . / constellation - bootstrap - network testnet","title":"Connect to a node on testnet"},{"location":"ledger/running-a-constellation/#compiler-flags","text":"The following compiler flags run the constellation in various modes. -lanes : how many lanes to use. -slices : how many slices to use. -block-interval : block interval in milliseconds. -standalone : signal the network to run in standalone mode. -private-network : signal the network to run as part of a private network. -db-prefix : database prefix. -port : starting port for ledger services. -peers : comma separated list of addresses for initial connection. -external : global IP address or hostname for the node. -config : path to the manifest configuration. -max-peers : maximum number of peers to connect to. -transient-peers : random number of peers given in answer to peer requests. -peers-update-cycle-ms : speed of peer updates in milliseconds. -disable-signing : disable signing of all network messages. -bootstrap : signal to connect to the bootstrap server. -discoverable : signal that node can be advertised on the bootstrap server. -host-name : hostname or identifier for the node. -network : name of the bootstrap network to connect to. -token : the authentication token to talk to bootstrap. -processor-threads : number of processor threads. -verifier-threads : number of verifier threads. -executors : number of transaction executors. -experimental : comma separated list of experimental features to enable.","title":"Compiler flags"},{"location":"ledger/etch-language/","text":"Welcome to the etch language docs Your browser does not support the video tag. For news, tutorials, and the latest, visit https://community.fetch.ai . What's etch ? etch is a high-level, statically-typed programming language designed for creating smart contracts on the Fetch.ai Ledger. Unlike similar languages, etch allows developers to code advanced compute-intensive logic for high performance scenarios such as machine learning and AI. The Fetch.ai Ledger (known as Constellation) runs compiled etch bytecode that is extremely robust to ensure maximum hardware-optimised performance. The etch language imposes rigorous compilation restrictions in order to avoid unwelcome and costly runtime errors. Design and test your smart contract code with the etch VM simulator before including it in a Python Ledger API script which takes care of deployment and other details. Find out how to run smart contract code with the Python Ledger API here . Note The `etch` language and the `etch` language guide are work in progress so some areas of the language remain incomplete for now. Please try out as much code as you like and send us your examples. Let us know if you have any problems.","title":"Introduction"},{"location":"ledger/etch-language/addresses/","text":"Address type format The Address data structure formats multiple cryptographic public key types. Currently, Address public key types start out as uncompressed ECDSA secp256k1_ 64 byte binary arrays. An Address is generated by hashing the raw bytes of the public key and appending a 4 byte checksum. The checksum comes from the hash of the first 4 bytes of the Address . The result is Base58 encoded. You can generate test addresses with the the ledger-api-py (Python SDK) . Create an Address function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); endfunction Type size in detail There are two Address formats: INTERNAL : This is a straightforward canonical representation of a sha256 public key and the length is always 32 bytes. This is the Address format used inside the Fetch.ai ledger C++ code. EXTERNAL : This is the public format used to interact with the Python Ledger HTTP API and also in smart contract etch code. The final size of the external Address result is between 50-51 bytes as the Base58 encoding process increases the size by a multiple of 1.42. In Python-type pseudocode below, we show you the steps for producing both types of Address . public_key = XYZ # simple internal representation canonical_address = sha256 ( public_key ) # external representation RAW_public_api_address = concatenate ( canonical_address , sha256 ( canonical_address )[ 0 : 4 bytes ]) # check length assert ( 36 bytes == len ( RAW_public_api_address )) # Base58 encoding public_api_address = Base58 ( RAW_public_api_address ) SHA256 etch currently supports the SHA256 encryption algorithm. Find out more here . Verification The Address type has a function signedTx() which allows you to verify the signature. It returns a boolean. This is only valid in an @action function, else it will return false. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var verified : Bool ; verified = account . signedTx (); printLn ( toString ( verified )); endfunction The above code always prints false when it is not contained within an @action function. The Address type will eventually support all asymmetric cryptographic types and, more importantly, will be quantum computing ready. Print Address Use toString() to print Address types. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); printLn ( toString ( account )); endfunction","title":"Address"},{"location":"ledger/etch-language/addresses/#address-type-format","text":"The Address data structure formats multiple cryptographic public key types. Currently, Address public key types start out as uncompressed ECDSA secp256k1_ 64 byte binary arrays. An Address is generated by hashing the raw bytes of the public key and appending a 4 byte checksum. The checksum comes from the hash of the first 4 bytes of the Address . The result is Base58 encoded. You can generate test addresses with the the ledger-api-py (Python SDK) .","title":"Address type format"},{"location":"ledger/etch-language/addresses/#create-an-address","text":"function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); endfunction","title":"Create an Address"},{"location":"ledger/etch-language/addresses/#type-size-in-detail","text":"There are two Address formats: INTERNAL : This is a straightforward canonical representation of a sha256 public key and the length is always 32 bytes. This is the Address format used inside the Fetch.ai ledger C++ code. EXTERNAL : This is the public format used to interact with the Python Ledger HTTP API and also in smart contract etch code. The final size of the external Address result is between 50-51 bytes as the Base58 encoding process increases the size by a multiple of 1.42. In Python-type pseudocode below, we show you the steps for producing both types of Address . public_key = XYZ # simple internal representation canonical_address = sha256 ( public_key ) # external representation RAW_public_api_address = concatenate ( canonical_address , sha256 ( canonical_address )[ 0 : 4 bytes ]) # check length assert ( 36 bytes == len ( RAW_public_api_address )) # Base58 encoding public_api_address = Base58 ( RAW_public_api_address )","title":"Type size in detail"},{"location":"ledger/etch-language/addresses/#sha256","text":"etch currently supports the SHA256 encryption algorithm. Find out more here .","title":"SHA256"},{"location":"ledger/etch-language/addresses/#verification","text":"The Address type has a function signedTx() which allows you to verify the signature. It returns a boolean. This is only valid in an @action function, else it will return false. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var verified : Bool ; verified = account . signedTx (); printLn ( toString ( verified )); endfunction The above code always prints false when it is not contained within an @action function. The Address type will eventually support all asymmetric cryptographic types and, more importantly, will be quantum computing ready.","title":"Verification"},{"location":"ledger/etch-language/addresses/#print-address","text":"Use toString() to print Address types. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); printLn ( toString ( account )); endfunction","title":"Print Address"},{"location":"ledger/etch-language/arrays/","text":"Arrays One dimensional arrays Declare, access by index, and iterate over an array like this: function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; // print the array printLn ( myArray ); // print a single element of the array printLn ( toString ( myArray [ 3 ])); // print elements ascending for ( i in 0 : myArray . count ()) printLn ( toString ( myArray [ i ])); endfor endfunction Two dimensional arrays Declare a 4x4 two dimensional array like this: function main () // build a 4x4 grid var grid = Array < Array < Int32 > > ( 4 ); for ( row in 0 : grid . count ()) grid [ row ] = Array < Int32 > ( 4 ); endfor // initialise row and column values var count = 1 ; for ( row in 0 : grid . count ()) for ( column in 0 : grid [ row ]. count ()) grid [ row ][ column ] = count ; count += 1 ; endfor printLn ( grid [ row ]); endfor endfunction Nested arrays etch supports multidimensional arrays. function main () var ref_array = Array < Array < Array < String >>> ( 2 ); ref_array [ 0 ] = Array < Array < String >> ( 2 ); ref_array [ 1 ] = Array < Array < String >> ( 2 ); ref_array [ 0 ][ 0 ] = Array < String > ( 1 ); ref_array [ 0 ][ 1 ] = Array < String > ( 1 ); ref_array [ 1 ][ 0 ] = Array < String > ( 2 ); ref_array [ 1 ][ 1 ] = Array < String > ( 2 ); endfunction Array functions Count The count() function returns the number of items in a one dimensional array, or the number of arrays in a two dimensional array. Returns 0 if the array is empty. function main () var myArray = Array < Int32 > ( 2 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; printLn ( myArray . count ()); myArray . append ( 42 ); printLn ( myArray . count ()); endfunction function main () printLn ( Array < Array < UInt32 >> ( 10 ). count ()); endfunction Append The append() function adds a new type safe item to the end of a one dimensional array. function main () var myArray = Array < UInt32 > ( 2 ); myArray [ 0 ] = 1u32 ; myArray [ 1 ] = 2u32 ; myArray . append ( 42u32 ); // type safety check // myArray.append(\"hello\"); // error: unable to find matching function for 'append' printLn ( myArray ); endfunction Or an array to the end of a two dimensional array. function main () var my2dArray = Array < Array < Int32 >> ( 3 ); var count = 1 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 3 ); for ( j in 0 : my2dArray . count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor printLn ( \" \" ); my2dArray . append ( Array < Int32 > ( 8 )); my2dArray [ 1 ]. append ( 42 ); for ( k in 0 : my2dArray . count ()) printLn ( my2dArray [ k ]); endfor endfunction Extend Use extend() to append the contents of one array to another in order of insertion. Array types must be the same. function main () var data1 = Array < Int32 > ( 3 ); data1 [ 0 ] = 1 ; data1 [ 1 ] = 2 ; data1 [ 2 ] = 3 ; printLn ( data1 ); var data2 = Array < Int32 > ( 2 ); data2 [ 0 ] = 5 ; data2 [ 1 ] = 4 ; data1 . extend ( data2 ); printLn ( data1 ); endfunction Pop back and pop front The popBack() function removes and returns the last item from a one dimensional array, or the last array from a two dimensional array. The popFront() function removes and returns the first item or array, or the first array from a two dimensional array. Fails if the array is empty. function main () var myArray = Array < Int32 > ( 3 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; printLn ( myArray ); var backItem = myArray . popBack (); var frontItem = myArray . popFront (); printLn (( toString ( backItem )) + \" removed from the end of myArray\" ); printLn (( toString ( frontItem )) + \" removed from the start of myArray\" ); printLn ( myArray ); endfunction function main () //create a 3 by 3 array var my2dArray = Array < Array < Int32 >> ( 3 ); var count = 1 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 3 ); for ( j in 0 : my2dArray [ i ]. count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor printLn ( \"Remove back and front arrays\" ); var backArray = my2dArray . popBack (); printLn ( backArray ); var frontArray = my2dArray . popFront (); printLn ( frontArray ); printLn ( \"Left with\" ); for ( row in 0 : my2dArray . count ()) printLn ( my2dArray [ row ]); endfor endfunction Pop back and front with n Use popBack(n) to remove the last n items from a one dimensional array, or the last n arrays from a two dimensional array, and return them as an array(s). Use popFront(n) to remove and return the first n items or arrays. n must be a non-negative integer. Returns an array. Fails if n is negative or n is greater than the number of items or arrays. Returns an empty array if n equals 0, leaving the original array unchanged. function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; myArray [ 3 ] = 40 ; myArray [ 4 ] = 50 ; printLn ( myArray ); var backItems = myArray . popBack ( 2 ); var frontItems = myArray . popFront ( 1 ); printLn ( \"n=2 items removed from end: \" ); printLn ( backItems ); printLn ( \"n=1 items removed from start: \" ); printLn ( frontItems ); printLn ( \"Remaining array: \" ); printLn ( myArray ); endfunction function main () var my2dArray = Array < Array < Int32 >> ( 5 ); var count = 11 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 5 ); for ( j in 0 : my2dArray [ i ]. count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor var backArray = my2dArray . popBack ( 2 ); printLn ( \"n=2 removed back arrays: \" ); for ( k in 0 : 2 ) printLn ( backArray [ k ]); endfor var frontArray = my2dArray . popFront ( 2 ); printLn ( \"n=2 removed front arrays: \" ); for ( l in 0 : 2 ) printLn ( frontArray [ l ]); endfor printLn ( \"Remaining array(s) : \") ; for ( m in 0 : 1 ) printLn ( my2dArray [ m ]); endfor endfunction Reverse The reverse() function reverses the order of items in a one dimensional array, or the order of arrays in a two dimensional array. function main () var myArray = Array < Int32 > ( 3 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; printLn ( myArray ); myArray . reverse (); printLn ( myArray ); endfunction function main () var my2dArray = Array < Array < Int32 >> ( 5 ); var count = 101 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 5 ); for ( j in 0 : my2dArray [ i ]. count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor my2dArray . reverse (); printLn ( \"Reversed: \" ); for ( k in 0 : my2dArray . count ()) printLn ( my2dArray [ k ]); endfor endfunction Erase Remove an element from an array with the erase() function. function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( myArray ); myArray . erase ( 2 ); printLn ( myArray ); endfunction","title":"Arrays"},{"location":"ledger/etch-language/arrays/#arrays","text":"","title":"Arrays"},{"location":"ledger/etch-language/arrays/#one-dimensional-arrays","text":"Declare, access by index, and iterate over an array like this: function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; // print the array printLn ( myArray ); // print a single element of the array printLn ( toString ( myArray [ 3 ])); // print elements ascending for ( i in 0 : myArray . count ()) printLn ( toString ( myArray [ i ])); endfor endfunction","title":"One dimensional arrays"},{"location":"ledger/etch-language/arrays/#two-dimensional-arrays","text":"Declare a 4x4 two dimensional array like this: function main () // build a 4x4 grid var grid = Array < Array < Int32 > > ( 4 ); for ( row in 0 : grid . count ()) grid [ row ] = Array < Int32 > ( 4 ); endfor // initialise row and column values var count = 1 ; for ( row in 0 : grid . count ()) for ( column in 0 : grid [ row ]. count ()) grid [ row ][ column ] = count ; count += 1 ; endfor printLn ( grid [ row ]); endfor endfunction","title":"Two dimensional arrays"},{"location":"ledger/etch-language/arrays/#nested-arrays","text":"etch supports multidimensional arrays. function main () var ref_array = Array < Array < Array < String >>> ( 2 ); ref_array [ 0 ] = Array < Array < String >> ( 2 ); ref_array [ 1 ] = Array < Array < String >> ( 2 ); ref_array [ 0 ][ 0 ] = Array < String > ( 1 ); ref_array [ 0 ][ 1 ] = Array < String > ( 1 ); ref_array [ 1 ][ 0 ] = Array < String > ( 2 ); ref_array [ 1 ][ 1 ] = Array < String > ( 2 ); endfunction","title":"Nested arrays"},{"location":"ledger/etch-language/arrays/#array-functions","text":"","title":"Array functions"},{"location":"ledger/etch-language/arrays/#count","text":"The count() function returns the number of items in a one dimensional array, or the number of arrays in a two dimensional array. Returns 0 if the array is empty. function main () var myArray = Array < Int32 > ( 2 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; printLn ( myArray . count ()); myArray . append ( 42 ); printLn ( myArray . count ()); endfunction function main () printLn ( Array < Array < UInt32 >> ( 10 ). count ()); endfunction","title":"Count"},{"location":"ledger/etch-language/arrays/#append","text":"The append() function adds a new type safe item to the end of a one dimensional array. function main () var myArray = Array < UInt32 > ( 2 ); myArray [ 0 ] = 1u32 ; myArray [ 1 ] = 2u32 ; myArray . append ( 42u32 ); // type safety check // myArray.append(\"hello\"); // error: unable to find matching function for 'append' printLn ( myArray ); endfunction Or an array to the end of a two dimensional array. function main () var my2dArray = Array < Array < Int32 >> ( 3 ); var count = 1 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 3 ); for ( j in 0 : my2dArray . count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor printLn ( \" \" ); my2dArray . append ( Array < Int32 > ( 8 )); my2dArray [ 1 ]. append ( 42 ); for ( k in 0 : my2dArray . count ()) printLn ( my2dArray [ k ]); endfor endfunction","title":"Append"},{"location":"ledger/etch-language/arrays/#extend","text":"Use extend() to append the contents of one array to another in order of insertion. Array types must be the same. function main () var data1 = Array < Int32 > ( 3 ); data1 [ 0 ] = 1 ; data1 [ 1 ] = 2 ; data1 [ 2 ] = 3 ; printLn ( data1 ); var data2 = Array < Int32 > ( 2 ); data2 [ 0 ] = 5 ; data2 [ 1 ] = 4 ; data1 . extend ( data2 ); printLn ( data1 ); endfunction","title":"Extend"},{"location":"ledger/etch-language/arrays/#pop-back-and-pop-front","text":"The popBack() function removes and returns the last item from a one dimensional array, or the last array from a two dimensional array. The popFront() function removes and returns the first item or array, or the first array from a two dimensional array. Fails if the array is empty. function main () var myArray = Array < Int32 > ( 3 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; printLn ( myArray ); var backItem = myArray . popBack (); var frontItem = myArray . popFront (); printLn (( toString ( backItem )) + \" removed from the end of myArray\" ); printLn (( toString ( frontItem )) + \" removed from the start of myArray\" ); printLn ( myArray ); endfunction function main () //create a 3 by 3 array var my2dArray = Array < Array < Int32 >> ( 3 ); var count = 1 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 3 ); for ( j in 0 : my2dArray [ i ]. count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor printLn ( \"Remove back and front arrays\" ); var backArray = my2dArray . popBack (); printLn ( backArray ); var frontArray = my2dArray . popFront (); printLn ( frontArray ); printLn ( \"Left with\" ); for ( row in 0 : my2dArray . count ()) printLn ( my2dArray [ row ]); endfor endfunction","title":"Pop back and pop front"},{"location":"ledger/etch-language/arrays/#pop-back-and-front-with-n","text":"Use popBack(n) to remove the last n items from a one dimensional array, or the last n arrays from a two dimensional array, and return them as an array(s). Use popFront(n) to remove and return the first n items or arrays. n must be a non-negative integer. Returns an array. Fails if n is negative or n is greater than the number of items or arrays. Returns an empty array if n equals 0, leaving the original array unchanged. function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; myArray [ 3 ] = 40 ; myArray [ 4 ] = 50 ; printLn ( myArray ); var backItems = myArray . popBack ( 2 ); var frontItems = myArray . popFront ( 1 ); printLn ( \"n=2 items removed from end: \" ); printLn ( backItems ); printLn ( \"n=1 items removed from start: \" ); printLn ( frontItems ); printLn ( \"Remaining array: \" ); printLn ( myArray ); endfunction function main () var my2dArray = Array < Array < Int32 >> ( 5 ); var count = 11 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 5 ); for ( j in 0 : my2dArray [ i ]. count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor var backArray = my2dArray . popBack ( 2 ); printLn ( \"n=2 removed back arrays: \" ); for ( k in 0 : 2 ) printLn ( backArray [ k ]); endfor var frontArray = my2dArray . popFront ( 2 ); printLn ( \"n=2 removed front arrays: \" ); for ( l in 0 : 2 ) printLn ( frontArray [ l ]); endfor printLn ( \"Remaining array(s) : \") ; for ( m in 0 : 1 ) printLn ( my2dArray [ m ]); endfor endfunction","title":"Pop back and front with n"},{"location":"ledger/etch-language/arrays/#reverse","text":"The reverse() function reverses the order of items in a one dimensional array, or the order of arrays in a two dimensional array. function main () var myArray = Array < Int32 > ( 3 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; printLn ( myArray ); myArray . reverse (); printLn ( myArray ); endfunction function main () var my2dArray = Array < Array < Int32 >> ( 5 ); var count = 101 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 5 ); for ( j in 0 : my2dArray [ i ]. count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor my2dArray . reverse (); printLn ( \"Reversed: \" ); for ( k in 0 : my2dArray . count ()) printLn ( my2dArray [ k ]); endfor endfunction","title":"Reverse"},{"location":"ledger/etch-language/arrays/#erase","text":"Remove an element from an array with the erase() function. function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( myArray ); myArray . erase ( 2 ); printLn ( myArray ); endfunction","title":"Erase"},{"location":"ledger/etch-language/balance-transfer/","text":"Like Context , Block , and Transaction , the balance and transfer functions must run against a Fetch.ai Ledger node. balance() The balance function returns the balance of funds owned by the contract address as a UInt64 type. @ action function check_balance () var bal : UInt64 = 0u64 ; bal = balance (); printLn ( bal ); endfunction You can call balance() from a smart contract currently invoking against a node in the following annotated smart contract functions: @init @action @query You can call balance() from a synergetic contract currently invoking against a node in the following annotated synergetic contract functions: @clear transfer(target : Address, amount : UInt64) The transfer function allows the smart contract to transfer an amount of FET to a receiving entity. It takes two parameters: An Address type representing the receiving entity. A UInt64 value representing the amount of FET the entity will receive. @ action function transfer_funds ( target : Address , amount : UInt64 ) transfer ( target , amount ); endfunction You can call transfer() from a smart contract currently invoking against a node in the following annotated functions: @init @action You can call transfer() from a synergetic contract currently invoking against a node in the following annotated functions: @clear Example Let's execute an example against a local ledger node. Instructions for starting up a ledger node are here . etch smart contract code The etch code here and Python wrapper code below it comes from a Python Ledger API wrapped example that you can run against a Fetch.ai ledger node. The first contract code is here. persistent balance_state : UInt64 ; @ action function set_balance_state () use balance_state ; balance_state . set ( balance ()); endfunction @ query function query_balance_state () : UInt64 use balance_state ; return balance_state . get ( 567u64 ); endfunction @ action function transfer_funds ( target : Address , amount : UInt64 ) transfer ( target , amount ); endfunction And the second smart contract code is here. @ action function transfer_funds1 ( target : Address , amount : UInt64 ) transfer ( target , amount ); endfunction Tip Full and complete documentation for the Python Ledger API is currently in development. Please check here for updates. This beautiful example show how smart contracts may interact with each other. Python Ledger API wrapper code from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address CONTRACT_TEXT = \"\"\"first contract as above\"\"\" TRANSFER_CONTRACT_TEXT = \"\"\"second contract as above\"\"\" def balance_within_range ( actual , expected , fees = 150 ): return actual >= expected - fees def setup ( api ): entity1 = Entity () api . sync ( api . tokens . wealth ( entity1 , 100000 )) contract1 = Contract ( TRANSFER_CONTRACT_TEXT , entity1 ) contract2 = Contract ( CONTRACT_TEXT , entity1 ) initial_owner_balance = api . tokens . balance ( Address ( entity1 )) assert initial_owner_balance == 100000 , \\ 'Expected initial directly-queried balance to be 0, found {} ' . format ( 100000 , initial_owner_balance ) api . sync ( api . contracts . create ( entity1 , contract1 , 2000 )) api . sync ( api . contracts . create ( entity1 , contract2 , 2000 )) return entity1 , contract1 , contract2 def transfer_and_verify_balances ( api , entity , address_to , amount ): from_balance_before = api . tokens . balance ( Address ( entity )) to_balance_before = api . tokens . balance ( address_to ) assert from_balance_before > amount , \\ 'Insufficient funds' print ( 'Transfer from {} to {} ' . format ( Address ( entity ), address_to )) api . sync ( api . tokens . transfer ( entity , address_to , amount , 100 )) from_balance_after = api . tokens . balance ( Address ( entity )) assert balance_within_range ( from_balance_after , from_balance_before - amount ), \\ 'Expected balance to decrease by {} - found {} (before); {} (after)' . format ( amount , from_balance_before , from_balance_after ) to_balance_after = api . tokens . balance ( address_to ) assert balance_within_range ( to_balance_after , to_balance_before + amount ), \\ 'Expected balance to increase by {} - found {} (before); {} (after)' . format ( amount , to_balance_before , to_balance_after ) def call_transfer_action_and_verify_balances ( api , source_contract , action , signers , target_address , amount ): from_balance_before = api . tokens . balance ( source_contract . address ) to_balance_before = api . tokens . balance ( target_address ) assert from_balance_before > amount , \\ 'Insufficient funds' print ( 'Transfer from {} to {} ' . format ( source_contract . address , target_address )) api . sync ( source_contract . action ( api , action , 100 , signers , target_address , amount )) from_balance_after = api . tokens . balance ( source_contract . address ) assert balance_within_range ( from_balance_after , from_balance_before - amount ), \\ 'Expected balance to decrease by {} - found {} (before); {} (after)' . format ( amount , from_balance_before , from_balance_after ) to_balance_after = api . tokens . balance ( target_address ) assert balance_within_range ( to_balance_after , to_balance_before + amount ), \\ 'Expected balance to increase by {} - found {} (before); {} (after)' . format ( amount , to_balance_before , to_balance_after ) def run ( options ): api = LedgerApi ( options [ 'host' ], options [ 'port' ]) # Create an entity and have it deploy both contracts entity1 , contract1 , contract2 = setup ( api ) # Have entity1 send contract1 some money transfer_and_verify_balances ( api , entity1 , contract1 . address , 2345 ) # Have contract1 send contract2 some of its money call_transfer_action_and_verify_balances ( api , contract1 , 'transfer_funds1' , [ entity1 ], contract2 . address , 1345 ) # Have contract2 send some money back to its owner call_transfer_action_and_verify_balances ( api , contract2 , 'transfer_funds' , [ entity1 ], Address ( entity1 ), 1000 ) if __name__ == \"__main__\" : run ({ 'host' : '127.0.0.1' , 'port' : 8100 }) You should see similar to the following results. WARNING:root:Defaulting to wildcard shard mask as none supplied WARNING:root:Defaulting to wildcard shard mask as none supplied Transfer from 2VkKoC7DvBz6wXKZyoypkg2xsRBkE3FdNGXHqShqcEevYray4J to 24sx12GNYMRSFHLyUkiPLmfjeydeV5225RYZfpu2Qvk2LMpWWu Transfer from 24sx12GNYMRSFHLyUkiPLmfjeydeV5225RYZfpu2Qvk2LMpWWu to 2mfWzyUTgoju5nWYMENf7M1yLE3b2Ma31kmAhKPvAW7ytBydev Transfer from 2mfWzyUTgoju5nWYMENf7M1yLE3b2Ma31kmAhKPvAW7ytBydev to 2VkKoC7DvBz6wXKZyoypkg2xsRBkE3FdNGXHqShqcEevYray4J Process finished with exit code 0","title":"Balance and Transfer"},{"location":"ledger/etch-language/balance-transfer/#balance","text":"The balance function returns the balance of funds owned by the contract address as a UInt64 type. @ action function check_balance () var bal : UInt64 = 0u64 ; bal = balance (); printLn ( bal ); endfunction You can call balance() from a smart contract currently invoking against a node in the following annotated smart contract functions: @init @action @query You can call balance() from a synergetic contract currently invoking against a node in the following annotated synergetic contract functions: @clear","title":"balance()"},{"location":"ledger/etch-language/balance-transfer/#transfertarget-address-amount-uint64","text":"The transfer function allows the smart contract to transfer an amount of FET to a receiving entity. It takes two parameters: An Address type representing the receiving entity. A UInt64 value representing the amount of FET the entity will receive. @ action function transfer_funds ( target : Address , amount : UInt64 ) transfer ( target , amount ); endfunction You can call transfer() from a smart contract currently invoking against a node in the following annotated functions: @init @action You can call transfer() from a synergetic contract currently invoking against a node in the following annotated functions: @clear","title":"transfer(target : Address, amount : UInt64)"},{"location":"ledger/etch-language/balance-transfer/#example","text":"Let's execute an example against a local ledger node. Instructions for starting up a ledger node are here .","title":"Example"},{"location":"ledger/etch-language/balance-transfer/#etch-smart-contract-code","text":"The etch code here and Python wrapper code below it comes from a Python Ledger API wrapped example that you can run against a Fetch.ai ledger node. The first contract code is here. persistent balance_state : UInt64 ; @ action function set_balance_state () use balance_state ; balance_state . set ( balance ()); endfunction @ query function query_balance_state () : UInt64 use balance_state ; return balance_state . get ( 567u64 ); endfunction @ action function transfer_funds ( target : Address , amount : UInt64 ) transfer ( target , amount ); endfunction And the second smart contract code is here. @ action function transfer_funds1 ( target : Address , amount : UInt64 ) transfer ( target , amount ); endfunction Tip Full and complete documentation for the Python Ledger API is currently in development. Please check here for updates. This beautiful example show how smart contracts may interact with each other.","title":"etch smart contract code"},{"location":"ledger/etch-language/balance-transfer/#python-ledger-api-wrapper-code","text":"from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address CONTRACT_TEXT = \"\"\"first contract as above\"\"\" TRANSFER_CONTRACT_TEXT = \"\"\"second contract as above\"\"\" def balance_within_range ( actual , expected , fees = 150 ): return actual >= expected - fees def setup ( api ): entity1 = Entity () api . sync ( api . tokens . wealth ( entity1 , 100000 )) contract1 = Contract ( TRANSFER_CONTRACT_TEXT , entity1 ) contract2 = Contract ( CONTRACT_TEXT , entity1 ) initial_owner_balance = api . tokens . balance ( Address ( entity1 )) assert initial_owner_balance == 100000 , \\ 'Expected initial directly-queried balance to be 0, found {} ' . format ( 100000 , initial_owner_balance ) api . sync ( api . contracts . create ( entity1 , contract1 , 2000 )) api . sync ( api . contracts . create ( entity1 , contract2 , 2000 )) return entity1 , contract1 , contract2 def transfer_and_verify_balances ( api , entity , address_to , amount ): from_balance_before = api . tokens . balance ( Address ( entity )) to_balance_before = api . tokens . balance ( address_to ) assert from_balance_before > amount , \\ 'Insufficient funds' print ( 'Transfer from {} to {} ' . format ( Address ( entity ), address_to )) api . sync ( api . tokens . transfer ( entity , address_to , amount , 100 )) from_balance_after = api . tokens . balance ( Address ( entity )) assert balance_within_range ( from_balance_after , from_balance_before - amount ), \\ 'Expected balance to decrease by {} - found {} (before); {} (after)' . format ( amount , from_balance_before , from_balance_after ) to_balance_after = api . tokens . balance ( address_to ) assert balance_within_range ( to_balance_after , to_balance_before + amount ), \\ 'Expected balance to increase by {} - found {} (before); {} (after)' . format ( amount , to_balance_before , to_balance_after ) def call_transfer_action_and_verify_balances ( api , source_contract , action , signers , target_address , amount ): from_balance_before = api . tokens . balance ( source_contract . address ) to_balance_before = api . tokens . balance ( target_address ) assert from_balance_before > amount , \\ 'Insufficient funds' print ( 'Transfer from {} to {} ' . format ( source_contract . address , target_address )) api . sync ( source_contract . action ( api , action , 100 , signers , target_address , amount )) from_balance_after = api . tokens . balance ( source_contract . address ) assert balance_within_range ( from_balance_after , from_balance_before - amount ), \\ 'Expected balance to decrease by {} - found {} (before); {} (after)' . format ( amount , from_balance_before , from_balance_after ) to_balance_after = api . tokens . balance ( target_address ) assert balance_within_range ( to_balance_after , to_balance_before + amount ), \\ 'Expected balance to increase by {} - found {} (before); {} (after)' . format ( amount , to_balance_before , to_balance_after ) def run ( options ): api = LedgerApi ( options [ 'host' ], options [ 'port' ]) # Create an entity and have it deploy both contracts entity1 , contract1 , contract2 = setup ( api ) # Have entity1 send contract1 some money transfer_and_verify_balances ( api , entity1 , contract1 . address , 2345 ) # Have contract1 send contract2 some of its money call_transfer_action_and_verify_balances ( api , contract1 , 'transfer_funds1' , [ entity1 ], contract2 . address , 1345 ) # Have contract2 send some money back to its owner call_transfer_action_and_verify_balances ( api , contract2 , 'transfer_funds' , [ entity1 ], Address ( entity1 ), 1000 ) if __name__ == \"__main__\" : run ({ 'host' : '127.0.0.1' , 'port' : 8100 }) You should see similar to the following results. WARNING:root:Defaulting to wildcard shard mask as none supplied WARNING:root:Defaulting to wildcard shard mask as none supplied Transfer from 2VkKoC7DvBz6wXKZyoypkg2xsRBkE3FdNGXHqShqcEevYray4J to 24sx12GNYMRSFHLyUkiPLmfjeydeV5225RYZfpu2Qvk2LMpWWu Transfer from 24sx12GNYMRSFHLyUkiPLmfjeydeV5225RYZfpu2Qvk2LMpWWu to 2mfWzyUTgoju5nWYMENf7M1yLE3b2Ma31kmAhKPvAW7ytBydev Transfer from 2mfWzyUTgoju5nWYMENf7M1yLE3b2Ma31kmAhKPvAW7ytBydev to 2VkKoC7DvBz6wXKZyoypkg2xsRBkE3FdNGXHqShqcEevYray4J Process finished with exit code 0","title":"Python Ledger API wrapper code"},{"location":"ledger/etch-language/context/","text":"Context is an etch language type that provides access to currently invoking ledger transaction data - such as block and transaction information - coming from smart contracts running against ledger nodes. Specific annotated functions Smart contract transaction data is available in functions annotated with @init and @action . This means that, putting Context code in @query functions or other functions not equipped to access a Context , should raise an error. Note It is not possible to provide standalone `etch` code snippet examples as `Context` requires a running ledger node. Coding with Context Note The only way to get a `Context` is by calling `getContext()`. The Context object has two member functions. block() : returns access to the current Block object - see below. transaction() : returns access to the current Transaction . Check the Transaction documentation for details. We will execute the example below against a local ledger node. Instructions for running a ledger node are here . etch smart contract code is wrapped inside Python Ledger API scripts which take care of the implementation against a running ledger (think truffle/ganache plus web3). Tip Full and complete documentation for the Python Ledger API is currently in development. Please check here for updates. getContext() , block() , and blockNumber() To get a Context , call getContext() . From here, you have access to the Block object which has a blockNumber() function that returns the current block number. The following syntax grabs the Context , gets the Block object from the Context , then runs the blockNumber() function of Block which returns the current block number. var context = getContext (); var block = context . block (); var block_number = block . blockNumber (); Example The following etch smart contract tests the Context and Block types and the blockNumber() function. persistent init_block_number_state : UInt64 ; @ init function set_block_number ( owner : Address ) : Int64 use init_block_number_state ; var context = getContext (); var block = context . block (); var block_number = block . blockNumber (); init_block_number_state . set ( block_number ); return toInt64 ( block_number ); endfunction @ query function get_init_block_number_state () : UInt64 use init_block_number_state ; return init_block_number_state . get ( 0u64 ); endfunction Now run the above embedded in this script that calls the Python Ledger API. from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity CONTRACT_TEXT = \"[as above]\" def run ( options ): entity1 = Entity () # build the ledger API api = LedgerApi ( options [ 'host' ], options [ 'port' ]) # create wealth so that we have the funds to be able to create contracts on the network api . sync ( api . tokens . wealth ( entity1 , 100000 )) contract = Contract ( CONTRACT_TEXT , entity1 ) # deploy the contract to the network status = api . sync ( api . contracts . create ( entity1 , contract , 20000 ))[ 0 ] block_number = contract . query ( api , 'get_init_block_number_state' ) print ( block_number ) if __name__ == \"__main__\" : run ({ 'host' : '127.0.0.1' , 'port' : 8100 }) The script prints the current block number to the console.","title":"Context"},{"location":"ledger/etch-language/context/#specific-annotated-functions","text":"Smart contract transaction data is available in functions annotated with @init and @action . This means that, putting Context code in @query functions or other functions not equipped to access a Context , should raise an error. Note It is not possible to provide standalone `etch` code snippet examples as `Context` requires a running ledger node.","title":"Specific annotated functions"},{"location":"ledger/etch-language/context/#coding-with-context","text":"Note The only way to get a `Context` is by calling `getContext()`. The Context object has two member functions. block() : returns access to the current Block object - see below. transaction() : returns access to the current Transaction . Check the Transaction documentation for details. We will execute the example below against a local ledger node. Instructions for running a ledger node are here . etch smart contract code is wrapped inside Python Ledger API scripts which take care of the implementation against a running ledger (think truffle/ganache plus web3). Tip Full and complete documentation for the Python Ledger API is currently in development. Please check here for updates.","title":"Coding with Context"},{"location":"ledger/etch-language/context/#getcontext-block-and-blocknumber","text":"To get a Context , call getContext() . From here, you have access to the Block object which has a blockNumber() function that returns the current block number. The following syntax grabs the Context , gets the Block object from the Context , then runs the blockNumber() function of Block which returns the current block number. var context = getContext (); var block = context . block (); var block_number = block . blockNumber ();","title":"getContext(), block(), and blockNumber()"},{"location":"ledger/etch-language/context/#example","text":"The following etch smart contract tests the Context and Block types and the blockNumber() function. persistent init_block_number_state : UInt64 ; @ init function set_block_number ( owner : Address ) : Int64 use init_block_number_state ; var context = getContext (); var block = context . block (); var block_number = block . blockNumber (); init_block_number_state . set ( block_number ); return toInt64 ( block_number ); endfunction @ query function get_init_block_number_state () : UInt64 use init_block_number_state ; return init_block_number_state . get ( 0u64 ); endfunction Now run the above embedded in this script that calls the Python Ledger API. from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity CONTRACT_TEXT = \"[as above]\" def run ( options ): entity1 = Entity () # build the ledger API api = LedgerApi ( options [ 'host' ], options [ 'port' ]) # create wealth so that we have the funds to be able to create contracts on the network api . sync ( api . tokens . wealth ( entity1 , 100000 )) contract = Contract ( CONTRACT_TEXT , entity1 ) # deploy the contract to the network status = api . sync ( api . contracts . create ( entity1 , contract , 20000 ))[ 0 ] block_number = contract . query ( api , 'get_init_block_number_state' ) print ( block_number ) if __name__ == \"__main__\" : run ({ 'host' : '127.0.0.1' , 'port' : 8100 }) The script prints the current block number to the console.","title":"Example"},{"location":"ledger/etch-language/control-flow/","text":"Control flow Tip Make sure to declare the end of the function and construct. if-else function main () var x = 2 ; var y = 2 ; if ( x == y ) printLn ( \"They are equal.\" ); elseif ( x > y ) printLn ( \"x is more than y.\" ); else if ( x > y ) printLn ( \"x is more than y.\" ); else printLn ( \"y is more than x.\" ); endif endif endfunction You can also test the values contained within complex data types for equality. function main () var x = State < Int32 > ( \"account1\" ); var y = State < Int32 > ( \"account2\" ); x . set ( 5 ); y . set ( 8 ); if ( x . get () > y . get ()) printLn ( \"Object x is greater than object y.\" ); else printLn ( \"Object x is less than or equal to object y.\" ); endif endfunction while function main () var i = 0 ; while ( i < 10 ) printLn ( toString ( i )); i += 1 ; endwhile endfunction for function main () // ascending printLn ( \"Ascending for loop.\" ); for ( i in 0 : 5 ) printLn ( toString ( i )); endfor // stepwise ascent printLn ( \"Ascending stepwise.\" ); for ( k in 0 : 10 : 2 ) printLn ( toString ( k )); endfor endfunction break function main () for ( i in 0 : 10 ) printLn ( toString ( i )); if ( i == 5 ) break ; endif endfor endfunction continue function main () var i = 0 ; while ( i < 10 ) i += 1 ; if ( i == 5 ) continue ; endif printLn ( toString ( i )); endwhile endfunction","title":"Control flow"},{"location":"ledger/etch-language/control-flow/#if-else","text":"function main () var x = 2 ; var y = 2 ; if ( x == y ) printLn ( \"They are equal.\" ); elseif ( x > y ) printLn ( \"x is more than y.\" ); else if ( x > y ) printLn ( \"x is more than y.\" ); else printLn ( \"y is more than x.\" ); endif endif endfunction You can also test the values contained within complex data types for equality. function main () var x = State < Int32 > ( \"account1\" ); var y = State < Int32 > ( \"account2\" ); x . set ( 5 ); y . set ( 8 ); if ( x . get () > y . get ()) printLn ( \"Object x is greater than object y.\" ); else printLn ( \"Object x is less than or equal to object y.\" ); endif endfunction","title":"if-else"},{"location":"ledger/etch-language/control-flow/#while","text":"function main () var i = 0 ; while ( i < 10 ) printLn ( toString ( i )); i += 1 ; endwhile endfunction","title":"while"},{"location":"ledger/etch-language/control-flow/#for","text":"function main () // ascending printLn ( \"Ascending for loop.\" ); for ( i in 0 : 5 ) printLn ( toString ( i )); endfor // stepwise ascent printLn ( \"Ascending stepwise.\" ); for ( k in 0 : 10 : 2 ) printLn ( toString ( k )); endfor endfunction","title":"for"},{"location":"ledger/etch-language/control-flow/#break","text":"function main () for ( i in 0 : 10 ) printLn ( toString ( i )); if ( i == 5 ) break ; endif endfor endfunction","title":"break"},{"location":"ledger/etch-language/control-flow/#continue","text":"function main () var i = 0 ; while ( i < 10 ) i += 1 ; if ( i == 5 ) continue ; endif printLn ( toString ( i )); endwhile endfunction","title":"continue"},{"location":"ledger/etch-language/crypto/","text":"SHA256 The SHA256() object gives you a number of ways to generate random 32 byte hashes which are returned as a 64 digit hexadecimal number. Use update() on the SHA256() object to include String or Buffer types into the context before finalising the hash. The final() function generates the hash and returns the value. The reset() function allows you to start over with the same object. function main () // construct a SHA256 object var s = SHA256 (); // update the object with a string s . update ( \"hello\" ); // update the object with a Buffer var buffer = Buffer ( 8 ); s . update ( buffer ); // finalise the object s . final (); // reset the object s . reset (); endfunction Here's another example which builds a SHA256 hash by concatenating strings and applying them to the SHA256() object. The example then resets the object and repeats the process with three more strings. function main () var my_string_value_1 = \"sdkjfhiuwehfesdfno ; s ; ' mADF ; LK \"; var my_string_value_2 = \"ipoiuwr8934jklnwlkj0892;m\" ; var my_string_value_3 = \"vvvowywnklhjxlmxxxxxxxxxxxxxxxxxxxxxxxxtreretrgy653wre6548\" ; // create a SHA256() context object var sha256_hash = SHA256 (); // give it your strings sha256_hash . update ( my_string_value_1 ); sha256_hash . update ( my_string_value_2 ); sha256_hash . update ( my_string_value_3 ); // finalise the context and print the hash value var hash_value_of_concatenated_strings_1_2_3 = sha256_hash . final (); printLn ( \"Hash of my concatenated string 1,2,3 = \" + toString ( hash_value_of_concatenated_strings_1_2_3 )); // RESETTING context of the hasher since we want to start calculate hash from the scratch sha256_hash . reset (); // more strings var my_string_value_4 = \"12345fg\" ; var my_string_value_5 = \"@!#$@#%#\" ; var my_string_value_6 = \"{}:>L$%^:c\" ; // add to context sha256_hash . update ( my_string_value_4 ); sha256_hash . update ( my_string_value_5 ); sha256_hash . update ( my_string_value_6 ); // finalise and print the value var hash_value_of_concatenated_strings_4_5_6 = sha256_hash . final (); printLn ( \"Hash of my concatenated string 4,5,6 = \" + toString ( hash_value_of_concatenated_strings_4_5_6 )); endfunction","title":"Cryptographic functions"},{"location":"ledger/etch-language/data-loaders/","text":"A DataLoader is an object used by an Optimiser for loading data into a Graph . Usually this data is a pair of Tensor types (data and label). Declare and initialise a DataLoader giving a string parameter which defines the type of input data. The common generic DataLoader takes Tensor objects. function main () var dataLoader = DataLoader ( \"tensor\" ); endfunction There are currently three flavours of DataLoader in etch . Fetch.ai developers have built specific DataLoader types for research and example purposes that take MNIST files, and csv files for a commodity application. Tensor data loader Use the addData() function for loading Tensor objects. var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); The following code builds two Tensor objects containing data and label values respectively. These are then loaded into a DataLoader() with the addData() function. function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 2u64 ; data_shape [ 1 ] = 4u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 2u64 ; label_shape [ 1 ] = 4u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); endfunction isDone() and getNext() DataLoader function isDone() returns a boolean if a read has reached the end of a training epoch. The getNext() function iterates through the TrainingPair types contained within a DataLoader . Typically, use isDone() and getNext() together. function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 2u64 ; data_shape [ 1 ] = 4u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 2u64 ; label_shape [ 1 ] = 4u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); while ( ! dataloader . isDone ()) dataloader . getNext (); // do stuff here endwhile endfunction Serialisation A DataLoader is serialisable and deserialisable. The following code stores a DataLoader in a State object. It then creates a new DataLoader object and retrieves the DataLoader from the State . function main () var dataloader = DataLoader ( \"tensor\" ); var dataloader_state = State < DataLoader > ( \"dataloader\" ); dataloader_state . set ( dataloader ); var retrieved_dataloader = DataLoader ( \"tensor\" ); retrieved_dataloader = dataloader_state . get (); endfunction","title":"DataLoader"},{"location":"ledger/etch-language/data-loaders/#tensor-data-loader","text":"Use the addData() function for loading Tensor objects. var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); The following code builds two Tensor objects containing data and label values respectively. These are then loaded into a DataLoader() with the addData() function. function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 2u64 ; data_shape [ 1 ] = 4u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 2u64 ; label_shape [ 1 ] = 4u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); endfunction","title":"Tensor data loader"},{"location":"ledger/etch-language/data-loaders/#isdone-and-getnext","text":"DataLoader function isDone() returns a boolean if a read has reached the end of a training epoch. The getNext() function iterates through the TrainingPair types contained within a DataLoader . Typically, use isDone() and getNext() together. function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 2u64 ; data_shape [ 1 ] = 4u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 2u64 ; label_shape [ 1 ] = 4u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); while ( ! dataloader . isDone ()) dataloader . getNext (); // do stuff here endwhile endfunction","title":"isDone() and getNext()"},{"location":"ledger/etch-language/data-loaders/#serialisation","text":"A DataLoader is serialisable and deserialisable. The following code stores a DataLoader in a State object. It then creates a new DataLoader object and retrieves the DataLoader from the State . function main () var dataloader = DataLoader ( \"tensor\" ); var dataloader_state = State < DataLoader > ( \"dataloader\" ); dataloader_state . set ( dataloader ); var retrieved_dataloader = DataLoader ( \"tensor\" ); retrieved_dataloader = dataloader_state . get (); endfunction","title":"Serialisation"},{"location":"ledger/etch-language/debug/","text":"Debugging tips and tricks Use printLn(toString(...)) to query variables on the command line and in the etch playground. Note In a live environment, the `etch` compiler will strip out `printLn()` statements. Compiling Our compiler is very strict. It will complain about: Unknown and unsupported symbols, operators, and indexes. Lack of types for variables and parameters. Assigning null to primitive types. Incorrect, incompatible, and uninferrable types in statements and functions. Duplicate variables, parameters, and functions. Incomparable types in boolean tests. Unmatched and unexpected beginnings, middles, and endings in selections, iterations, statements, and blocks. Incorrectly formed statements. Incorrect amount, or lack of, operands in boolean tests. break and continue statements outside while or for loops. Non-functions, unmatched functions, and functions that do not return a value. Local function definitions. Returning null or no value from functions. Attempts to construct primitives and unmatched constructors. Mismatches between type and instance functions. Member access support issues with dot operator. while , for , if , var , return , break , continue , variables, and expressions declared at topmost scope. System arguments System.Argc() and System.Argv() give access to compiler argument count and values. The following code prints the number of compiler arguments, then lists their values. function main () var message : String ; printLn ( \"System args: \" + toString ( System . Argc ())); // print the argument values for ( i in 0 : System . Argc ()) message = toString ( i ) + \" = \" + System . Argv ( i ); printLn ( message ); endfor endfunction Running the code from the command line with zero flags -- sends arguments to the etch executable. For example, run the code snippet above with zero flags -- and an example argument hello like this: ./etch sysargs-examples.etch -- hello You should see the following output: F E \u2571 etch v0 .1.0 - 30 - g557389e0 T C Copyright 2018 - 2019 ( c ) Fetch AI Ltd . H System args : 2 0 = . / etch 1 = hello etch features like this are useful for experimentation and debugging in a development environment. For example, the system arguments can load machine learning training data into a script. For smart contracts, there are flags, such as -data , which do specific things. We explain coding, compiling, contract flags, and all about etch smart contracts here .","title":"Debugging"},{"location":"ledger/etch-language/debug/#compiling","text":"Our compiler is very strict. It will complain about: Unknown and unsupported symbols, operators, and indexes. Lack of types for variables and parameters. Assigning null to primitive types. Incorrect, incompatible, and uninferrable types in statements and functions. Duplicate variables, parameters, and functions. Incomparable types in boolean tests. Unmatched and unexpected beginnings, middles, and endings in selections, iterations, statements, and blocks. Incorrectly formed statements. Incorrect amount, or lack of, operands in boolean tests. break and continue statements outside while or for loops. Non-functions, unmatched functions, and functions that do not return a value. Local function definitions. Returning null or no value from functions. Attempts to construct primitives and unmatched constructors. Mismatches between type and instance functions. Member access support issues with dot operator. while , for , if , var , return , break , continue , variables, and expressions declared at topmost scope.","title":"Compiling"},{"location":"ledger/etch-language/debug/#system-arguments","text":"System.Argc() and System.Argv() give access to compiler argument count and values. The following code prints the number of compiler arguments, then lists their values. function main () var message : String ; printLn ( \"System args: \" + toString ( System . Argc ())); // print the argument values for ( i in 0 : System . Argc ()) message = toString ( i ) + \" = \" + System . Argv ( i ); printLn ( message ); endfor endfunction Running the code from the command line with zero flags -- sends arguments to the etch executable. For example, run the code snippet above with zero flags -- and an example argument hello like this: ./etch sysargs-examples.etch -- hello You should see the following output: F E \u2571 etch v0 .1.0 - 30 - g557389e0 T C Copyright 2018 - 2019 ( c ) Fetch AI Ltd . H System args : 2 0 = . / etch 1 = hello etch features like this are useful for experimentation and debugging in a development environment. For example, the system arguments can load machine learning training data into a script. For smart contracts, there are flags, such as -data , which do specific things. We explain coding, compiling, contract flags, and all about etch smart contracts here .","title":"System arguments"},{"location":"ledger/etch-language/error-checking/","text":"The following functions help with diagnosing bugs and ensuring the correct state of variables and boolean tests. Panic Force runtime errors with panic() . Use panic for unrecoverable states. When encountering the state, panic() terminates the program immediately providing feedback. function main () var x = 1 ; var y = 2 ; var z = y + x ; printLn ( toString ( z )); z =- 2 ; if ( z != - 1 ) panic ( \"This is a terrible mistake!\" ); endif printLn ( toString ( z )); endfunction Assert Use assert to ensure state with optional feedback. function main () var x = 1 ; var y = 2 ; var z = y + x ; printLn ( toString ( z )); z =- 2 ; // assert(z == 1); assert ( z == 1 , \"Feedback here.\" ); printLn ( toString ( z )); endfunction","title":"Error checking"},{"location":"ledger/etch-language/error-checking/#panic","text":"Force runtime errors with panic() . Use panic for unrecoverable states. When encountering the state, panic() terminates the program immediately providing feedback. function main () var x = 1 ; var y = 2 ; var z = y + x ; printLn ( toString ( z )); z =- 2 ; if ( z != - 1 ) panic ( \"This is a terrible mistake!\" ); endif printLn ( toString ( z )); endfunction","title":"Panic"},{"location":"ledger/etch-language/error-checking/#assert","text":"Use assert to ensure state with optional feedback. function main () var x = 1 ; var y = 2 ; var z = y + x ; printLn ( toString ( z )); z =- 2 ; // assert(z == 1); assert ( z == 1 , \"Feedback here.\" ); printLn ( toString ( z )); endfunction","title":"Assert"},{"location":"ledger/etch-language/extending-etch/","text":"Extending etch Note Coming soon: details on extending `etch` in C++.","title":"Extending etch"},{"location":"ledger/etch-language/functions/","text":"Functions Writing a function Coding a function in etch is straightforward. All etch programs run in the simulator are triggered by a main() function. This is for development purposes only. Smart contracts do not require a main() function. In the example below, a function myFunction() is called from main() . function main () myFunction (); endfunction // declare the function called from main() function myFunction () printLn ( \"hello\" ); endfunction Parameter and return types The iterative fibonacci function below takes a parameter n: Int32 which is a 32 bit integer type named n . The function returns an Int32 and declares this after the function name and parameter list as : Int32 . function fibonacci ( n : Int32 ) : Int32 var a = 0 ; var b = 1 ; var temp = 0 ; for ( i in 0 : n ) temp = a ; a = b ; b = temp + b ; printLn ( toString ( a )); endfor return a ; endfunction // call fibonacci from main() function main () fibonacci ( 10 ); endfunction Recursion Below is an example of the fibonacci function implemented with recursion. Warning Take care with recursion in smart contract code. function fibonacci ( n : Int32 ) : Int32 if ( n == 1 || n == 0 ) return 1 ; else return ( fibonacci ( n - 1 ) + fibonacci ( n - 2 )); endif endfunction function main () var nterms = 10 ; for ( i in 0 : nterms ) printLn ( toString ( fibonacci ( i ))); endfor endfunction Pass by reference All variables in etch are passed by reference. Attempting to reassign the value of a primitive variable passed to another function will cause a compilation error. function main () var original_value = 10 ; printLn ( original_value ); change_value ( original_value ); printLn ( original_value ); endfunction function change_value ( value : Int32 ) // value = 20 ; // error: assignment operand is not writeable. Failed to compile. endfunction The same is true of complex types. function main () var myArray = Array < Int32 > ( 5 ); change_value ( myArray ); endfunction function change_value ( value : Array < Int32 > ) // value = Array < Int32 > ( 3 ); // error: assignment operand is not writeable. Failed to compile. endfunction However, this is not the case with the internal state of object types such as Array . function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( myArray ); change_value ( myArray ); printLn ( myArray ); endfunction function change_value ( myArray : Array < Int32 > ) myArray [ 2 ] = 100 ; endfunction Reassigning a primitive type to a new variable does not affect the original. function main () var x = 10 ; printLn ( x ); change_value ( x ); printLn ( x ); endfunction function change_value ( value : Int32 ) var y = 20 ; y = value ; printLn ( y ); y = 20 ; endfunction However, reassigning an object and changing any of its internal values does affect the original. function main () var myArray = Array < String > ( 2 ); myArray [ 0 ] = \"hello\" ; printLn ( myArray [ 0 ]); change_value ( myArray ); printLn ( myArray [ 0 ]); endfunction function change_value ( myArray : Array < String > ) myArray [ 0 ] = \"goodbye\" ; endfunction Utility functions Print printLn() is available for printing variables to the console with a line break. print() is available without a line break. Note `etch` strips out all `printLn()` statements in a release environment. This means that logs and other miscellaneous debug code never finds its way onto ledger shards. Sysargs The following System functions Argc() and Argv() return the number of arguments to etch and their value. These functions are used to pass data to the etch simulator. System.Argc() System.Argv() Type casting toInt8() toInt16() toInt64() toUInt8() toUInt16() toUInt32() toUInt64() toFixed32() toFixed64() toFixed128() toString() For example: function main () var x = 10 ; printLn ( x ); var y = toInt8 ( x ); printLn ( y ); var z = toInt16 ( x ); printLn ( z ); var a = toInt32 ( x ); printLn ( a ); var b = toInt64 ( x ); printLn ( b ); var c = toUInt8 ( x ); printLn ( c ); var d = toUInt16 ( x ); printLn ( d ); var e = toUInt32 ( x ); printLn ( e ); var f = toUInt64 ( x ); printLn ( f ); var g = toFixed32 ( x ); printLn ( g ); var h = toFixed64 ( x ); printLn ( h ); var i = toFixed128 ( x ); printLn ( i ); endfunction Annotations etch smart contract code includes annotated functions: @init is a constructor method that initialises the contract. @action is a function which defines transactions on the ledger that change state. @query is a function that allows you to query data residing on the ledger. There are more annotations for synergetic contracts. See more information on Annotations here . Getters and setters Getters and setters are available for StructuredData , State , and ShardedState types. set() get()","title":"Functions"},{"location":"ledger/etch-language/functions/#writing-a-function","text":"Coding a function in etch is straightforward. All etch programs run in the simulator are triggered by a main() function. This is for development purposes only. Smart contracts do not require a main() function. In the example below, a function myFunction() is called from main() . function main () myFunction (); endfunction // declare the function called from main() function myFunction () printLn ( \"hello\" ); endfunction","title":"Writing a function"},{"location":"ledger/etch-language/functions/#parameter-and-return-types","text":"The iterative fibonacci function below takes a parameter n: Int32 which is a 32 bit integer type named n . The function returns an Int32 and declares this after the function name and parameter list as : Int32 . function fibonacci ( n : Int32 ) : Int32 var a = 0 ; var b = 1 ; var temp = 0 ; for ( i in 0 : n ) temp = a ; a = b ; b = temp + b ; printLn ( toString ( a )); endfor return a ; endfunction // call fibonacci from main() function main () fibonacci ( 10 ); endfunction","title":"Parameter and return types"},{"location":"ledger/etch-language/functions/#recursion","text":"Below is an example of the fibonacci function implemented with recursion. Warning Take care with recursion in smart contract code. function fibonacci ( n : Int32 ) : Int32 if ( n == 1 || n == 0 ) return 1 ; else return ( fibonacci ( n - 1 ) + fibonacci ( n - 2 )); endif endfunction function main () var nterms = 10 ; for ( i in 0 : nterms ) printLn ( toString ( fibonacci ( i ))); endfor endfunction","title":"Recursion"},{"location":"ledger/etch-language/functions/#pass-by-reference","text":"All variables in etch are passed by reference. Attempting to reassign the value of a primitive variable passed to another function will cause a compilation error. function main () var original_value = 10 ; printLn ( original_value ); change_value ( original_value ); printLn ( original_value ); endfunction function change_value ( value : Int32 ) // value = 20 ; // error: assignment operand is not writeable. Failed to compile. endfunction The same is true of complex types. function main () var myArray = Array < Int32 > ( 5 ); change_value ( myArray ); endfunction function change_value ( value : Array < Int32 > ) // value = Array < Int32 > ( 3 ); // error: assignment operand is not writeable. Failed to compile. endfunction However, this is not the case with the internal state of object types such as Array . function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( myArray ); change_value ( myArray ); printLn ( myArray ); endfunction function change_value ( myArray : Array < Int32 > ) myArray [ 2 ] = 100 ; endfunction Reassigning a primitive type to a new variable does not affect the original. function main () var x = 10 ; printLn ( x ); change_value ( x ); printLn ( x ); endfunction function change_value ( value : Int32 ) var y = 20 ; y = value ; printLn ( y ); y = 20 ; endfunction However, reassigning an object and changing any of its internal values does affect the original. function main () var myArray = Array < String > ( 2 ); myArray [ 0 ] = \"hello\" ; printLn ( myArray [ 0 ]); change_value ( myArray ); printLn ( myArray [ 0 ]); endfunction function change_value ( myArray : Array < String > ) myArray [ 0 ] = \"goodbye\" ; endfunction","title":"Pass by reference"},{"location":"ledger/etch-language/functions/#utility-functions","text":"","title":"Utility functions"},{"location":"ledger/etch-language/functions/#print","text":"printLn() is available for printing variables to the console with a line break. print() is available without a line break. Note `etch` strips out all `printLn()` statements in a release environment. This means that logs and other miscellaneous debug code never finds its way onto ledger shards.","title":"Print"},{"location":"ledger/etch-language/functions/#sysargs","text":"The following System functions Argc() and Argv() return the number of arguments to etch and their value. These functions are used to pass data to the etch simulator. System.Argc() System.Argv()","title":"Sysargs"},{"location":"ledger/etch-language/functions/#type-casting","text":"toInt8() toInt16() toInt64() toUInt8() toUInt16() toUInt32() toUInt64() toFixed32() toFixed64() toFixed128() toString() For example: function main () var x = 10 ; printLn ( x ); var y = toInt8 ( x ); printLn ( y ); var z = toInt16 ( x ); printLn ( z ); var a = toInt32 ( x ); printLn ( a ); var b = toInt64 ( x ); printLn ( b ); var c = toUInt8 ( x ); printLn ( c ); var d = toUInt16 ( x ); printLn ( d ); var e = toUInt32 ( x ); printLn ( e ); var f = toUInt64 ( x ); printLn ( f ); var g = toFixed32 ( x ); printLn ( g ); var h = toFixed64 ( x ); printLn ( h ); var i = toFixed128 ( x ); printLn ( i ); endfunction","title":"Type casting"},{"location":"ledger/etch-language/functions/#annotations","text":"etch smart contract code includes annotated functions: @init is a constructor method that initialises the contract. @action is a function which defines transactions on the ledger that change state. @query is a function that allows you to query data residing on the ledger. There are more annotations for synergetic contracts. See more information on Annotations here .","title":"Annotations"},{"location":"ledger/etch-language/functions/#getters-and-setters","text":"Getters and setters are available for StructuredData , State , and ShardedState types. set() get()","title":"Getters and setters"},{"location":"ledger/etch-language/getstarted/","text":"Getting started Prerequisites To build with Etch, you will need a running node. Installation At the root of your ledger installation directory cd into build folder. Run make etch . Setup At the root of your ledger installation directory cd into apps/etch . Run ./etch with filename, flags, and arguments: ./etch [options] <filename> -- [script args] . For example: ./etch hello-world.etch -data test.json . This runs a hello-world.etch file and produces a json file containing info on the data required by the contract. Hello world with Etch Let's use the etch simulator for the development process. Unlike Smart Contracts, Etch code needs a main() function as it's entry point. @testCase function main () printLn ( \"Hello, world\" ); endfunction You can test this contract with the etch executable. Save this code snippet to hello_world.etch Run the following from your build directory: ./apps/etch/etch hello_world.etch This produces an output similar to: F E \u2571 etch v0.4.1-rc3 T C Copyright 2018-2019 (c) Fetch AI Ltd. H Hello, world! main is the default runner function in etch . When submitting the smart contract to the ledger, we do not need the main function as it is inaccessible to the ledger code. Compile and run two or more etch files It is possible to compile and run two or more etch files in one go. The files are not order dependent and the single main() function can be in any of the files. For example, run ./etch file-1.etch file-2.etch file-n.etch . Etch playground You can run all the examples in these docs in the etch playground here as well as on the command line.","title":"Getting started"},{"location":"ledger/etch-language/getstarted/#getting-started","text":"","title":"Getting started"},{"location":"ledger/etch-language/getstarted/#prerequisites","text":"To build with Etch, you will need a running node.","title":"Prerequisites"},{"location":"ledger/etch-language/getstarted/#installation","text":"At the root of your ledger installation directory cd into build folder. Run make etch .","title":"Installation"},{"location":"ledger/etch-language/getstarted/#setup","text":"At the root of your ledger installation directory cd into apps/etch . Run ./etch with filename, flags, and arguments: ./etch [options] <filename> -- [script args] . For example: ./etch hello-world.etch -data test.json . This runs a hello-world.etch file and produces a json file containing info on the data required by the contract.","title":"Setup"},{"location":"ledger/etch-language/getstarted/#hello-world-with-etch","text":"Let's use the etch simulator for the development process. Unlike Smart Contracts, Etch code needs a main() function as it's entry point. @testCase function main () printLn ( \"Hello, world\" ); endfunction You can test this contract with the etch executable. Save this code snippet to hello_world.etch Run the following from your build directory: ./apps/etch/etch hello_world.etch This produces an output similar to: F E \u2571 etch v0.4.1-rc3 T C Copyright 2018-2019 (c) Fetch AI Ltd. H Hello, world! main is the default runner function in etch . When submitting the smart contract to the ledger, we do not need the main function as it is inaccessible to the ledger code.","title":"Hello world with Etch"},{"location":"ledger/etch-language/getstarted/#compile-and-run-two-or-more-etch-files","text":"It is possible to compile and run two or more etch files in one go. The files are not order dependent and the single main() function can be in any of the files. For example, run ./etch file-1.etch file-2.etch file-n.etch .","title":"Compile and run two or more etch files"},{"location":"ledger/etch-language/getstarted/#etch-playground","text":"You can run all the examples in these docs in the etch playground here as well as on the command line.","title":"Etch playground"},{"location":"ledger/etch-language/graph/","text":"Declare and initialise a Graph . function main () var graph = Graph (); endfunction A Graph is a directed acyclic computational graph used to process data through a sequence of operations. The current primary use case for these is the instantiation of neural networks. Each node in the Graph maintains responsibility for either a single operation or a layer of operations. The preferred method for training a Graph is to use a DataLoader and Optimiser . We describe these two objects in a later section. Placeholders Placeholder nodes store data on the Graph . Use them to set the input for computing a forward pass of a neural network. Create a placeholder node with addPlaceholder() . function main () var graph = Graph (); graph . addPlaceholder ( \"my_tensor\" ); endfunction Layers Fully connected Add a fully connected layer to a Graph with the function addFullyConnected() . It takes four input parameters specifying the name of the fully connected node, the name of a previously defined node, input size, and output size. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addFullyConnected ( \"connected\" , \"my_tensor\" , 3 * 3 , 4 ); endfunction 1D convolution The addConv1D() training node operation of a Graph convolves the input layer in one dimension. It takes six parameters specifying the name of the node, the name of a previously defined node (to feed input), the number of filters, number of input channels, kernel size, and stride size respectively. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 3 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addConv1D ( \"conv\" , \"my_tensor\" , 3 , 3 , 3 , 2 ); endfunction Operations Activations ReLU The addRelu() function of a Graph adds a node which contains the rectified linear unit (ReLU) activation function. Its behaviour can be characterised as returning x if x > 0 , or 0 otherwise. It takes two parameters specifying the node name and the name of a node which feeds input to the ReLU. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addRelu ( \"relu\" , \"my_tensor\" ); endfunction Softmax The addSoftmax() function of a Graph adds a node to the Graph that applies the softmax activation function to the input Tensor . It takes two parameters specifying the name of the node and the name of an existing node that feeds input data. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addSoftmax ( \"softmax\" , \"my_tensor\" ); endfunction Dropout The addDropout() function of a Graph adds a node that applies the dropout activation function to the input Tensor . It takes three parameters specifying the name of the node, the name of an existing node that feeds input data, and a Fixed64 type with a value between 0 and 1 specifying the dropout randomisation value. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addDropout ( \"dropout\" , \"my_tensor\" , 0.5f p64 ); endfunction Transpose The addTranspose() function of a Graph adds a node to the Graph that applies the transpose activation function to the input Tensor . It takes two parameters specifying the name of the node and the name of an existing node that feeds input data. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addTranspose ( \"transpose\" , \"my_tensor\" ); endfunction Exp The addExp() function of a Graph adds a node to the Graph that applies the exp activation function to the input Tensor . It takes two parameters specifying the name of the node and the name of an existing node that feeds input data. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addExp ( \"exp\" , \"my_tensor\" ); endfunction Loss functions Cross entropy loss The addCrossEntropyLoss() function of a Graph is a loss function measuring the performance of a classification model. It takes three parameters specifying the name of the node, the name of the input data node, and the name of the label data node. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); input_tensor . fillRandom (); var label_tensor = Tensor ( tensor_shape ); label_tensor . fillRandom (); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); graph . addCrossEntropyLoss ( \"cross_entropy_loss\" , \"input\" , \"label\" ); endfunction Mean square error loss The addMeanSquareErrorLoss() function of a Graph is a loss function measuring the average of the square of errors. It takes three parameters specifying the name of the node, the name of the input data node, and the name of the label data node. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); input_tensor . fillRandom (); var label_tensor = Tensor ( tensor_shape ); label_tensor . fillRandom (); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); graph . addMeanSquareErrorLoss ( \"mean_square_error_loss\" , \"input\" , \"label\" ); endfunction Serialisation For storing on the Fetch.ai Ledger, a Graph is serialisable and deserialisable. The following code stores a Graph in a State object. It then creates a new Graph object and retrieves the previously stored Graph data from the State . function main () var graph = Graph (); var graph_state = State < Graph > ( \"graph\" ); graph_state . set ( graph ); var retrieved_graph = Graph (); retrieved_graph = graph_state . get (); endfunction Serialise to string It is possible to store Graph data in a string. This facilitates smart contract function calls. Create a string representation of a Graph with the serialiseToString() function. Then, serialise the Graph by setting the string into a State . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 2u64 ; tensor_shape [ 1 ] = 10u64 ; var data_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); data_tensor . fill ( 7.0f p64 ); label_tensor . fill ( 7.0f p64 ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addRelu ( \"Output\" , \"Input\" ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); graph . setInput ( \"Input\" , data_tensor ); graph . setInput ( \"Label\" , label_tensor ); var graph_string = graph . serializeToString (); // demo the graph string printLn ( graph_string ); // serialise the Graph with its hex string representation var state = State < String > ( \"graph_state\" ); state . set ( graph_string ); graph . evaluate ( \"Error\" ); endfunction Deserialise from string Retrieve a Graph from the ledger via its string representation with the deserialiseFromString() function. function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 2u64 ; tensor_shape [ 1 ] = 10u64 ; var data_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); data_tensor . fill ( 7.0f p64 ); label_tensor . fill ( 7.0f p64 ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addRelu ( \"Output\" , \"Input\" ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); graph . setInput ( \"Input\" , data_tensor ); graph . setInput ( \"Label\" , label_tensor ); var graph_string = graph . serializeToString (); // serialise the Graph with its hex string representation var state = State < String > ( \"graph_state\" ); state . set ( graph_string ); graph . evaluate ( \"Error\" ); var retrieved_state = State < String > ( \"graph_state\" ); var retrieved_graph_string = retrieved_state . get (); // demo the Graph string printLn ( retrieved_graph_string ); var retrieved_graph = Graph (); retrieved_graph = retrieved_graph . deserializeFromString ( retrieved_graph_string ); endfunction Build a Graph example The example below builds a Graph object by first adding two placeholder nodes which will contain the input and label data. Next, a fully connected layer is set up, FC_1 , containing 128 neurons and taking input data of size 28x28 . The output will feed into a ReLU activation, Relu_1 . These two steps are repeated with new fully connected layer FC_2 taking Relu_1 as input and consequently lowering the input dimension and output neurons. The output of this, FC_2 , is fed into another ReLU activation, Relu_2 . Finally, after running a final fully connected layer, we will calculate a soft max activation before applying the cross entropy loss function against the Label data to evaluate the accuracy of the model. The code does not show steps for loading the data or training the Graph . function main () // define the neural network var g = Graph (); // placeholders to map input data g . addPlaceholder ( \"Input\" ); g . addPlaceholder ( \"Label\" ); // fully connected layers with ReLU g . addFullyConnected ( \"FC_1\" , \"Input\" , 28 * 28 , 128 ); g . addRelu ( \"Relu_1\" , \"FC_1\" ); g . addFullyConnected ( \"FC_2\" , \"Relu_1\" , 128 , 64 ); g . addRelu ( \"Relu_2\" , \"FC_2\" ); // fully connected layer with soft max g . addFullyConnected ( \"FC_3\" , \"Relu_2\" , 64 , 10 ); g . addSoftmax ( \"Softmax\" , \"FC_3\" ); // loss function g . addCrossEntropyLoss ( \"Error\" , \"Softmax\" , \"Label\" ); // load data here // run operations here endfunction Training a Graph example Manually train a neural network on a graph by repeatedly processing the following 4 steps: Set input data to Graph placeholders. Evaluate a forward pass on the Graph . Back propagate through the Graph (to compute gradients). Apply gradients to the weights calculated at the back propagation. Steps 1-3 may be processed multiple times prior to processing step 4 (the gradients will accumulate). In etch , these functions are taken care of by the more efficient DataLoader and Optimiser objects which we will see in a later section. 1. Set input Add Tensor input or training data to a Graph with the setInput() function which takes a previously set placeholder string. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . addFullyConnected ( \"fc1\" , \"input\" , 1 , 3 ); graph . addMeanSquareErrorLoss ( \"error\" , \"fc1\" , \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); endfunction 2. Evaluate The evaluate() method performs a forward pass on the Graph , computing the output of all operations/layers as required and leading to the specified output node. The return parameter is the Tensor computed at the output of the specified node. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . addFullyConnected ( \"fc1\" , \"input\" , 1 , 3 ); graph . addMeanSquareErrorLoss ( \"error\" , \"fc1\" , \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); // perform a forward pass var loss = graph . evaluate ( \"error\" ); endfunction 3. Back propagate Perform back propagation with the backPropagate() function. The function back propagates from the specified node through all ops leading to it. Having already made a prediction via the forward pass through the Graph , backPropagate() computes the error gradient with respect to the weights in every node. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . addFullyConnected ( \"fc1\" , \"input\" , 1 , 3 ); graph . addMeanSquareErrorLoss ( \"error\" , \"fc1\" , \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); // perform a forward pass var loss = graph . evaluate ( \"error\" ); // run back propagation graph . backPropagate ( \"error\" ); endfunction 4. Step Run the step() function on a Graph to generate the results. The function applies the SGD function to weights calculated by the previous training cycles. The Fixed64 parameter value the function takes is the learning rate. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . addFullyConnected ( \"fc1\" , \"input\" , 1 , 3 ); graph . addMeanSquareErrorLoss ( \"error\" , \"fc1\" , \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); // perform a forward pass var loss = graph . evaluate ( \"error\" ); // run back propagation graph . backPropagate ( \"error\" ); // call step graph . step ( 0.1f p64 ); endfunction Note `step()` will be deprecated in favour of `applyGradients()`.","title":"Graph"},{"location":"ledger/etch-language/graph/#placeholders","text":"Placeholder nodes store data on the Graph . Use them to set the input for computing a forward pass of a neural network. Create a placeholder node with addPlaceholder() . function main () var graph = Graph (); graph . addPlaceholder ( \"my_tensor\" ); endfunction","title":"Placeholders"},{"location":"ledger/etch-language/graph/#layers","text":"","title":"Layers"},{"location":"ledger/etch-language/graph/#fully-connected","text":"Add a fully connected layer to a Graph with the function addFullyConnected() . It takes four input parameters specifying the name of the fully connected node, the name of a previously defined node, input size, and output size. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addFullyConnected ( \"connected\" , \"my_tensor\" , 3 * 3 , 4 ); endfunction","title":"Fully connected"},{"location":"ledger/etch-language/graph/#1d-convolution","text":"The addConv1D() training node operation of a Graph convolves the input layer in one dimension. It takes six parameters specifying the name of the node, the name of a previously defined node (to feed input), the number of filters, number of input channels, kernel size, and stride size respectively. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 3 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addConv1D ( \"conv\" , \"my_tensor\" , 3 , 3 , 3 , 2 ); endfunction","title":"1D convolution"},{"location":"ledger/etch-language/graph/#operations","text":"","title":"Operations"},{"location":"ledger/etch-language/graph/#activations","text":"","title":"Activations"},{"location":"ledger/etch-language/graph/#relu","text":"The addRelu() function of a Graph adds a node which contains the rectified linear unit (ReLU) activation function. Its behaviour can be characterised as returning x if x > 0 , or 0 otherwise. It takes two parameters specifying the node name and the name of a node which feeds input to the ReLU. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addRelu ( \"relu\" , \"my_tensor\" ); endfunction","title":"ReLU"},{"location":"ledger/etch-language/graph/#softmax","text":"The addSoftmax() function of a Graph adds a node to the Graph that applies the softmax activation function to the input Tensor . It takes two parameters specifying the name of the node and the name of an existing node that feeds input data. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addSoftmax ( \"softmax\" , \"my_tensor\" ); endfunction","title":"Softmax"},{"location":"ledger/etch-language/graph/#dropout","text":"The addDropout() function of a Graph adds a node that applies the dropout activation function to the input Tensor . It takes three parameters specifying the name of the node, the name of an existing node that feeds input data, and a Fixed64 type with a value between 0 and 1 specifying the dropout randomisation value. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addDropout ( \"dropout\" , \"my_tensor\" , 0.5f p64 ); endfunction","title":"Dropout"},{"location":"ledger/etch-language/graph/#transpose","text":"The addTranspose() function of a Graph adds a node to the Graph that applies the transpose activation function to the input Tensor . It takes two parameters specifying the name of the node and the name of an existing node that feeds input data. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addTranspose ( \"transpose\" , \"my_tensor\" ); endfunction","title":"Transpose"},{"location":"ledger/etch-language/graph/#exp","text":"The addExp() function of a Graph adds a node to the Graph that applies the exp activation function to the input Tensor . It takes two parameters specifying the name of the node and the name of an existing node that feeds input data. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); graph . addPlaceholder ( \"my_tensor\" ); graph . setInput ( \"my_tensor\" , tensor ); graph . addExp ( \"exp\" , \"my_tensor\" ); endfunction","title":"Exp"},{"location":"ledger/etch-language/graph/#loss-functions","text":"","title":"Loss functions"},{"location":"ledger/etch-language/graph/#cross-entropy-loss","text":"The addCrossEntropyLoss() function of a Graph is a loss function measuring the performance of a classification model. It takes three parameters specifying the name of the node, the name of the input data node, and the name of the label data node. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); input_tensor . fillRandom (); var label_tensor = Tensor ( tensor_shape ); label_tensor . fillRandom (); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); graph . addCrossEntropyLoss ( \"cross_entropy_loss\" , \"input\" , \"label\" ); endfunction","title":"Cross entropy loss"},{"location":"ledger/etch-language/graph/#mean-square-error-loss","text":"The addMeanSquareErrorLoss() function of a Graph is a loss function measuring the average of the square of errors. It takes three parameters specifying the name of the node, the name of the input data node, and the name of the label data node. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); input_tensor . fillRandom (); var label_tensor = Tensor ( tensor_shape ); label_tensor . fillRandom (); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); graph . addMeanSquareErrorLoss ( \"mean_square_error_loss\" , \"input\" , \"label\" ); endfunction","title":"Mean square error loss"},{"location":"ledger/etch-language/graph/#serialisation","text":"For storing on the Fetch.ai Ledger, a Graph is serialisable and deserialisable. The following code stores a Graph in a State object. It then creates a new Graph object and retrieves the previously stored Graph data from the State . function main () var graph = Graph (); var graph_state = State < Graph > ( \"graph\" ); graph_state . set ( graph ); var retrieved_graph = Graph (); retrieved_graph = graph_state . get (); endfunction","title":"Serialisation"},{"location":"ledger/etch-language/graph/#serialise-to-string","text":"It is possible to store Graph data in a string. This facilitates smart contract function calls. Create a string representation of a Graph with the serialiseToString() function. Then, serialise the Graph by setting the string into a State . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 2u64 ; tensor_shape [ 1 ] = 10u64 ; var data_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); data_tensor . fill ( 7.0f p64 ); label_tensor . fill ( 7.0f p64 ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addRelu ( \"Output\" , \"Input\" ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); graph . setInput ( \"Input\" , data_tensor ); graph . setInput ( \"Label\" , label_tensor ); var graph_string = graph . serializeToString (); // demo the graph string printLn ( graph_string ); // serialise the Graph with its hex string representation var state = State < String > ( \"graph_state\" ); state . set ( graph_string ); graph . evaluate ( \"Error\" ); endfunction","title":"Serialise to string"},{"location":"ledger/etch-language/graph/#deserialise-from-string","text":"Retrieve a Graph from the ledger via its string representation with the deserialiseFromString() function. function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 2u64 ; tensor_shape [ 1 ] = 10u64 ; var data_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); data_tensor . fill ( 7.0f p64 ); label_tensor . fill ( 7.0f p64 ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addRelu ( \"Output\" , \"Input\" ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); graph . setInput ( \"Input\" , data_tensor ); graph . setInput ( \"Label\" , label_tensor ); var graph_string = graph . serializeToString (); // serialise the Graph with its hex string representation var state = State < String > ( \"graph_state\" ); state . set ( graph_string ); graph . evaluate ( \"Error\" ); var retrieved_state = State < String > ( \"graph_state\" ); var retrieved_graph_string = retrieved_state . get (); // demo the Graph string printLn ( retrieved_graph_string ); var retrieved_graph = Graph (); retrieved_graph = retrieved_graph . deserializeFromString ( retrieved_graph_string ); endfunction","title":"Deserialise from string"},{"location":"ledger/etch-language/graph/#build-a-graph-example","text":"The example below builds a Graph object by first adding two placeholder nodes which will contain the input and label data. Next, a fully connected layer is set up, FC_1 , containing 128 neurons and taking input data of size 28x28 . The output will feed into a ReLU activation, Relu_1 . These two steps are repeated with new fully connected layer FC_2 taking Relu_1 as input and consequently lowering the input dimension and output neurons. The output of this, FC_2 , is fed into another ReLU activation, Relu_2 . Finally, after running a final fully connected layer, we will calculate a soft max activation before applying the cross entropy loss function against the Label data to evaluate the accuracy of the model. The code does not show steps for loading the data or training the Graph . function main () // define the neural network var g = Graph (); // placeholders to map input data g . addPlaceholder ( \"Input\" ); g . addPlaceholder ( \"Label\" ); // fully connected layers with ReLU g . addFullyConnected ( \"FC_1\" , \"Input\" , 28 * 28 , 128 ); g . addRelu ( \"Relu_1\" , \"FC_1\" ); g . addFullyConnected ( \"FC_2\" , \"Relu_1\" , 128 , 64 ); g . addRelu ( \"Relu_2\" , \"FC_2\" ); // fully connected layer with soft max g . addFullyConnected ( \"FC_3\" , \"Relu_2\" , 64 , 10 ); g . addSoftmax ( \"Softmax\" , \"FC_3\" ); // loss function g . addCrossEntropyLoss ( \"Error\" , \"Softmax\" , \"Label\" ); // load data here // run operations here endfunction","title":"Build a Graph example"},{"location":"ledger/etch-language/graph/#training-a-graph-example","text":"Manually train a neural network on a graph by repeatedly processing the following 4 steps: Set input data to Graph placeholders. Evaluate a forward pass on the Graph . Back propagate through the Graph (to compute gradients). Apply gradients to the weights calculated at the back propagation. Steps 1-3 may be processed multiple times prior to processing step 4 (the gradients will accumulate). In etch , these functions are taken care of by the more efficient DataLoader and Optimiser objects which we will see in a later section.","title":"Training a Graph example"},{"location":"ledger/etch-language/graph/#1-set-input","text":"Add Tensor input or training data to a Graph with the setInput() function which takes a previously set placeholder string. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . addFullyConnected ( \"fc1\" , \"input\" , 1 , 3 ); graph . addMeanSquareErrorLoss ( \"error\" , \"fc1\" , \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); endfunction","title":"1. Set input"},{"location":"ledger/etch-language/graph/#2-evaluate","text":"The evaluate() method performs a forward pass on the Graph , computing the output of all operations/layers as required and leading to the specified output node. The return parameter is the Tensor computed at the output of the specified node. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . addFullyConnected ( \"fc1\" , \"input\" , 1 , 3 ); graph . addMeanSquareErrorLoss ( \"error\" , \"fc1\" , \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); // perform a forward pass var loss = graph . evaluate ( \"error\" ); endfunction","title":"2. Evaluate"},{"location":"ledger/etch-language/graph/#3-back-propagate","text":"Perform back propagation with the backPropagate() function. The function back propagates from the specified node through all ops leading to it. Having already made a prediction via the forward pass through the Graph , backPropagate() computes the error gradient with respect to the weights in every node. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . addFullyConnected ( \"fc1\" , \"input\" , 1 , 3 ); graph . addMeanSquareErrorLoss ( \"error\" , \"fc1\" , \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); // perform a forward pass var loss = graph . evaluate ( \"error\" ); // run back propagation graph . backPropagate ( \"error\" ); endfunction","title":"3. Back propagate"},{"location":"ledger/etch-language/graph/#4-step","text":"Run the step() function on a Graph to generate the results. The function applies the SGD function to weights calculated by the previous training cycles. The Fixed64 parameter value the function takes is the learning rate. function main () var graph = Graph (); var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var input_tensor = Tensor ( tensor_shape ); var label_tensor = Tensor ( tensor_shape ); graph . addPlaceholder ( \"input\" ); graph . addPlaceholder ( \"label\" ); graph . addFullyConnected ( \"fc1\" , \"input\" , 1 , 3 ); graph . addMeanSquareErrorLoss ( \"error\" , \"fc1\" , \"label\" ); graph . setInput ( \"input\" , input_tensor ); graph . setInput ( \"label\" , label_tensor ); // perform a forward pass var loss = graph . evaluate ( \"error\" ); // run back propagation graph . backPropagate ( \"error\" ); // call step graph . step ( 0.1f p64 ); endfunction Note `step()` will be deprecated in favour of `applyGradients()`.","title":"4. Step"},{"location":"ledger/etch-language/logic/","text":"Logical operators Equal to function main () var x = 12 ; var y = 12 ; if ( x == y ) printLn ( \"Equal.\" ); endif endfunction Not equal to function main () var x = 12 ; var y = 11 ; if ( x != y ) printLn ( \"Not equal.\" ); endif endfunction Less than function main () var x = 12 ; var y = 11 ; if ( y < x ) printLn ( \"Less than.\" ); endif if ( y <= x ) printLn ( \"Less than or equal to.\" ); endif endfunction More than function main () var x = 12 ; var y = 11 ; if ( x > y ) printLn ( \"More than.\" ); endif if ( x >= y ) printLn ( \"More than or equal to.\" ); endif endfunction And function main () var f : Bool = false ; var t : Bool = true ; if ( f && t ) printLn ( \"True.\" ); else printLn ( \"False.\" ); endif endfunction Or function main () var f : Bool = false ; var t : Bool = true ; if ( f || t ) printLn ( \"True.\" ); else printLn ( \"False.\" ); endif endfunction Xor Note Coming soon: support for `xor`.","title":"Logical operators"},{"location":"ledger/etch-language/logic/#equal-to","text":"function main () var x = 12 ; var y = 12 ; if ( x == y ) printLn ( \"Equal.\" ); endif endfunction","title":"Equal to"},{"location":"ledger/etch-language/logic/#not-equal-to","text":"function main () var x = 12 ; var y = 11 ; if ( x != y ) printLn ( \"Not equal.\" ); endif endfunction","title":"Not equal to"},{"location":"ledger/etch-language/logic/#less-than","text":"function main () var x = 12 ; var y = 11 ; if ( y < x ) printLn ( \"Less than.\" ); endif if ( y <= x ) printLn ( \"Less than or equal to.\" ); endif endfunction","title":"Less than"},{"location":"ledger/etch-language/logic/#more-than","text":"function main () var x = 12 ; var y = 11 ; if ( x > y ) printLn ( \"More than.\" ); endif if ( x >= y ) printLn ( \"More than or equal to.\" ); endif endfunction","title":"More than"},{"location":"ledger/etch-language/logic/#and","text":"function main () var f : Bool = false ; var t : Bool = true ; if ( f && t ) printLn ( \"True.\" ); else printLn ( \"False.\" ); endif endfunction","title":"And"},{"location":"ledger/etch-language/logic/#or","text":"function main () var f : Bool = false ; var t : Bool = true ; if ( f || t ) printLn ( \"True.\" ); else printLn ( \"False.\" ); endif endfunction","title":"Or"},{"location":"ledger/etch-language/logic/#xor","text":"Note Coming soon: support for `xor`.","title":"Xor"},{"location":"ledger/etch-language/maths-functions/","text":"Tip `Fixed64` is the default variable data type used by the `etch` mathematics and machine learning libraries. In the current version, and further to the common mathematical operations provided by the etch language already discussed here , the following functions are available. Absolute value abs() returns the absolute value of all signed integer types. function main () // 8 bit signed integers var int_8_bit = 1 i8 ; printLn ( toString ( abs ( int_8_bit ))); var neg_int_8_bit = - 1 i8 ; printLn ( toString ( abs ( neg_int_8_bit ))); // 16 bit signed integers var int_16_bit = 1 i16 ; printLn ( toString ( abs ( int_8_bit ))); var neg_int_16_bit = - 1 i16 ; printLn ( toString ( abs ( neg_int_16_bit ))); // 32 bit signed integers var int_32_bit = 1 ; printLn ( toString ( abs ( int_32_bit ))); var neg_int_32_bit = - 1 ; printLn ( toString ( abs ( neg_int_32_bit ))); // 64 bit signed integers var int_64_bit = 1 i64 ; printLn ( toString ( abs ( int_64_bit ))); var neg_int_64_bit = - 1 i64 ; printLn ( toString ( abs ( neg_int_64_bit ))); endfunction And positive unsigned integer types. function main () // 8 bit unsigned integers var int_8_bit = 1u8 ; printLn ( toString ( abs ( int_8_bit ))); // 16 bit unsigned integers var int_16_bit = 1u16 ; printLn ( toString ( abs ( int_8_bit ))); // 32 bit unsigned integers var int_32_bit = 1u32 ; printLn ( toString ( abs ( int_32_bit ))); // 64 bit unsigned integers var int_64_bit = 1u64 ; printLn ( toString ( abs ( int_64_bit ))); endfunction And fixed point types. function main () // 32 bit fixed point var fixed_32 = 1.0f p32 ; printLn ( toString ( abs ( fixed_32 ))); var neg_fixed_32 = - 1.0f p32 ; printLn ( toString ( abs ( neg_fixed_32 ))); // 64 bit fixed point var fixed_64 = 1.0f p64 ; printLn ( toString ( abs ( fixed_64 ))); var neg_fixed_64 = - 1.0f p64 ; printLn ( toString ( abs ( neg_fixed_64 ))); // 128 bit fixed point var fixed_128 = 1.0f p128 ; printLn ( toString ( abs ( fixed_128 ))); var neg_fixed_128 = - 1.0f p128 ; printLn ( toString ( abs ( neg_fixed_128 ))); endfunction Exponential function The exponential function returns the value of e to the number given, exp(x) = e x where e is Euler's base of natural logarithms. The exponential function is limited to fixed point variables. function main () var a = 2.0f p32 ; var b = 3.0f p64 ; var c = 4.0f p128 ; printLn ( toString ( exp ( a ))); printLn ( toString ( exp ( b ))); printLn ( toString ( exp ( c ))); endfunction Range restrictions Fixed32 accuracy is limited within the range [-10.3974, 10.3974] . Fixed64 accuracy is limited within the range [-21.48756260, 21.48756260] . Fixed128 accuracy is limited within the range [-43.6682723752765511, 43.6682723752765511] . Running the exponential function on numbers outside of this range produces unexpected results. Warning If the implementation of a function depends on exp() then accuracy is limited within a range dependent on the implementation. Warning For Fixed point types, take extra care because, even though the type has a reduced range, it has an increased accuracy within that range. Special cases Scenario Result x is NaN e^x = NaN x < MIN_EXP e^x = 0 x > MAX_EXP overflow_error exception x == 1 e^x = e x == 0 e^x = 1 x == -inf e^(-inf) = 0 x == +inf e^(+inf) = +inf x < 0 e^x = 1/e^(-x) Errors for x \u2208 (-10, 5) Fixed32 : average: 0.000178116 , max: 0.00584819 Fixed64 : average: 4.97318e-09 , max: 1.66689e-07 Power The power function returns the value of the first parameter raised to the second. The power function is limited to fixed point variables. function main () var a = 2.0f p64 ; var b = 3.0f p64 ; printLn ( toString ( pow ( a , b ))); var c = 4.0f p32 ; var d = 5.0f p32 ; printLn ( toString ( pow ( c , d ))); var e = 2.0f p128 ; var f = 3.0f p128 ; printLn ( toString ( pow ( e , f ))); endfunction Warn The pow() implementation depends on exp() so the range is limited. The implementation is as follows: `x^y = exp(y * log(x));` Special cases Scenario Result x or y is NaN pow(x, y) = NaN x == 0 , y == 0 pow(x, y) = NaN x == 0 , y != 0 pow(x, y) = 0 x any , y == 0 pow(x, y) = 1 x < 0 , y non int pow(x, y) = NaN x +/-inf pow(x, y) = x < 0 , y int pow(x, y) = \\prod_1^y x Errors for x \u2208 (0, 100), y \u2208 (0, 10.5) Fixed32 : average: 1.49365e-06 , max: 3.04673e-05 Fixed64 : average: 8.45537e-12 , max: 8.70098e-10 Errors for x \u2208 (-10, 10), y \u2208 (-4, 4) Fixed32 : average: 3.9093e-06 , max: 9.15527e-06 Fixed64 : average: 7.71863e-11 , max: 2.25216e-10 Random (non deterministic) You can currently generate non-deterministic, random, signed and unsigned integers (not 8 bit types), and floats. The beginning value of the range must be less than the end value. function main () // var randUInt8 = rand ( 0u8 , 1000u8 ); // error: unable to find matching function for 'Rand' //printLn(toString(randUInt8)); // unpermitted range // var rand_test = rand(100u16, 0u16); // runtime error: Invalid argument: rand(a, b) must satisfy a < b var randUInt16 = rand ( 0u16 , 1000u16 ); printLn ( toString ( randUInt16 )); var randUInt32 = rand ( 0u32 , 1000u32 ); printLn ( toString ( randUInt32 )); var randUInt64 = rand ( 0u64 , 1000u64 ); printLn ( toString ( randUInt64 )); // var randInt8 = rand(0u8, 1000u8); // printLn(toString(randInt8)); var randInt16 = rand ( 0 i16 , 1000 i16 ); printLn ( toString ( randInt16 )); var randInt32 = rand ( 0 i32 , 1000 i32 ); printLn ( toString ( randInt32 )); var randInt64 = rand ( 0 i64 , 1000 i64 ); printLn ( toString ( randInt64 )); var randFixed32 = rand ( 0.0f p32 , 1000.0f p32 ); printLn ( toString ( randFixed32 )); var randFixed64 = rand ( 0.0f p64 , 1000.0f p64 ); printLn ( toString ( randFixed64 )); endfunction Square root The square root of a number is found with the sqrt() function. The square root function is limited to fixed point variables. function main () var a = 4.0f p32 ; var b = 49.0f p64 ; var c = 49.0f p128 ; printLn ( toString ( sqrt ( a ))); printLn ( toString ( sqrt ( b ))); printLn ( toString ( sqrt ( c ))); endfunction Special cases Scenario Result x is NaN sqrt(NaN) = NaN x == 1 sqrt(x) = 1 x == 0 sqrt(x) = 0 x < 0 sqrt(x) = NaN x == +inf sqrt(+inf) = +inf Errors for x \u2208 (0, 5) Fixed32 : average: 0.000863796 , max: 0.00368993 Fixed64 : average: 3.71316e-10 , max: 1.56033e-09 Trigonometry Sin , Cos , and Tan function main () var x = 1.0f p64 ; printLn ( \"sin of 1\" ); printLn ( toString ( sin ( x ))); x = 0.5f p64 ; printLn ( \"sin of 0.5\" ); printLn ( toString ( sin ( x ))); x = 0.0f p64 ; printLn ( \"sin of 0\" ); printLn ( toString ( sin ( x ))); x = 1.0f p64 ; printLn ( \"cos of 1\" ); printLn ( toString ( cos ( x ))); x = 0.5f p64 ; printLn ( \"cos of 0.5\" ); printLn ( toString ( cos ( x ))); x = 0.0f p64 ; printLn ( \"cos of 0\" ); printLn ( toString ( cos ( x ))); x = 1.0f p64 ; printLn ( \"tan of 1\" ); printLn ( toString ( tan ( x ))); x = 0.5f p64 ; printLn ( \"tan of 0.5\" ); printLn ( toString ( tan ( x ))); x = 0.0f p64 ; printLn ( \"tan of 0\" ); printLn ( toString ( tan ( x ))); endfunction Sin special cases Scenario Result x is NaN sin(x) = NaN x is +/-inf sin(x) = NaN x == 0 sin(x) = 0 x < 0 sin(x) = -sin(-x) Errors for x \u2208 (-100 _ Pi /2, 100 _ Pi /2) Fixed32 : average: 0.000552292 , max: 0.108399 Fixed64 : average: 4.52891e-09 , max: 1.38022e-06 Cos special cases Scenario Result x is NaN cos(x) = NaN x == +/-inf cos(x) = NaN x == 0 cos(x) = 1 Errors for x \u2208 (-100 _ Pi /2, 100 _ Pi /2) Fixed32 : average: 0.000552292 , max: 0.108399 Fixed64 : average: 4.52891e-09 , max: 1.38022e-06 Tan special cases Scenario Result x is NaN tan(NaN) = NaN x == 1 tan(x) = 1 x == 0 tan(x) = 0 x < 0 tan(x) = NaN x == +inf tan(+inf) = +inf Errors for x \u2208 (-Pi/2 + 0.01, Pi/2 - 0.01) Fixed32 : average: 0.000552292 , max: 0.108399 Fixed32 : average: 4.52891e-09 , max: 1.38022e-06 ArcSin , ArcCos , and ArcTan function main () var x = 1.0f p64 ; printLn ( \"asin of 1\" ); printLn ( toString ( asin ( x ))); x = 0.5f p64 ; printLn ( \"asin of 0.5\" ); printLn ( toString ( asin ( x ))); x = 0.0f p64 ; printLn ( \"asin of 0\" ); printLn ( toString ( asin ( x ))); x = 1.0f p64 ; printLn ( \"acos of 1\" ); printLn ( toString ( acos ( x ))); x = 0.5f p64 ; printLn ( \"acos of 0.5\" ); printLn ( toString ( acos ( x ))); x = 0.0f p64 ; printLn ( \"acos of 0\" ); printLn ( toString ( acos ( x ))); x = 1.0f p64 ; printLn ( \"atan of 1\" ); printLn ( toString ( atan ( x ))); x = 0.5f p64 ; printLn ( \"atan of 0.5\" ); printLn ( toString ( atan ( x ))); x = 0.0f p64 ; printLn ( \"atan of 0\" ); printLn ( toString ( atan ( x ))); endfunction ASin special cases Scenario Result x is NaN asin(x) = NaN x is +/-inf asin(x) = NaN |x| > 1 asin(x) = NaN x < 0 asin(x) = -asin(-x) Errors for x \u2208 (-1, 1) Fixed32 : average: 1.76928e-05 , max: 0.000294807 Fixed64 : average: 2.62396e-10 , max: 1.87484e-09 ACos special cases Scenario Result x is NaN acos(x) = NaN x is +/-inf acos(x) = NaN |x| > 1 acos(x) = NaN Errors for x \u2208 (-1, 1) Fixed32 : average: 1.94115e-05 , max: 0.000305612 Fixed64 : average: 2.65666e-10 , max: 1.78974e-09 ATan special cases Scenario Result x is NaN atan(x) = NaN x is +/-inf atan(x) = +/- Pi/2 x < 0 atan(x) = -atan(-x) x > 1 atan(x) = Pi/2 - Atan(1/x) Errors for x \u2208 (-5, 5) Fixed32 : average: 9.41805e-06 , max: 3.11978e-05 Fixed64 : average: 9.69576e-10 , max: 2.84322e-08 Hyperbolic Sin , Cos , and Tan function main () var x = 1.0f p64 ; printLn ( \"sinh of 1\" ); printLn ( toString ( sinh ( x ))); x = 0.5f p64 ; printLn ( \"sinh of 0.5\" ); printLn ( toString ( sinh ( x ))); x = 0.0f p64 ; printLn ( \"sinh of 0\" ); printLn ( toString ( sinh ( x ))); x = 1.0f p64 ; printLn ( \"cosh of 1\" ); printLn ( toString ( cosh ( x ))); x = 0.5f p64 ; printLn ( \"cosh of 0.5\" ); printLn ( toString ( cosh ( x ))); x = 0.0f p64 ; printLn ( \"cosh of 0\" ); printLn ( toString ( cosh ( x ))); x = 1.0f p64 ; printLn ( \"tanh of 1\" ); printLn ( toString ( tanh ( x ))); x = 0.5f p64 ; printLn ( \"tanh of 0.5\" ); printLn ( toString ( tanh ( x ))); x = 0.0f p64 ; printLn ( \"tanh of 0\" ); printLn ( toString ( tanh ( x ))); endfunction Warn The sinh() implementation depends on exp() so the range is limited. The implementation is as follows: `sinh(x) = (e^x - e^(-x)) / 2` SinH special cases Scenario Result x is NaN sinh(x) = NaN x is +/-inf sinh(x) = +/-inf Errors for x \u2208 (-5, 5) Fixed32 : average: 6.63577e-05 , max: 0.000479903 Fixed64 : average: 7.39076e-09 , max: 7.90546e-08 CosH special cases Scenario Result x is NaN cosh(x) = NaN x is +/-inf cosh(x) = +inf Warn The cosh() implementation depends on exp() so the range is limited. The implementation is as follows: `cosh(x) = (e^x + e^(-x)) / 2` Errors for x \u2208 (-5, 5) Fixed32 : average: 6.92127e-05 , max: 0.000487532 Fixed64 : average: 7.30786e-09 , max: 7.89509e-08 TanH special cases Scenario Result x is NaN tanh(x) = NaN x is +/-inf tanh(x) = +/-1 Warn The tanh() implementation depends on exp() so the range is limited. The implementation is as follows: `tanh(x) = (e^x - e^(-x)) / (e^x + e^(-x))` Errors for x \u2208 (-3, 3) Fixed32 : average: 1.25046e-05 , max: 7.0897e-05 Fixed64 : average: 1.7648e-10 , max: 1.19186e-09 Hyperbolic ArcSin , ArcCos , and ArcTan function main () var x = 1.0f p64 ; printLn ( \"asinh of 1\" ); printLn ( toString ( asinh ( x ))); x = 0.5f p64 ; printLn ( \"asinh of 0.5\" ); printLn ( toString ( asinh ( x ))); x = 0.0f p64 ; printLn ( \"asinh of 0\" ); printLn ( toString ( asinh ( x ))); x = 1.0f p64 ; printLn ( \"acosh of 1\" ); printLn ( toString ( acosh ( x ))); x = 0.5f p64 ; printLn ( \"acosh of 0.5\" ); printLn ( toString ( acosh ( x ))); x = 0.0f p64 ; printLn ( \"acosh of 0\" ); printLn ( toString ( acosh ( x ))); x = 1.0f p64 ; printLn ( \"atanh of 1\" ); printLn ( toString ( atanh ( x ))); x = 0.5f p64 ; printLn ( \"atanh of 0.5\" ); printLn ( toString ( atanh ( x ))); x = 0.0f p64 ; printLn ( \"atanh of 0\" ); printLn ( toString ( atanh ( x ))); endfunction ArcSin special cases Scenario Result x is NaN asinh(x) = NaN x is +/-inf asinh(x) = +/-inf Errors for x \u2208 (-3, 3) Fixed32 : average: 5.59257e-05 , max: 0.00063489 Fixed64 : average: 3.49254e-09 , max: 2.62839e-08 ArcCos special cases Scenario Result x is NaN acosh(x) = NaN x is +inf acosh(x) = +inf x < 1 acosh(x) = NaN Errors for x \u2208 (1, 3) Fixed32 : average: 8.53834e-06 , max: 6.62567e-05 Errors for x \u2208 (1, 5) Fixed64 : average: 2.37609e-09 , max: 2.28507e-08 ArcTan special cases Scenario Result x is NaN atanh(x) = NaN x is +/-inf atanh(x) = NaN Errors for x \u2208 (-1, 1) Fixed32 : average: 2.08502e-05 , max: 0.000954267 Fixed64 : average: 1.47673e-09 , max: 1.98984e-07","title":"Maths functions"},{"location":"ledger/etch-language/maths-functions/#absolute-value","text":"abs() returns the absolute value of all signed integer types. function main () // 8 bit signed integers var int_8_bit = 1 i8 ; printLn ( toString ( abs ( int_8_bit ))); var neg_int_8_bit = - 1 i8 ; printLn ( toString ( abs ( neg_int_8_bit ))); // 16 bit signed integers var int_16_bit = 1 i16 ; printLn ( toString ( abs ( int_8_bit ))); var neg_int_16_bit = - 1 i16 ; printLn ( toString ( abs ( neg_int_16_bit ))); // 32 bit signed integers var int_32_bit = 1 ; printLn ( toString ( abs ( int_32_bit ))); var neg_int_32_bit = - 1 ; printLn ( toString ( abs ( neg_int_32_bit ))); // 64 bit signed integers var int_64_bit = 1 i64 ; printLn ( toString ( abs ( int_64_bit ))); var neg_int_64_bit = - 1 i64 ; printLn ( toString ( abs ( neg_int_64_bit ))); endfunction And positive unsigned integer types. function main () // 8 bit unsigned integers var int_8_bit = 1u8 ; printLn ( toString ( abs ( int_8_bit ))); // 16 bit unsigned integers var int_16_bit = 1u16 ; printLn ( toString ( abs ( int_8_bit ))); // 32 bit unsigned integers var int_32_bit = 1u32 ; printLn ( toString ( abs ( int_32_bit ))); // 64 bit unsigned integers var int_64_bit = 1u64 ; printLn ( toString ( abs ( int_64_bit ))); endfunction And fixed point types. function main () // 32 bit fixed point var fixed_32 = 1.0f p32 ; printLn ( toString ( abs ( fixed_32 ))); var neg_fixed_32 = - 1.0f p32 ; printLn ( toString ( abs ( neg_fixed_32 ))); // 64 bit fixed point var fixed_64 = 1.0f p64 ; printLn ( toString ( abs ( fixed_64 ))); var neg_fixed_64 = - 1.0f p64 ; printLn ( toString ( abs ( neg_fixed_64 ))); // 128 bit fixed point var fixed_128 = 1.0f p128 ; printLn ( toString ( abs ( fixed_128 ))); var neg_fixed_128 = - 1.0f p128 ; printLn ( toString ( abs ( neg_fixed_128 ))); endfunction","title":"Absolute value"},{"location":"ledger/etch-language/maths-functions/#exponential-function","text":"The exponential function returns the value of e to the number given, exp(x) = e x where e is Euler's base of natural logarithms. The exponential function is limited to fixed point variables. function main () var a = 2.0f p32 ; var b = 3.0f p64 ; var c = 4.0f p128 ; printLn ( toString ( exp ( a ))); printLn ( toString ( exp ( b ))); printLn ( toString ( exp ( c ))); endfunction","title":"Exponential function"},{"location":"ledger/etch-language/maths-functions/#range-restrictions","text":"Fixed32 accuracy is limited within the range [-10.3974, 10.3974] . Fixed64 accuracy is limited within the range [-21.48756260, 21.48756260] . Fixed128 accuracy is limited within the range [-43.6682723752765511, 43.6682723752765511] . Running the exponential function on numbers outside of this range produces unexpected results. Warning If the implementation of a function depends on exp() then accuracy is limited within a range dependent on the implementation. Warning For Fixed point types, take extra care because, even though the type has a reduced range, it has an increased accuracy within that range.","title":"Range restrictions"},{"location":"ledger/etch-language/maths-functions/#special-cases","text":"Scenario Result x is NaN e^x = NaN x < MIN_EXP e^x = 0 x > MAX_EXP overflow_error exception x == 1 e^x = e x == 0 e^x = 1 x == -inf e^(-inf) = 0 x == +inf e^(+inf) = +inf x < 0 e^x = 1/e^(-x)","title":"Special cases"},{"location":"ledger/etch-language/maths-functions/#errors-for-x-10-5","text":"Fixed32 : average: 0.000178116 , max: 0.00584819 Fixed64 : average: 4.97318e-09 , max: 1.66689e-07","title":"Errors for x \u2208 (-10, 5)"},{"location":"ledger/etch-language/maths-functions/#power","text":"The power function returns the value of the first parameter raised to the second. The power function is limited to fixed point variables. function main () var a = 2.0f p64 ; var b = 3.0f p64 ; printLn ( toString ( pow ( a , b ))); var c = 4.0f p32 ; var d = 5.0f p32 ; printLn ( toString ( pow ( c , d ))); var e = 2.0f p128 ; var f = 3.0f p128 ; printLn ( toString ( pow ( e , f ))); endfunction Warn The pow() implementation depends on exp() so the range is limited. The implementation is as follows: `x^y = exp(y * log(x));`","title":"Power"},{"location":"ledger/etch-language/maths-functions/#special-cases_1","text":"Scenario Result x or y is NaN pow(x, y) = NaN x == 0 , y == 0 pow(x, y) = NaN x == 0 , y != 0 pow(x, y) = 0 x any , y == 0 pow(x, y) = 1 x < 0 , y non int pow(x, y) = NaN x +/-inf pow(x, y) = x < 0 , y int pow(x, y) = \\prod_1^y x","title":"Special cases"},{"location":"ledger/etch-language/maths-functions/#errors-for-x-0-100-y-0-105","text":"Fixed32 : average: 1.49365e-06 , max: 3.04673e-05 Fixed64 : average: 8.45537e-12 , max: 8.70098e-10","title":"Errors for x \u2208 (0, 100), y \u2208 (0, 10.5)"},{"location":"ledger/etch-language/maths-functions/#errors-for-x-10-10-y-4-4","text":"Fixed32 : average: 3.9093e-06 , max: 9.15527e-06 Fixed64 : average: 7.71863e-11 , max: 2.25216e-10","title":"Errors for x \u2208 (-10, 10), y \u2208 (-4, 4)"},{"location":"ledger/etch-language/maths-functions/#random-non-deterministic","text":"You can currently generate non-deterministic, random, signed and unsigned integers (not 8 bit types), and floats. The beginning value of the range must be less than the end value. function main () // var randUInt8 = rand ( 0u8 , 1000u8 ); // error: unable to find matching function for 'Rand' //printLn(toString(randUInt8)); // unpermitted range // var rand_test = rand(100u16, 0u16); // runtime error: Invalid argument: rand(a, b) must satisfy a < b var randUInt16 = rand ( 0u16 , 1000u16 ); printLn ( toString ( randUInt16 )); var randUInt32 = rand ( 0u32 , 1000u32 ); printLn ( toString ( randUInt32 )); var randUInt64 = rand ( 0u64 , 1000u64 ); printLn ( toString ( randUInt64 )); // var randInt8 = rand(0u8, 1000u8); // printLn(toString(randInt8)); var randInt16 = rand ( 0 i16 , 1000 i16 ); printLn ( toString ( randInt16 )); var randInt32 = rand ( 0 i32 , 1000 i32 ); printLn ( toString ( randInt32 )); var randInt64 = rand ( 0 i64 , 1000 i64 ); printLn ( toString ( randInt64 )); var randFixed32 = rand ( 0.0f p32 , 1000.0f p32 ); printLn ( toString ( randFixed32 )); var randFixed64 = rand ( 0.0f p64 , 1000.0f p64 ); printLn ( toString ( randFixed64 )); endfunction","title":"Random (non deterministic)"},{"location":"ledger/etch-language/maths-functions/#square-root","text":"The square root of a number is found with the sqrt() function. The square root function is limited to fixed point variables. function main () var a = 4.0f p32 ; var b = 49.0f p64 ; var c = 49.0f p128 ; printLn ( toString ( sqrt ( a ))); printLn ( toString ( sqrt ( b ))); printLn ( toString ( sqrt ( c ))); endfunction","title":"Square root"},{"location":"ledger/etch-language/maths-functions/#special-cases_2","text":"Scenario Result x is NaN sqrt(NaN) = NaN x == 1 sqrt(x) = 1 x == 0 sqrt(x) = 0 x < 0 sqrt(x) = NaN x == +inf sqrt(+inf) = +inf","title":"Special cases"},{"location":"ledger/etch-language/maths-functions/#errors-for-x-0-5","text":"Fixed32 : average: 0.000863796 , max: 0.00368993 Fixed64 : average: 3.71316e-10 , max: 1.56033e-09","title":"Errors for x \u2208 (0, 5)"},{"location":"ledger/etch-language/maths-functions/#trigonometry","text":"","title":"Trigonometry"},{"location":"ledger/etch-language/maths-functions/#sin-cos-and-tan","text":"function main () var x = 1.0f p64 ; printLn ( \"sin of 1\" ); printLn ( toString ( sin ( x ))); x = 0.5f p64 ; printLn ( \"sin of 0.5\" ); printLn ( toString ( sin ( x ))); x = 0.0f p64 ; printLn ( \"sin of 0\" ); printLn ( toString ( sin ( x ))); x = 1.0f p64 ; printLn ( \"cos of 1\" ); printLn ( toString ( cos ( x ))); x = 0.5f p64 ; printLn ( \"cos of 0.5\" ); printLn ( toString ( cos ( x ))); x = 0.0f p64 ; printLn ( \"cos of 0\" ); printLn ( toString ( cos ( x ))); x = 1.0f p64 ; printLn ( \"tan of 1\" ); printLn ( toString ( tan ( x ))); x = 0.5f p64 ; printLn ( \"tan of 0.5\" ); printLn ( toString ( tan ( x ))); x = 0.0f p64 ; printLn ( \"tan of 0\" ); printLn ( toString ( tan ( x ))); endfunction","title":"Sin, Cos, and Tan"},{"location":"ledger/etch-language/maths-functions/#sin-special-cases","text":"Scenario Result x is NaN sin(x) = NaN x is +/-inf sin(x) = NaN x == 0 sin(x) = 0 x < 0 sin(x) = -sin(-x)","title":"Sin special cases"},{"location":"ledger/etch-language/maths-functions/#errors-for-x-100-_-pi2-100-_-pi2","text":"Fixed32 : average: 0.000552292 , max: 0.108399 Fixed64 : average: 4.52891e-09 , max: 1.38022e-06","title":"Errors for x \u2208 (-100 _ Pi/2, 100 _ Pi/2)"},{"location":"ledger/etch-language/maths-functions/#cos-special-cases","text":"Scenario Result x is NaN cos(x) = NaN x == +/-inf cos(x) = NaN x == 0 cos(x) = 1","title":"Cos special cases"},{"location":"ledger/etch-language/maths-functions/#errors-for-x-100-_-pi2-100-_-pi2_1","text":"Fixed32 : average: 0.000552292 , max: 0.108399 Fixed64 : average: 4.52891e-09 , max: 1.38022e-06","title":"Errors for x \u2208 (-100 _ Pi/2, 100 _ Pi/2)"},{"location":"ledger/etch-language/maths-functions/#tan-special-cases","text":"Scenario Result x is NaN tan(NaN) = NaN x == 1 tan(x) = 1 x == 0 tan(x) = 0 x < 0 tan(x) = NaN x == +inf tan(+inf) = +inf","title":"Tan special cases"},{"location":"ledger/etch-language/maths-functions/#errors-for-x-pi2-001-pi2-001","text":"Fixed32 : average: 0.000552292 , max: 0.108399 Fixed32 : average: 4.52891e-09 , max: 1.38022e-06","title":"Errors for x \u2208 (-Pi/2 + 0.01, Pi/2 - 0.01)"},{"location":"ledger/etch-language/maths-functions/#arcsin-arccos-and-arctan","text":"function main () var x = 1.0f p64 ; printLn ( \"asin of 1\" ); printLn ( toString ( asin ( x ))); x = 0.5f p64 ; printLn ( \"asin of 0.5\" ); printLn ( toString ( asin ( x ))); x = 0.0f p64 ; printLn ( \"asin of 0\" ); printLn ( toString ( asin ( x ))); x = 1.0f p64 ; printLn ( \"acos of 1\" ); printLn ( toString ( acos ( x ))); x = 0.5f p64 ; printLn ( \"acos of 0.5\" ); printLn ( toString ( acos ( x ))); x = 0.0f p64 ; printLn ( \"acos of 0\" ); printLn ( toString ( acos ( x ))); x = 1.0f p64 ; printLn ( \"atan of 1\" ); printLn ( toString ( atan ( x ))); x = 0.5f p64 ; printLn ( \"atan of 0.5\" ); printLn ( toString ( atan ( x ))); x = 0.0f p64 ; printLn ( \"atan of 0\" ); printLn ( toString ( atan ( x ))); endfunction","title":"ArcSin, ArcCos, and ArcTan"},{"location":"ledger/etch-language/maths-functions/#asin-special-cases","text":"Scenario Result x is NaN asin(x) = NaN x is +/-inf asin(x) = NaN |x| > 1 asin(x) = NaN x < 0 asin(x) = -asin(-x)","title":"ASin special cases"},{"location":"ledger/etch-language/maths-functions/#errors-for-x-1-1","text":"Fixed32 : average: 1.76928e-05 , max: 0.000294807 Fixed64 : average: 2.62396e-10 , max: 1.87484e-09","title":"Errors for x \u2208 (-1, 1)"},{"location":"ledger/etch-language/maths-functions/#acos-special-cases","text":"Scenario Result x is NaN acos(x) = NaN x is +/-inf acos(x) = NaN |x| > 1 acos(x) = NaN","title":"ACos special cases"},{"location":"ledger/etch-language/maths-functions/#errors-for-x-1-1_1","text":"Fixed32 : average: 1.94115e-05 , max: 0.000305612 Fixed64 : average: 2.65666e-10 , max: 1.78974e-09","title":"Errors for x \u2208 (-1, 1)"},{"location":"ledger/etch-language/maths-functions/#atan-special-cases","text":"Scenario Result x is NaN atan(x) = NaN x is +/-inf atan(x) = +/- Pi/2 x < 0 atan(x) = -atan(-x) x > 1 atan(x) = Pi/2 - Atan(1/x)","title":"ATan special cases"},{"location":"ledger/etch-language/maths-functions/#errors-for-x-5-5","text":"Fixed32 : average: 9.41805e-06 , max: 3.11978e-05 Fixed64 : average: 9.69576e-10 , max: 2.84322e-08","title":"Errors for x \u2208 (-5, 5)"},{"location":"ledger/etch-language/maths-functions/#hyperbolic-sin-cos-and-tan","text":"function main () var x = 1.0f p64 ; printLn ( \"sinh of 1\" ); printLn ( toString ( sinh ( x ))); x = 0.5f p64 ; printLn ( \"sinh of 0.5\" ); printLn ( toString ( sinh ( x ))); x = 0.0f p64 ; printLn ( \"sinh of 0\" ); printLn ( toString ( sinh ( x ))); x = 1.0f p64 ; printLn ( \"cosh of 1\" ); printLn ( toString ( cosh ( x ))); x = 0.5f p64 ; printLn ( \"cosh of 0.5\" ); printLn ( toString ( cosh ( x ))); x = 0.0f p64 ; printLn ( \"cosh of 0\" ); printLn ( toString ( cosh ( x ))); x = 1.0f p64 ; printLn ( \"tanh of 1\" ); printLn ( toString ( tanh ( x ))); x = 0.5f p64 ; printLn ( \"tanh of 0.5\" ); printLn ( toString ( tanh ( x ))); x = 0.0f p64 ; printLn ( \"tanh of 0\" ); printLn ( toString ( tanh ( x ))); endfunction Warn The sinh() implementation depends on exp() so the range is limited. The implementation is as follows: `sinh(x) = (e^x - e^(-x)) / 2`","title":"Hyperbolic Sin, Cos, and Tan"},{"location":"ledger/etch-language/maths-functions/#sinh-special-cases","text":"Scenario Result x is NaN sinh(x) = NaN x is +/-inf sinh(x) = +/-inf","title":"SinH special cases"},{"location":"ledger/etch-language/maths-functions/#errors-for-x-5-5_1","text":"Fixed32 : average: 6.63577e-05 , max: 0.000479903 Fixed64 : average: 7.39076e-09 , max: 7.90546e-08","title":"Errors for x \u2208 (-5, 5)"},{"location":"ledger/etch-language/maths-functions/#cosh-special-cases","text":"Scenario Result x is NaN cosh(x) = NaN x is +/-inf cosh(x) = +inf Warn The cosh() implementation depends on exp() so the range is limited. The implementation is as follows: `cosh(x) = (e^x + e^(-x)) / 2`","title":"CosH special cases"},{"location":"ledger/etch-language/maths-functions/#errors-for-x-5-5_2","text":"Fixed32 : average: 6.92127e-05 , max: 0.000487532 Fixed64 : average: 7.30786e-09 , max: 7.89509e-08","title":"Errors for x \u2208 (-5, 5)"},{"location":"ledger/etch-language/maths-functions/#tanh-special-cases","text":"Scenario Result x is NaN tanh(x) = NaN x is +/-inf tanh(x) = +/-1 Warn The tanh() implementation depends on exp() so the range is limited. The implementation is as follows: `tanh(x) = (e^x - e^(-x)) / (e^x + e^(-x))`","title":"TanH special cases"},{"location":"ledger/etch-language/maths-functions/#errors-for-x-3-3","text":"Fixed32 : average: 1.25046e-05 , max: 7.0897e-05 Fixed64 : average: 1.7648e-10 , max: 1.19186e-09","title":"Errors for x \u2208 (-3, 3)"},{"location":"ledger/etch-language/maths-functions/#hyperbolic-arcsin-arccos-and-arctan","text":"function main () var x = 1.0f p64 ; printLn ( \"asinh of 1\" ); printLn ( toString ( asinh ( x ))); x = 0.5f p64 ; printLn ( \"asinh of 0.5\" ); printLn ( toString ( asinh ( x ))); x = 0.0f p64 ; printLn ( \"asinh of 0\" ); printLn ( toString ( asinh ( x ))); x = 1.0f p64 ; printLn ( \"acosh of 1\" ); printLn ( toString ( acosh ( x ))); x = 0.5f p64 ; printLn ( \"acosh of 0.5\" ); printLn ( toString ( acosh ( x ))); x = 0.0f p64 ; printLn ( \"acosh of 0\" ); printLn ( toString ( acosh ( x ))); x = 1.0f p64 ; printLn ( \"atanh of 1\" ); printLn ( toString ( atanh ( x ))); x = 0.5f p64 ; printLn ( \"atanh of 0.5\" ); printLn ( toString ( atanh ( x ))); x = 0.0f p64 ; printLn ( \"atanh of 0\" ); printLn ( toString ( atanh ( x ))); endfunction","title":"Hyperbolic ArcSin, ArcCos, and ArcTan"},{"location":"ledger/etch-language/maths-functions/#arcsin-special-cases","text":"Scenario Result x is NaN asinh(x) = NaN x is +/-inf asinh(x) = +/-inf","title":"ArcSin special cases"},{"location":"ledger/etch-language/maths-functions/#errors-for-x-3-3_1","text":"Fixed32 : average: 5.59257e-05 , max: 0.00063489 Fixed64 : average: 3.49254e-09 , max: 2.62839e-08","title":"Errors for x \u2208 (-3, 3)"},{"location":"ledger/etch-language/maths-functions/#arccos-special-cases","text":"Scenario Result x is NaN acosh(x) = NaN x is +inf acosh(x) = +inf x < 1 acosh(x) = NaN","title":"ArcCos special cases"},{"location":"ledger/etch-language/maths-functions/#errors-for-x-1-3","text":"Fixed32 : average: 8.53834e-06 , max: 6.62567e-05","title":"Errors for x \u2208 (1, 3)"},{"location":"ledger/etch-language/maths-functions/#errors-for-x-1-5","text":"Fixed64 : average: 2.37609e-09 , max: 2.28507e-08","title":"Errors for x \u2208 (1, 5)"},{"location":"ledger/etch-language/maths-functions/#arctan-special-cases","text":"Scenario Result x is NaN atanh(x) = NaN x is +/-inf atanh(x) = NaN","title":"ArcTan special cases"},{"location":"ledger/etch-language/maths-functions/#errors-for-x-1-1_2","text":"Fixed32 : average: 2.08502e-05 , max: 0.000954267 Fixed64 : average: 1.47673e-09 , max: 1.98984e-07","title":"Errors for x \u2208 (-1, 1)"},{"location":"ledger/etch-language/model/","text":"A Model is the simplest way to build, train, and evaluate neural networks in etch . The Model type takes care of the underlying implementation details for Graph , DataLoader , and Optimiser . There are three types of Model . Sequential : trains a computational graph to predict either continuous variables or classes, and allows more control over the layers of the network. Regressor : trains a computational graph to predict continuous variables. For example, what will be the future price of a particular currency? Classifier : trains a computational graph to predict classes. For example, is this a picture of a cat or a dog? Construct a Model Create a Model by setting a flag in the constructor. function main () var model1 = Model ( \"sequential\" ); var model2 = Model ( \"regressor\" ); var model3 = Model ( \"classifier\" ); endfunction Add Manually add the layers to a sequential Model . The function add(x, y, z, a) with four parameters requires you specify a flag type, the dimensions, and the activation type. The function add(x, y, z) with three parameters requires you specify a flag type and the dimensions. function main () var model = Model ( \"sequential\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); endfunction Compile Compile the Model with the compile() function. The function compile(loss-function-flag, optimiser-flag) takes two inputs. In the below example, we compiled with a mean squared error loss function and an Adam Optimiser . function main () var model = Model ( \"sequential\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); endfunction Read in input data The readCSV(System.Argv(1)) function allows you to read in data from csv files with the etch compiler argument commands. For example, run the below script with the following command. The first if-else block ensure the correct number of arguments with System.Argc() . ./etch -- file1 file2 file3 file4 function main () if ( System . Argc () != 5 ) print ( \"Usage: SCRIPT_FILE -- PATH/TO/BOSTON_TRAIN_DATA.CSV PATH/TO/BOSTON_TRAIN_LABELS.CSV PATH/TO/BOSTON_TEST_DATA.CSV PATH/TO/BOSTON_TEST_LABELS.CSV \" ); return ; endif var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); endfunction Fit With the Model set up as above, you can now add the input data and run the training function fit(data, labels, batch-size) . function main () var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); endfunction Evaluate Evaluate the prediction error with the evaluate() function. function main () var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); var loss = model . evaluate (); printLn ( loss ); endfunction Predict Finally, make predictions on the data function main () var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); var loss = model . evaluate (); printLn ( loss ); var predictions = model . predict ( test_data ); print ( predictions . at ( 0u64 , 0u64 )); endfunction","title":"Model"},{"location":"ledger/etch-language/model/#construct-a-model","text":"Create a Model by setting a flag in the constructor. function main () var model1 = Model ( \"sequential\" ); var model2 = Model ( \"regressor\" ); var model3 = Model ( \"classifier\" ); endfunction","title":"Construct a Model"},{"location":"ledger/etch-language/model/#add","text":"Manually add the layers to a sequential Model . The function add(x, y, z, a) with four parameters requires you specify a flag type, the dimensions, and the activation type. The function add(x, y, z) with three parameters requires you specify a flag type and the dimensions. function main () var model = Model ( \"sequential\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); endfunction","title":"Add"},{"location":"ledger/etch-language/model/#compile","text":"Compile the Model with the compile() function. The function compile(loss-function-flag, optimiser-flag) takes two inputs. In the below example, we compiled with a mean squared error loss function and an Adam Optimiser . function main () var model = Model ( \"sequential\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); endfunction","title":"Compile"},{"location":"ledger/etch-language/model/#read-in-input-data","text":"The readCSV(System.Argv(1)) function allows you to read in data from csv files with the etch compiler argument commands. For example, run the below script with the following command. The first if-else block ensure the correct number of arguments with System.Argc() . ./etch -- file1 file2 file3 file4 function main () if ( System . Argc () != 5 ) print ( \"Usage: SCRIPT_FILE -- PATH/TO/BOSTON_TRAIN_DATA.CSV PATH/TO/BOSTON_TRAIN_LABELS.CSV PATH/TO/BOSTON_TEST_DATA.CSV PATH/TO/BOSTON_TEST_LABELS.CSV \" ); return ; endif var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); endfunction","title":"Read in input data"},{"location":"ledger/etch-language/model/#fit","text":"With the Model set up as above, you can now add the input data and run the training function fit(data, labels, batch-size) . function main () var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); endfunction","title":"Fit"},{"location":"ledger/etch-language/model/#evaluate","text":"Evaluate the prediction error with the evaluate() function. function main () var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); var loss = model . evaluate (); printLn ( loss ); endfunction","title":"Evaluate"},{"location":"ledger/etch-language/model/#predict","text":"Finally, make predictions on the data function main () var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); var loss = model . evaluate (); printLn ( loss ); var predictions = model . predict ( test_data ); print ( predictions . at ( 0u64 , 0u64 )); endfunction","title":"Predict"},{"location":"ledger/etch-language/operators/","text":"Operators + += == != ( ) && - -= || < < = [ ] * *= > >= / /= ++ = : , % %= -- ! . Minus function main () var plus = 42 ; var minus = - 42 ; printLn ( toString ( plus )); printLn ( toString ( minus )); var plusminused = - plus ; printLn ( toString ( plusminused )); endfunction Increment function main () var int32bit : Int32 = 42 ; int32bit ++ ; printLn ( toString ( int32bit )); ++ int32bit ; printLn ( toString ( int32bit )); endfunction Decrement function main () var int32bit : Int32 = 42 ; int32bit -- ; printLn ( toString ( int32bit )); -- int32bit ; printLn ( toString ( int32bit )); endfunction Addition function main () var x = 42 ; var y = 66 ; var z = x + y ; printLn ( toString ( z )); z += 2 ; printLn ( toString ( z )); endfunction Subtraction function main () var x = 42 ; var y = 66 ; var z = y - x ; printLn ( toString ( z )); z -= 2 ; printLn ( toString ( z )); endfunction Multiplication function main () var x = 42 ; var y = 2 ; var z = y * x ; printLn ( toString ( z )); z *= 2 ; printLn ( toString ( z )); endfunction Division Integer division returns a rounded down integer value. function main () var x = 41 ; var y = 7 ; var z = x / y ; printLn ( toString ( z )); z /= 2 ; printLn ( toString ( z )); var a = 32.3f p64 ; var b = 31.2f p64 ; var c = a / b ; printLn ( toString ( c )); endfunction Modulus function main () var x = 7 ; var y = 6 ; var z = x % y ; printLn ( toString ( z )); z %= 2 ; printLn ( toString ( z )); endfunction Ternary Not currently supported. Precedence 1. x ++ x -- subscript [] . 2. ++ x -- x ( + x ) - x ! toType 3. * / % 4. + - 5. < <= > >= 6. == != 7. && 8. || 9. = += -= *= /= 10. ,","title":"Operators"},{"location":"ledger/etch-language/operators/#minus","text":"function main () var plus = 42 ; var minus = - 42 ; printLn ( toString ( plus )); printLn ( toString ( minus )); var plusminused = - plus ; printLn ( toString ( plusminused )); endfunction","title":"Minus"},{"location":"ledger/etch-language/operators/#increment","text":"function main () var int32bit : Int32 = 42 ; int32bit ++ ; printLn ( toString ( int32bit )); ++ int32bit ; printLn ( toString ( int32bit )); endfunction","title":"Increment"},{"location":"ledger/etch-language/operators/#decrement","text":"function main () var int32bit : Int32 = 42 ; int32bit -- ; printLn ( toString ( int32bit )); -- int32bit ; printLn ( toString ( int32bit )); endfunction","title":"Decrement"},{"location":"ledger/etch-language/operators/#addition","text":"function main () var x = 42 ; var y = 66 ; var z = x + y ; printLn ( toString ( z )); z += 2 ; printLn ( toString ( z )); endfunction","title":"Addition"},{"location":"ledger/etch-language/operators/#subtraction","text":"function main () var x = 42 ; var y = 66 ; var z = y - x ; printLn ( toString ( z )); z -= 2 ; printLn ( toString ( z )); endfunction","title":"Subtraction"},{"location":"ledger/etch-language/operators/#multiplication","text":"function main () var x = 42 ; var y = 2 ; var z = y * x ; printLn ( toString ( z )); z *= 2 ; printLn ( toString ( z )); endfunction","title":"Multiplication"},{"location":"ledger/etch-language/operators/#division","text":"Integer division returns a rounded down integer value. function main () var x = 41 ; var y = 7 ; var z = x / y ; printLn ( toString ( z )); z /= 2 ; printLn ( toString ( z )); var a = 32.3f p64 ; var b = 31.2f p64 ; var c = a / b ; printLn ( toString ( c )); endfunction","title":"Division"},{"location":"ledger/etch-language/operators/#modulus","text":"function main () var x = 7 ; var y = 6 ; var z = x % y ; printLn ( toString ( z )); z %= 2 ; printLn ( toString ( z )); endfunction","title":"Modulus"},{"location":"ledger/etch-language/operators/#ternary","text":"Not currently supported.","title":"Ternary"},{"location":"ledger/etch-language/operators/#precedence","text":"1. x ++ x -- subscript [] . 2. ++ x -- x ( + x ) - x ! toType 3. * / % 4. + - 5. < <= > >= 6. == != 7. && 8. || 9. = += -= *= /= 10. ,","title":"Precedence"},{"location":"ledger/etch-language/optimiser/","text":"Use an Optimiser to run the machine learning training on a Graph and a DataLoader . Declare and initialise an Optimiser , giving it the name of the optimisation algorithm you wish to run, the Graph and the DataLoader objects, and the place-holder nodes for the input data, training data, and error data. var optimiser = Optimiser ( \"sgd\" , graph , dataloader , { \"Input1\" , \"Input2\" , ...}, \"Label\" , \"Error\" ); To run the Optimiser , call run() with a batch size. Batch size sets the number of samples to train on in an epoch. var loss = optimiser . run ( batch_size ); Adagrad \"adagrad\" implements the Adagrad optimiser . function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 20u64 ; data_shape [ 1 ] = 4000u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 1u64 ; label_shape [ 1 ] = 4000u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); data_tensor . fillRandom (); label_tensor . fillRandom (); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addFullyConnected ( \"Output\" , \"Input\" , 20 , 1 ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); var batch_size = 8u64 ; // train the data via an Adagrad Optimiser var optimiser = Optimiser ( \"adagrad\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); endfunction Adam \"adam\" implements the Adam optimiser . // ... // train the data via an Adam Optimiser var optimiser = Optimiser ( \"adam\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); // ... Momentum \"momentum\" implements the Momentum optimiser . // ... // train the data via a Momentum Optimiser var optimiser = Optimiser ( \"momentum\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); // ... RMSprop \"rmsprop\" implements the RMSprop optimiser . // ... // train the data via an RMSprop Optimiser var optimiser = Optimiser ( \"rmsprop\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); // ... SGD \"sgd\" implements the SGD optimiser . // ... // train the data via an SGD Optimiser var optimiser = Optimiser ( \"sgd\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); // ... Full optimisation example Run the collection of Optimiser consecutively and check that error reduction is consistent. function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 20u64 ; data_shape [ 1 ] = 4000u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 1u64 ; label_shape [ 1 ] = 4000u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); data_tensor . fillRandom (); label_tensor . fillRandom (); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addFullyConnected ( \"Output\" , \"Input\" , 20 , 1 ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); var batch_size = 8u64 ; // test that every optimiser can be constructed and that running reduces loss var optimiser1 = Optimiser ( \"adagrad\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser1 . run ( batch_size ); var optimiser2 = Optimiser ( \"adam\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss2 = optimiser2 . run ( batch_size ); assert ( loss2 < loss ); var optimiser3 = Optimiser ( \"momentum\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); loss = optimiser3 . run ( batch_size ); assert ( loss < loss2 ); var optimiser4 = Optimiser ( \"rmsprop\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); loss2 = optimiser4 . run ( batch_size ); assert ( loss2 < loss ); var optimiser5 = Optimiser ( \"sgd\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); loss = optimiser5 . run ( batch_size ); assert ( loss < loss2 ); loss2 = optimiser1 . run ( batch_size ); assert ( loss2 < loss ); endfunction Reset Graph or DataLoader Reset the Graph or DataLoader into the Optimiser with the setGraph() and setDataLoader() functions. function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 20u64 ; data_shape [ 1 ] = 4000u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 1u64 ; label_shape [ 1 ] = 4000u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); data_tensor . fillRandom (); label_tensor . fillRandom (); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addFullyConnected ( \"Output\" , \"Input\" , 20 , 1 ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); var batch_size = 8u64 ; // test that every optimiser can be constructed and that running reduces loss var optimiser = Optimiser ( \"adagrad\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss1 = optimiser . run ( batch_size ); // build new Graph and DataLoader var graph2 = Graph (); graph2 . addPlaceholder ( \"Input\" ); graph2 . addPlaceholder ( \"Label\" ); graph2 . addFullyConnected ( \"Output\" , \"Input\" , 20 , 1 ); graph2 . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); var dataloader2 = DataLoader ( \"tensor\" ); data_tensor . fillRandom (); label_tensor . fillRandom (); dataloader2 . addData ( data_tensor , label_tensor ); // set new Graph and DataLoader into the Optimiser optimiser . setGraph ( graph2 ); optimiser . setDataloader ( dataloader2 ); var loss2 = optimiser . run ( batch_size ); // assert(loss2 < loss1); endfunction","title":"Optimiser"},{"location":"ledger/etch-language/optimiser/#adagrad","text":"\"adagrad\" implements the Adagrad optimiser . function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 20u64 ; data_shape [ 1 ] = 4000u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 1u64 ; label_shape [ 1 ] = 4000u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); data_tensor . fillRandom (); label_tensor . fillRandom (); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addFullyConnected ( \"Output\" , \"Input\" , 20 , 1 ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); var batch_size = 8u64 ; // train the data via an Adagrad Optimiser var optimiser = Optimiser ( \"adagrad\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); endfunction","title":"Adagrad"},{"location":"ledger/etch-language/optimiser/#adam","text":"\"adam\" implements the Adam optimiser . // ... // train the data via an Adam Optimiser var optimiser = Optimiser ( \"adam\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); // ...","title":"Adam"},{"location":"ledger/etch-language/optimiser/#momentum","text":"\"momentum\" implements the Momentum optimiser . // ... // train the data via a Momentum Optimiser var optimiser = Optimiser ( \"momentum\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); // ...","title":"Momentum"},{"location":"ledger/etch-language/optimiser/#rmsprop","text":"\"rmsprop\" implements the RMSprop optimiser . // ... // train the data via an RMSprop Optimiser var optimiser = Optimiser ( \"rmsprop\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); // ...","title":"RMSprop"},{"location":"ledger/etch-language/optimiser/#sgd","text":"\"sgd\" implements the SGD optimiser . // ... // train the data via an SGD Optimiser var optimiser = Optimiser ( \"sgd\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser . run ( batch_size ); // ...","title":"SGD"},{"location":"ledger/etch-language/optimiser/#full-optimisation-example","text":"Run the collection of Optimiser consecutively and check that error reduction is consistent. function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 20u64 ; data_shape [ 1 ] = 4000u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 1u64 ; label_shape [ 1 ] = 4000u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); data_tensor . fillRandom (); label_tensor . fillRandom (); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addFullyConnected ( \"Output\" , \"Input\" , 20 , 1 ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); var batch_size = 8u64 ; // test that every optimiser can be constructed and that running reduces loss var optimiser1 = Optimiser ( \"adagrad\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss = optimiser1 . run ( batch_size ); var optimiser2 = Optimiser ( \"adam\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss2 = optimiser2 . run ( batch_size ); assert ( loss2 < loss ); var optimiser3 = Optimiser ( \"momentum\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); loss = optimiser3 . run ( batch_size ); assert ( loss < loss2 ); var optimiser4 = Optimiser ( \"rmsprop\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); loss2 = optimiser4 . run ( batch_size ); assert ( loss2 < loss ); var optimiser5 = Optimiser ( \"sgd\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); loss = optimiser5 . run ( batch_size ); assert ( loss < loss2 ); loss2 = optimiser1 . run ( batch_size ); assert ( loss2 < loss ); endfunction","title":"Full optimisation example"},{"location":"ledger/etch-language/optimiser/#reset-graph-or-dataloader","text":"Reset the Graph or DataLoader into the Optimiser with the setGraph() and setDataLoader() functions. function main () var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = 20u64 ; data_shape [ 1 ] = 4000u64 ; var label_shape = Array < UInt64 > ( 2 ); label_shape [ 0 ] = 1u64 ; label_shape [ 1 ] = 4000u64 ; var data_tensor = Tensor ( data_shape ); var label_tensor = Tensor ( label_shape ); data_tensor . fillRandom (); label_tensor . fillRandom (); var dataloader = DataLoader ( \"tensor\" ); dataloader . addData ( data_tensor , label_tensor ); var graph = Graph (); graph . addPlaceholder ( \"Input\" ); graph . addPlaceholder ( \"Label\" ); graph . addFullyConnected ( \"Output\" , \"Input\" , 20 , 1 ); graph . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); var batch_size = 8u64 ; // test that every optimiser can be constructed and that running reduces loss var optimiser = Optimiser ( \"adagrad\" , graph , dataloader , { \"Input\" }, \"Label\" , \"Error\" ); var loss1 = optimiser . run ( batch_size ); // build new Graph and DataLoader var graph2 = Graph (); graph2 . addPlaceholder ( \"Input\" ); graph2 . addPlaceholder ( \"Label\" ); graph2 . addFullyConnected ( \"Output\" , \"Input\" , 20 , 1 ); graph2 . addMeanSquareErrorLoss ( \"Error\" , \"Output\" , \"Label\" ); var dataloader2 = DataLoader ( \"tensor\" ); data_tensor . fillRandom (); label_tensor . fillRandom (); dataloader2 . addData ( data_tensor , label_tensor ); // set new Graph and DataLoader into the Optimiser optimiser . setGraph ( graph2 ); optimiser . setDataloader ( dataloader2 ); var loss2 = optimiser . run ( batch_size ); // assert(loss2 < loss1); endfunction","title":"Reset Graph or DataLoader"},{"location":"ledger/etch-language/persistent-globals/","text":"Persistent globals are succinct and ledger efficient persistent variable types that store data on the Fetch.ai Ledger. They are equivalent to State and ShardedState objects and are the primary mechanism for shard management. Five new keywords identify these types: persistent , sharded , use , as , and any . As etch evolves along with the Fetch.ai Ledger, persistent globals will help ensure maximum ledger storage efficiency. Recommendation Use the persistent global syntax instead of State and ShardedState syntax. Syntax Declare all persistent variables the smart contract may use at the top of the file before any function declarations. persistent Use the persistent keyword to reference global persistent State types available to the contract. persistent total : UInt32 ; // more persistent globals // smart contract functions... function main () // do stuff endfunction The above syntax references a State variable that previously could only be constructed as follows. function main () var total_state = State < UInt32 > ( \"str_ref\" ); var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var account_state = State < UInt256 > ( account ); endfunction Using the persistent global syntax, there is no way to reference the String or Address constructor parameter references as before. Note It is still possible to construct `State` types without persistent global declarations. sharded Use the persistent sharded keyword pair to declare global persistent ShardedState types available to the contract. persistent sharded balances : UInt64 ; // more persistent globals // smart contract functions... function main () // do stuff endfunction The above syntax references a ShardedState variable that previously could only be constructed as follows. function main () var balances_sharded_state = ShardedState < UInt64 > ( \"balances\" ); endfunction This means you cannot build a ShardedState referenced by a single String or Address as before. However, this limitation should promote a more economical use of the ledger. Note It is still possible to construct `ShardedState` types without persistent global declarations. use Import the global persistent variables into smart contract functions with the use keyword. State For State types, call get() and set() on the variable name as before. persistent total : UInt32 ; function main () // import a State type use total ; // call functions on the Fetch ledger types as before total . set ( 10u32 ); printLn ( total . get ()); endfunction ShardedState For ShardedState types, call get() and set() as before. persistent sharded balances : UInt64 ; function main () // import a ShardedState type with one key use balances [ \"balance1\" , \"balance2\" , \"balance3\" ]; // set a value on the keys balances . set ( \"balance1\" , 10u64 ); balances . set ( \"balance2\" , 20u64 ); balances . set ( \"balance3\" , 30u64 ); // print a value printLn ( toString ( balances . get ( \"balance2\" ))); endfunction However, note that setting keys on the ShardedState type happens at import time and there is no limit to the number of keys. Set and use keys on a persistent global ShardedState in a flexible manner as demonstrated by the following example. persistent sharded balances : UInt64 ; function main () use balances ; add_one_key (); add_two_more_keys (); printLn ( balances . get ( \"key_3\" )); endfunction function add_one_key () use balances [ \"key_1\" ]; balances . set ( \"key_1\" , 10u64 ); endfunction function add_two_more_keys () use balances [ \"key_2\" , \"key_3\" ]; balances . set ( \"key_2\" , 20u64 ); balances . set ( \"key_3\" , 30u64 ); endfunction Warning If you don't use a declared persistent global variable you have imported, etch generates a compilation error. This ensures maximum ledger efficiency (i.e. not paying for unused objects). as Alias the persistent global variable name to avoid confusion in large smart contract scripts. persistent total : UInt32 ; function main () use total as first_total ; first_total . set ( 0u32 ); second (); endfunction function second () use total as second_total ; second_total . set ( 20u32 ); endfunction any Warning Use any with great care. any does not require use of the variable within the function and it therefore has no safety mechanism for avoiding additional charges. Import all the declared persistent global variables with the wildcard keyword any . persistent total : UInt64 ; persistent sharded balances : UInt64 ; function main () use any ; total . set ( 100u64 ); balances . set ( \"balance_1\" , 100u64 ); endfunction Benefits Using persistent global syntax means that only one variable identifier can point to a single State or ShardedState object. The following unusual situation is not possible with persistent globals. function main () var a = State < Int32 > ( \"account1\" ); var b = State < Int32 > ( \"account1\" ); a . set ( 100 ); b . set ( - 10 ); printLn ( \"My state value = \" + toString ( a . get ())); var x = ShardedState < Int32 > ( \"account2\" ); var y = ShardedState < Int32 > ( \"account2\" ); x . set ( \"balance\" , 100 ); y . set ( \"balance\" , - 10 ); printLn ( \"My sharded state value = \" + toString ( x . get ( \"balance\" ))); endfunction Limitations You cannot pass persistent globals around. persistent total : UInt32 ; function main () use total as first_total ; first_total . set ( 0u32 ); second ( first_total ); endfunction function second ( passed_global : UInt32 ) // should error endfunction","title":"Persistent globals"},{"location":"ledger/etch-language/persistent-globals/#syntax","text":"Declare all persistent variables the smart contract may use at the top of the file before any function declarations.","title":"Syntax"},{"location":"ledger/etch-language/persistent-globals/#persistent","text":"Use the persistent keyword to reference global persistent State types available to the contract. persistent total : UInt32 ; // more persistent globals // smart contract functions... function main () // do stuff endfunction The above syntax references a State variable that previously could only be constructed as follows. function main () var total_state = State < UInt32 > ( \"str_ref\" ); var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var account_state = State < UInt256 > ( account ); endfunction Using the persistent global syntax, there is no way to reference the String or Address constructor parameter references as before. Note It is still possible to construct `State` types without persistent global declarations.","title":"persistent"},{"location":"ledger/etch-language/persistent-globals/#sharded","text":"Use the persistent sharded keyword pair to declare global persistent ShardedState types available to the contract. persistent sharded balances : UInt64 ; // more persistent globals // smart contract functions... function main () // do stuff endfunction The above syntax references a ShardedState variable that previously could only be constructed as follows. function main () var balances_sharded_state = ShardedState < UInt64 > ( \"balances\" ); endfunction This means you cannot build a ShardedState referenced by a single String or Address as before. However, this limitation should promote a more economical use of the ledger. Note It is still possible to construct `ShardedState` types without persistent global declarations.","title":"sharded"},{"location":"ledger/etch-language/persistent-globals/#use","text":"Import the global persistent variables into smart contract functions with the use keyword.","title":"use"},{"location":"ledger/etch-language/persistent-globals/#state","text":"For State types, call get() and set() on the variable name as before. persistent total : UInt32 ; function main () // import a State type use total ; // call functions on the Fetch ledger types as before total . set ( 10u32 ); printLn ( total . get ()); endfunction","title":"State"},{"location":"ledger/etch-language/persistent-globals/#shardedstate","text":"For ShardedState types, call get() and set() as before. persistent sharded balances : UInt64 ; function main () // import a ShardedState type with one key use balances [ \"balance1\" , \"balance2\" , \"balance3\" ]; // set a value on the keys balances . set ( \"balance1\" , 10u64 ); balances . set ( \"balance2\" , 20u64 ); balances . set ( \"balance3\" , 30u64 ); // print a value printLn ( toString ( balances . get ( \"balance2\" ))); endfunction However, note that setting keys on the ShardedState type happens at import time and there is no limit to the number of keys. Set and use keys on a persistent global ShardedState in a flexible manner as demonstrated by the following example. persistent sharded balances : UInt64 ; function main () use balances ; add_one_key (); add_two_more_keys (); printLn ( balances . get ( \"key_3\" )); endfunction function add_one_key () use balances [ \"key_1\" ]; balances . set ( \"key_1\" , 10u64 ); endfunction function add_two_more_keys () use balances [ \"key_2\" , \"key_3\" ]; balances . set ( \"key_2\" , 20u64 ); balances . set ( \"key_3\" , 30u64 ); endfunction Warning If you don't use a declared persistent global variable you have imported, etch generates a compilation error. This ensures maximum ledger efficiency (i.e. not paying for unused objects).","title":"ShardedState"},{"location":"ledger/etch-language/persistent-globals/#as","text":"Alias the persistent global variable name to avoid confusion in large smart contract scripts. persistent total : UInt32 ; function main () use total as first_total ; first_total . set ( 0u32 ); second (); endfunction function second () use total as second_total ; second_total . set ( 20u32 ); endfunction","title":"as"},{"location":"ledger/etch-language/persistent-globals/#any","text":"Warning Use any with great care. any does not require use of the variable within the function and it therefore has no safety mechanism for avoiding additional charges. Import all the declared persistent global variables with the wildcard keyword any . persistent total : UInt64 ; persistent sharded balances : UInt64 ; function main () use any ; total . set ( 100u64 ); balances . set ( \"balance_1\" , 100u64 ); endfunction","title":"any"},{"location":"ledger/etch-language/persistent-globals/#benefits","text":"Using persistent global syntax means that only one variable identifier can point to a single State or ShardedState object. The following unusual situation is not possible with persistent globals. function main () var a = State < Int32 > ( \"account1\" ); var b = State < Int32 > ( \"account1\" ); a . set ( 100 ); b . set ( - 10 ); printLn ( \"My state value = \" + toString ( a . get ())); var x = ShardedState < Int32 > ( \"account2\" ); var y = ShardedState < Int32 > ( \"account2\" ); x . set ( \"balance\" , 100 ); y . set ( \"balance\" , - 10 ); printLn ( \"My sharded state value = \" + toString ( x . get ( \"balance\" ))); endfunction","title":"Benefits"},{"location":"ledger/etch-language/persistent-globals/#limitations","text":"You cannot pass persistent globals around. persistent total : UInt32 ; function main () use total as first_total ; first_total . set ( 0u32 ); second ( first_total ); endfunction function second ( passed_global : UInt32 ) // should error endfunction","title":"Limitations"},{"location":"ledger/etch-language/regex/","text":"Regular expressions Note Coming soon: support for regular expressions.","title":"Regex"},{"location":"ledger/etch-language/release-notes/","text":"Version v0.9.x Significant changes in this version of the etch virtual machine include the following: Contract payable addresses. keras -style sequential Model now available for use in smart contracts. New transaction context / metadata API. Deprecation and removal of getBlockNumber API. Various stability improvements and bug fixes.","title":"Release notes"},{"location":"ledger/etch-language/release-notes/#version-v09x","text":"Significant changes in this version of the etch virtual machine include the following: Contract payable addresses. keras -style sequential Model now available for use in smart contracts. New transaction context / metadata API. Deprecation and removal of getBlockNumber API. Various stability improvements and bug fixes.","title":"Version v0.9.x"},{"location":"ledger/etch-language/sc-annotations/","text":"Smart contract annotations Smart contract functions are annotated depending on the activity they perform. These annotations are checked at compile time. A function definition or prototype can only be annotated once. Attempting to use more than annotation in a function will raise a compile-time error. @init The @init function defines a contract constructor that sets the state of the contract prior to any operations performed on it. It is called once and once only on contract initialisation/deployment. The name of the @init function can be anything at all. For example, the following function initialises a contract by creating a State type to represent the owner's account which then receives an initial supply of FET tokens. @ init function initialise ( owner : Address ) var INITIAL_SUPPLY = 100000000000u64 ; var account = State < UInt64 > ( \"owner\" ); account . set ( INITIAL_SUPPLY ); endfunction function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); initialise ( owner ); endfunction Only one @init function per contract is allowed; attempting to define more than one will raise a compile-time error. It must take no arguments or only an Address , and its return type must be either void or Int64 . Remember We use main() in the examples to allow for testing smart contract code outside of a ledger environment. @action The @action annotation signifies a function which performs a transaction. A smart contract must have one or more functions annotated with @action . In order for a function to be callable from other smart contracts, it must be annotated with @action , otherwise it will be effectively considered private. You cannot run an etch smart contract on the Python Ledger API without an @action function and it is these functions that trigger the charging rules for data persistence fees. An @action return type must be either void or Int64 . The following function performs a transaction between two parties. In the worst case, this function needs two shards for data storage. @ action function transfer ( from : Address , to : Address , amount : UInt64 ) var from_balance = State < UInt64 > ( from ); from_balance . set ( 1000u64 ); var to_balance = State < UInt64 > ( to ); to_balance . set ( 0u64 ); // check if all the conditions are valid if ( from_balance . get () <= amount ) panic ( \"Argh!\" ); endif from_balance . set ( from_balance . get () - amount ); to_balance . set ( to_balance . get () + amount ); endfunction function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var user = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); transfer ( owner , user , 100u64 ); endfunction @query Query functions are read-only functions that allow you to view data residing on the ledger. Their return type can not be void . The following function queries the balance of an Address . @ query function balance ( address : Address ) : UInt64 var account = State < UInt64 > ( address ); account . set ( 100u64 ); return account . get (); endfunction function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var owner_balance = balance ( owner ); printLn ( owner_balance ); endfunction","title":"Smart contract annotations"},{"location":"ledger/etch-language/sc-annotations/#smart-contract-annotations","text":"Smart contract functions are annotated depending on the activity they perform. These annotations are checked at compile time. A function definition or prototype can only be annotated once. Attempting to use more than annotation in a function will raise a compile-time error.","title":"Smart contract annotations"},{"location":"ledger/etch-language/sc-annotations/#init","text":"The @init function defines a contract constructor that sets the state of the contract prior to any operations performed on it. It is called once and once only on contract initialisation/deployment. The name of the @init function can be anything at all. For example, the following function initialises a contract by creating a State type to represent the owner's account which then receives an initial supply of FET tokens. @ init function initialise ( owner : Address ) var INITIAL_SUPPLY = 100000000000u64 ; var account = State < UInt64 > ( \"owner\" ); account . set ( INITIAL_SUPPLY ); endfunction function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); initialise ( owner ); endfunction Only one @init function per contract is allowed; attempting to define more than one will raise a compile-time error. It must take no arguments or only an Address , and its return type must be either void or Int64 . Remember We use main() in the examples to allow for testing smart contract code outside of a ledger environment.","title":"@init"},{"location":"ledger/etch-language/sc-annotations/#action","text":"The @action annotation signifies a function which performs a transaction. A smart contract must have one or more functions annotated with @action . In order for a function to be callable from other smart contracts, it must be annotated with @action , otherwise it will be effectively considered private. You cannot run an etch smart contract on the Python Ledger API without an @action function and it is these functions that trigger the charging rules for data persistence fees. An @action return type must be either void or Int64 . The following function performs a transaction between two parties. In the worst case, this function needs two shards for data storage. @ action function transfer ( from : Address , to : Address , amount : UInt64 ) var from_balance = State < UInt64 > ( from ); from_balance . set ( 1000u64 ); var to_balance = State < UInt64 > ( to ); to_balance . set ( 0u64 ); // check if all the conditions are valid if ( from_balance . get () <= amount ) panic ( \"Argh!\" ); endif from_balance . set ( from_balance . get () - amount ); to_balance . set ( to_balance . get () + amount ); endfunction function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var user = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); transfer ( owner , user , 100u64 ); endfunction","title":"@action"},{"location":"ledger/etch-language/sc-annotations/#query","text":"Query functions are read-only functions that allow you to view data residing on the ledger. Their return type can not be void . The following function queries the balance of an Address . @ query function balance ( address : Address ) : UInt64 var account = State < UInt64 > ( address ); account . set ( 100u64 ); return account . get (); endfunction function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var owner_balance = balance ( owner ); printLn ( owner_balance ); endfunction","title":"@query"},{"location":"ledger/etch-language/scaler/","text":"Use a Scaler to normalise data. Declare and initialise a Scaler . function main () var scaler = Scaler (); endfunction Min max The min_max flag identifies the scaler which normalises data sets in the range 0-1 based on the maximum and minimum value found in the data set. Set the Scaler type with the setScale() function. var scaler = Scaler (); scaler . setScale ( data_tensor , \"min_max\" ); Once the Scaler type is set, run the normalise() function to scale the data. deNormalise() reverses the process. Both functions return a Tensor . var norm_data_tensor = scaler . normalise ( data_tensor ); var denorm_data_tensor = scaler . deNormalise ( norm_data_tensor ); Scaler example The following code builds a Tensor then sets a Scaler on it to do min max normalisation. Two Tensor types hold normalised and denormalised data respectfully. A nested for loop asserts all normalised data points are between 0 and 1, then prints a set of calculations for each data point. function main () var height = 20u64 ; var width = 40u64 ; var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = height ; data_shape [ 1 ] = width ; var data_tensor = Tensor ( data_shape ); data_tensor . fillRandom (); var scaler = Scaler (); scaler . setScale ( data_tensor , \"min_max\" ); var norm_data_tensor = scaler . normalise ( data_tensor ); var denorm_data_tensor = scaler . deNormalise ( norm_data_tensor ); for ( i in 0u64 : height ) for ( j in 0u64 : width ) assert ( norm_data_tensor . at ( i , j ) <= 1.0f p64 ); assert ( norm_data_tensor . at ( i , j ) >= 0.0f p64 ); var diff = abs ( data_tensor . at ( i , j ) - denorm_data_tensor . at ( i , j )); printLn ( data_tensor . at ( i , j )); printLn ( norm_data_tensor . at ( i , j )); printLn ( denorm_data_tensor . at ( i , j )); printLn ( diff ); assert ( diff < 0.1f p64 ); endfor endfor endfunction","title":"Scaler"},{"location":"ledger/etch-language/scaler/#min-max","text":"The min_max flag identifies the scaler which normalises data sets in the range 0-1 based on the maximum and minimum value found in the data set. Set the Scaler type with the setScale() function. var scaler = Scaler (); scaler . setScale ( data_tensor , \"min_max\" ); Once the Scaler type is set, run the normalise() function to scale the data. deNormalise() reverses the process. Both functions return a Tensor . var norm_data_tensor = scaler . normalise ( data_tensor ); var denorm_data_tensor = scaler . deNormalise ( norm_data_tensor );","title":"Min max"},{"location":"ledger/etch-language/scaler/#scaler-example","text":"The following code builds a Tensor then sets a Scaler on it to do min max normalisation. Two Tensor types hold normalised and denormalised data respectfully. A nested for loop asserts all normalised data points are between 0 and 1, then prints a set of calculations for each data point. function main () var height = 20u64 ; var width = 40u64 ; var data_shape = Array < UInt64 > ( 2 ); data_shape [ 0 ] = height ; data_shape [ 1 ] = width ; var data_tensor = Tensor ( data_shape ); data_tensor . fillRandom (); var scaler = Scaler (); scaler . setScale ( data_tensor , \"min_max\" ); var norm_data_tensor = scaler . normalise ( data_tensor ); var denorm_data_tensor = scaler . deNormalise ( norm_data_tensor ); for ( i in 0u64 : height ) for ( j in 0u64 : width ) assert ( norm_data_tensor . at ( i , j ) <= 1.0f p64 ); assert ( norm_data_tensor . at ( i , j ) >= 0.0f p64 ); var diff = abs ( data_tensor . at ( i , j ) - denorm_data_tensor . at ( i , j )); printLn ( data_tensor . at ( i , j )); printLn ( norm_data_tensor . at ( i , j )); printLn ( denorm_data_tensor . at ( i , j )); printLn ( diff ); assert ( diff < 0.1f p64 ); endfor endfor endfunction","title":"Scaler example"},{"location":"ledger/etch-language/sharded-state/","text":"Warning Use persistent global syntax to build State variables. Introduction to ShardedState variables A ShardedState is like a State type in that data contained within a ShardedState will be etched upon the ledger. The key difference is that a ShardedState is a map, containing key/value pairs. A key must be a String or Address type. Behind the scenes, ShardedState creates anonymous State types for key/value pairs that etch onto the ledger. Declaration Declare a ShardedState in the same way you declare a State : function main () var shardedState = ShardedState < Int32 > ( \"account1\" ); endfunction The account1 identifier is the pointer to the place in memory that holds the data. Add key/value pairs Add key/value pairs to ShardedState like this: function main () var myShardedState = ShardedState < Int32 > ( \"account1\" ); myShardedState . set ( \"sales\" , 0 i32 ); myShardedState . set ( \"gross_profit\" , 0 i32 ); myShardedState . set ( \"net_profit\" , 0 i32 ); set_values_on_state (); endfunction function set_values_on_state () var state = ShardedState < Int32 > ( \"account1\" ); state . set ( \"sales\" , 2000000 ); state . set ( \"gross_profit\" , 1800000 ); state . set ( \"net_profit\" , 1300000 ); endfunction Querying with default values Let's add some query functions to get the ShardedState values. Notice that when you query the data, you provide default values and receive the actual value. Note The annotation `@query` is used in smart contract code and unnecessary for testing with the `etch` VM. function main () var myShardedState = ShardedState < Int32 > ( \"account1\" ); myShardedState . set ( \"sales\" , 0 i32 ); myShardedState . set ( \"gross_profit\" , 0 i32 ); myShardedState . set ( \"net_profit\" , 0 i32 ); set_values_on_state (); printLn ( query_sales ()); printLn ( query_gross_profit ()); printLn ( query_net_profit ()); endfunction function set_values_on_state () var state = ShardedState < Int32 > ( \"account1\" ); state . set ( \"sales\" , 2000000 ); state . set ( \"gross_profit\" , 1800000 ); state . set ( \"net_profit\" , 1300000 ); endfunction @ query function query_sales () : Int32 var state = ShardedState < Int32 > ( \"account1\" ); return state . get ( \"sales\" , 0 i32 ); endfunction @ query function query_gross_profit () : Int32 var state = ShardedState < Int32 > ( \"account1\" ); return state . get ( \"gross_profit\" , 0 i32 ); endfunction @ query function query_net_profit () : Int32 var state = ShardedState < Int32 > ( \"account1\" ); return state . get ( \"net_profit\" , 0 i32 ); endfunction ShardedState types with Address references You can create ShardedState types using Address types as the reference. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var myState = ShardedState < Int32 > ( account ); myState . set ( \"balance\" , 100 ); myState . set ( \"transx1\" , - 10 ); myState . set ( \"transx2\" , 30 ); printLn ( \"My account balance = \" + toString ( myState . get ( \"balance\" ))); endfunction","title":"ShardedState"},{"location":"ledger/etch-language/sharded-state/#introduction-to-shardedstate-variables","text":"A ShardedState is like a State type in that data contained within a ShardedState will be etched upon the ledger. The key difference is that a ShardedState is a map, containing key/value pairs. A key must be a String or Address type. Behind the scenes, ShardedState creates anonymous State types for key/value pairs that etch onto the ledger.","title":"Introduction to ShardedState variables"},{"location":"ledger/etch-language/sharded-state/#declaration","text":"Declare a ShardedState in the same way you declare a State : function main () var shardedState = ShardedState < Int32 > ( \"account1\" ); endfunction The account1 identifier is the pointer to the place in memory that holds the data.","title":"Declaration"},{"location":"ledger/etch-language/sharded-state/#add-keyvalue-pairs","text":"Add key/value pairs to ShardedState like this: function main () var myShardedState = ShardedState < Int32 > ( \"account1\" ); myShardedState . set ( \"sales\" , 0 i32 ); myShardedState . set ( \"gross_profit\" , 0 i32 ); myShardedState . set ( \"net_profit\" , 0 i32 ); set_values_on_state (); endfunction function set_values_on_state () var state = ShardedState < Int32 > ( \"account1\" ); state . set ( \"sales\" , 2000000 ); state . set ( \"gross_profit\" , 1800000 ); state . set ( \"net_profit\" , 1300000 ); endfunction","title":"Add key/value pairs"},{"location":"ledger/etch-language/sharded-state/#querying-with-default-values","text":"Let's add some query functions to get the ShardedState values. Notice that when you query the data, you provide default values and receive the actual value. Note The annotation `@query` is used in smart contract code and unnecessary for testing with the `etch` VM. function main () var myShardedState = ShardedState < Int32 > ( \"account1\" ); myShardedState . set ( \"sales\" , 0 i32 ); myShardedState . set ( \"gross_profit\" , 0 i32 ); myShardedState . set ( \"net_profit\" , 0 i32 ); set_values_on_state (); printLn ( query_sales ()); printLn ( query_gross_profit ()); printLn ( query_net_profit ()); endfunction function set_values_on_state () var state = ShardedState < Int32 > ( \"account1\" ); state . set ( \"sales\" , 2000000 ); state . set ( \"gross_profit\" , 1800000 ); state . set ( \"net_profit\" , 1300000 ); endfunction @ query function query_sales () : Int32 var state = ShardedState < Int32 > ( \"account1\" ); return state . get ( \"sales\" , 0 i32 ); endfunction @ query function query_gross_profit () : Int32 var state = ShardedState < Int32 > ( \"account1\" ); return state . get ( \"gross_profit\" , 0 i32 ); endfunction @ query function query_net_profit () : Int32 var state = ShardedState < Int32 > ( \"account1\" ); return state . get ( \"net_profit\" , 0 i32 ); endfunction","title":"Querying with default values"},{"location":"ledger/etch-language/sharded-state/#shardedstate-types-with-address-references","text":"You can create ShardedState types using Address types as the reference. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var myState = ShardedState < Int32 > ( account ); myState . set ( \"balance\" , 100 ); myState . set ( \"transx1\" , - 10 ); myState . set ( \"transx2\" , 30 ); printLn ( \"My account balance = \" + toString ( myState . get ( \"balance\" ))); endfunction","title":"ShardedState types with Address references"},{"location":"ledger/etch-language/states/","text":"Warning Use persistent global syntax to build State variables. Introduction to State variables A State provides persistent storage for smart contracts. It\u2019s like a global variable that is always there when any function of your contract runs. A smart contract might use a State to store the total supply or use multiple State variables to keep a track of who has what, for example. It can also let a contract track whether some events have occurred before it releases tokens. Declare a State like this: var myState1 = State < Int32 > ( \"simple_state_declaration\" ); Or even this: var myState2 = State < Array < Array < Array < String >>>> ( \"nested_array_state_declaration\" ); A State is not like a normal variable, you have to create a reference to it. For example: function main () var supply = UInt256 ( 1000u64 ); var contract_amount_state = State < UInt256 > ( \"contract_amount\" ); contract_amount_state . set ( supply ); endfunction The above code creates a variable name contract_amount_state and assigns it to a State<Int32> with a reference contract_amount . It then sets a value on the State . State references can be Address or String types. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var supply = UInt256 ( 1000u64 ); var myState = State < UInt256 > ( account ); myState . set ( supply ); endfunction You can get and set values on a State object. function main () var contract_amount_state = State < UInt256 > ( \"contract_amount\" ); var supply = UInt256 ( 1000u64 ); contract_amount_state . set ( supply ); var contract_amount = contract_amount_state . get (); printLn ( \"My state value = \" + toString ( contract_amount_state . get ())); endfunction Default values If a value has not yet been set on the State object and the State does not already exist on the ledger, a run-time error is thrown on calling get() . To avoid this, use with care get(<default value>) with a default value. For example, the following code prints zero if the state doesn't exist and the value that was originally set on it if it does exist. function main () var contract_amount_state = State < Int32 > ( \"contract_amount\" ); var contract_amount = contract_amount_state . get ( 0 ); printLn ( toString ( contract_amount )); endfunction Test a State exists You can test if a state already exists with existed() . function main () var contract_amount_state = State < Int32 > ( \"contract_amount\" ); if ( contract_amount_state . existed ()) printLn ( \"Yes, it exists.\" ); else printLn ( \"This state does not exist.\" ); endif endfunction This test is useful for scenarios in which you use states to see who has what, as you might do in a token contract where you need to keep track of token ownership. State references and scope In the example below, ownerState and contractState point to the same State object on the ledger. function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var ownerState = State < Int32 > ( owner ); ownerState . set ( 333 ); printLn ( \"My state value = \" + toString ( ownerState . get ())); var contractState = State < Int32 > ( owner ); // printLn(\"My state value = \" + toString(contractState.get())); // runtime error: line 7: The state does not represent any value. // The value has not been assigned and/or it does not exist in data storage. endfunction Assuming the referenced State object does not exist on the ledger, attempting to print the value of the second declaration of State generates an error - even though a value was set on it previously. This is because the data set in ownerState has not yet been written to the intermediate cache or ledger storage, so when contractState tries to access it, it finds no value and the etch VM generates a runtime error. Writing State data to the ledger The following is true for State types declared with a var identifier. Currently, State data is written to smart contract intermediate cache only after control has passed out of function scope. While identifiable State variables remain inside function scope, data is written to an intermediate object cache mechanism at construction time. Within the same scope, such data is inaccessible to new State identifiers which have not explicitly called set() on the State . You cannot access a value set on a State if the function scope in which it was created is still open. function main () var state = State < Int32 > ( \"value\" ); state . set ( 11 ); printLn ( state . get ()); var value1 = value (); printLn ( toString ( value1 )); // scope not yet closed therefore runtime error: // The state does not represent any value. // The value has not been assigned and/or it does not exist in data storage. endfunction function value () : Int32 var state = State < Int32 > ( \"value\" ); return state . get (); endfunction Once control reaches the end of the function, the data is written to an intermediate ledger cache mechanism and is available throughout the contract. Once control has reached the end of the contract, and no errors have arisen, the data is etched upon the ledger. Anonymous State types Declaring an anonymous State type without a var identifier performs an immediate data write. function main () State < String > ( \"account1\" ). set ( \"owner1_name\" ); var account1 = State < String > ( \"account1\" ); printLn ( account1 . get ()); endfunction This is useful for ShardedState types which initialise using these immediate write anonymous State types behind the scenes. Passing States around The following code shows the behaviour of State types as they are passed around functions. State values are available to get() if the function scope they were created in originally has closed. function main () var myState = State < Int32 > ( \"contract_owner_balance\" ); myState . set ( 33 ); printLn ( toString ( myState . get ())); // PRINTS 33 change_state ( myState ); printLn ( toString ( myState . get ())); // PRINTS 44 var result = query (); printLn ( toString ( result )); // PRINTS 55 endfunction function change_state ( state : State < Int32 > ) // you can pass around a State parameter and get access to the original state var newState = state ; newState . set ( 44 ); // a new state with pointer = \"balance\" var anotherState = State < Int32 > ( \"balance\" ); anotherState . set ( 55 ); // all states from this function are written now endfunction function query () : Int32 // accessing the State at pointer = \"balance\", a value out of scope var myState = State < Int32 > ( \"balance\" ); // returns the 55 set in change_state() return myState . get (); endfunction Verify an Address Often, a contract needs to confirm whether an @action or @query comes from a specific address. This can be done with the signedTx() function of the Address type. In the example below, an @action establishes if the the signer of the calling transaction is a specific authorised address. function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var authorised = State < Address > ( \"owner\" ); authorised . set ( owner ); doSomething ( owner ); endfunction @ action function doSomething ( signer : Address ) if ( ! signer . signedTx ()) panic ( \"This address doesn't verify, stopping here.\" ); endif // Get the authorised address from the ledger var authorised_state = State < Address > ( \"owner\" ); var authorised_address = authorised_state . get (); if ( authorised_address != signer ) panic ( \"Incorrect address used to trigger\" ); endif // ... we're good to go, the signer of the TX is the stored authorised address... endfunction","title":"State"},{"location":"ledger/etch-language/states/#introduction-to-state-variables","text":"A State provides persistent storage for smart contracts. It\u2019s like a global variable that is always there when any function of your contract runs. A smart contract might use a State to store the total supply or use multiple State variables to keep a track of who has what, for example. It can also let a contract track whether some events have occurred before it releases tokens. Declare a State like this: var myState1 = State < Int32 > ( \"simple_state_declaration\" ); Or even this: var myState2 = State < Array < Array < Array < String >>>> ( \"nested_array_state_declaration\" ); A State is not like a normal variable, you have to create a reference to it. For example: function main () var supply = UInt256 ( 1000u64 ); var contract_amount_state = State < UInt256 > ( \"contract_amount\" ); contract_amount_state . set ( supply ); endfunction The above code creates a variable name contract_amount_state and assigns it to a State<Int32> with a reference contract_amount . It then sets a value on the State . State references can be Address or String types. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var supply = UInt256 ( 1000u64 ); var myState = State < UInt256 > ( account ); myState . set ( supply ); endfunction You can get and set values on a State object. function main () var contract_amount_state = State < UInt256 > ( \"contract_amount\" ); var supply = UInt256 ( 1000u64 ); contract_amount_state . set ( supply ); var contract_amount = contract_amount_state . get (); printLn ( \"My state value = \" + toString ( contract_amount_state . get ())); endfunction","title":"Introduction to State variables"},{"location":"ledger/etch-language/states/#default-values","text":"If a value has not yet been set on the State object and the State does not already exist on the ledger, a run-time error is thrown on calling get() . To avoid this, use with care get(<default value>) with a default value. For example, the following code prints zero if the state doesn't exist and the value that was originally set on it if it does exist. function main () var contract_amount_state = State < Int32 > ( \"contract_amount\" ); var contract_amount = contract_amount_state . get ( 0 ); printLn ( toString ( contract_amount )); endfunction","title":"Default values"},{"location":"ledger/etch-language/states/#test-a-state-exists","text":"You can test if a state already exists with existed() . function main () var contract_amount_state = State < Int32 > ( \"contract_amount\" ); if ( contract_amount_state . existed ()) printLn ( \"Yes, it exists.\" ); else printLn ( \"This state does not exist.\" ); endif endfunction This test is useful for scenarios in which you use states to see who has what, as you might do in a token contract where you need to keep track of token ownership.","title":"Test a State exists"},{"location":"ledger/etch-language/states/#state-references-and-scope","text":"In the example below, ownerState and contractState point to the same State object on the ledger. function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var ownerState = State < Int32 > ( owner ); ownerState . set ( 333 ); printLn ( \"My state value = \" + toString ( ownerState . get ())); var contractState = State < Int32 > ( owner ); // printLn(\"My state value = \" + toString(contractState.get())); // runtime error: line 7: The state does not represent any value. // The value has not been assigned and/or it does not exist in data storage. endfunction Assuming the referenced State object does not exist on the ledger, attempting to print the value of the second declaration of State generates an error - even though a value was set on it previously. This is because the data set in ownerState has not yet been written to the intermediate cache or ledger storage, so when contractState tries to access it, it finds no value and the etch VM generates a runtime error.","title":"State references and scope"},{"location":"ledger/etch-language/states/#writing-state-data-to-the-ledger","text":"The following is true for State types declared with a var identifier. Currently, State data is written to smart contract intermediate cache only after control has passed out of function scope. While identifiable State variables remain inside function scope, data is written to an intermediate object cache mechanism at construction time. Within the same scope, such data is inaccessible to new State identifiers which have not explicitly called set() on the State . You cannot access a value set on a State if the function scope in which it was created is still open. function main () var state = State < Int32 > ( \"value\" ); state . set ( 11 ); printLn ( state . get ()); var value1 = value (); printLn ( toString ( value1 )); // scope not yet closed therefore runtime error: // The state does not represent any value. // The value has not been assigned and/or it does not exist in data storage. endfunction function value () : Int32 var state = State < Int32 > ( \"value\" ); return state . get (); endfunction Once control reaches the end of the function, the data is written to an intermediate ledger cache mechanism and is available throughout the contract. Once control has reached the end of the contract, and no errors have arisen, the data is etched upon the ledger.","title":"Writing State data to the ledger"},{"location":"ledger/etch-language/states/#anonymous-state-types","text":"Declaring an anonymous State type without a var identifier performs an immediate data write. function main () State < String > ( \"account1\" ). set ( \"owner1_name\" ); var account1 = State < String > ( \"account1\" ); printLn ( account1 . get ()); endfunction This is useful for ShardedState types which initialise using these immediate write anonymous State types behind the scenes.","title":"Anonymous State types"},{"location":"ledger/etch-language/states/#passing-states-around","text":"The following code shows the behaviour of State types as they are passed around functions. State values are available to get() if the function scope they were created in originally has closed. function main () var myState = State < Int32 > ( \"contract_owner_balance\" ); myState . set ( 33 ); printLn ( toString ( myState . get ())); // PRINTS 33 change_state ( myState ); printLn ( toString ( myState . get ())); // PRINTS 44 var result = query (); printLn ( toString ( result )); // PRINTS 55 endfunction function change_state ( state : State < Int32 > ) // you can pass around a State parameter and get access to the original state var newState = state ; newState . set ( 44 ); // a new state with pointer = \"balance\" var anotherState = State < Int32 > ( \"balance\" ); anotherState . set ( 55 ); // all states from this function are written now endfunction function query () : Int32 // accessing the State at pointer = \"balance\", a value out of scope var myState = State < Int32 > ( \"balance\" ); // returns the 55 set in change_state() return myState . get (); endfunction","title":"Passing States around"},{"location":"ledger/etch-language/states/#verify-an-address","text":"Often, a contract needs to confirm whether an @action or @query comes from a specific address. This can be done with the signedTx() function of the Address type. In the example below, an @action establishes if the the signer of the calling transaction is a specific authorised address. function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var authorised = State < Address > ( \"owner\" ); authorised . set ( owner ); doSomething ( owner ); endfunction @ action function doSomething ( signer : Address ) if ( ! signer . signedTx ()) panic ( \"This address doesn't verify, stopping here.\" ); endif // Get the authorised address from the ledger var authorised_state = State < Address > ( \"owner\" ); var authorised_address = authorised_state . get (); if ( authorised_address != signer ) panic ( \"Incorrect address used to trigger\" ); endif // ... we're good to go, the signer of the TX is the stored authorised address... endfunction","title":"Verify an Address"},{"location":"ledger/etch-language/strings/","text":"Strings etch supports ASCII and UTF8 for string representation. Concatenation Concatenate strings like this: function main () var myString : String = \"hello\" ; var myInferredString = \"hello again\" ; var myUtf8String = '\u4eba\u5c71\u4eba\u6d77' ; var x : String = null ; printLn ( myString ); printLn ( myInferredString ); printLn ( myInferredString + \" \" + myString ); printLn ( myUtf8String ); // printLn(myString + x); // runtime error: line xx: null reference endfunction Equality You can test strings for equality. function main () var myString1 : String = \"hello\" ; var myString2 : String = \"hello\" ; if ( myString1 == myString2 ) printLn ( \"They are equal.\" ); else printLn ( \"They are not equal.\" ); endif endfunction And inequality. function main () var myString1 : String = \"hello\" ; var myString2 : String = \"again\" ; if ( myString1 != myString2 ) printLn ( \"They are not equal.\" ); else printLn ( \"They are equal.\" ); endif endfunction You can do a less than comparison on equal and unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 < myString2 ) printLn ( \"myString1 is less than myString2.\" ); else printLn ( \"myString1 is not less than myString2.\" ); endif endfunction And a less than or equal to comparison on equal and unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 <= myString2 ) printLn ( \"myString1 is less than or equal to myString2.\" ); else printLn ( \"myString1 is not less or equal to than myString2.\" ); endif endfunction You can calculate greater than between two equal or unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 > myString2 ) printLn ( \"myString1 is greater than or equal to myString2.\" ); else printLn ( \"myString1 is not greater than or equal to myString2.\" ); endif endfunction And greater than or equal to also. function main () var myString1 : String = \"a\" ; var myString2 : String = \"a\" ; if ( myString1 >= myString2 ) printLn ( \"myString1 is greater than or equal to myString2.\" ); else printLn ( \"myString1 is not greater than or equal to myString2.\" ); endif endfunction String functions You can use the following utility functions for string manipulation: Find The find() function searches a string for the first occurrence of a specified substring. The search is case sensitive. The first character in the string occurs at index 0. Returns the index of the first occurrence of the substring. Returns -1 if the substring is not found. Returns -1 if either the string or the substring are empty. function main () var myString : String = \"Hello World\" ; printLn ( myString . find ( \"o\" )); endfunction Length The length() function returns the number of characters in a string. Returns -1 if the string is empty. function main () var myString : String = \"Hello World\" ; printLn ( myString . length ()); endfunction Reverse The reverse() function reverses the order of characters in a string. function main () var myString : String = \"xyz\" ; myString . reverse (); printLn ( myString ); endfunction Split The split() function takes an input string and a character(s) sequence separator to split on and returns an array of strings that does not include the separator. Returns a one element array if there is no separator within it or if the input string is empty. Returns an empty string if more than one separator is encountered consecutively. Returns an empty string as the first element in the output array if the first element of the input is a separator. Returns an empty string as the last element in the output array if the last element of the input is a separator. The following code takes a string and splits it on the separator -- returning an array of strings which it then outputs. function main () var text = ' xxx -- yyy -- zzz ' ; printLn ( text ); var output = text . split ( ' -- ' ); printLn ( output [ 0 ]); printLn ( output [ 1 ]); printLn ( output [ 2 ]); endfunction Substring The substr() function extracts a substring from a string, based on specified starting and ending indices (but excluding the final character): string.substr(start, end) The start character in the string occurs at index 0. The end character is excluded from the substring. Returns an empty string if start and end indices are equal. Returns the whole string if start equals 0 and end is equal to the length of the string. Fails if start is greater than end . Fails if start is negative. Fails if end is greater than the length of the string. function main () printLn ( \"Hello World\" . substr ( 6 , 11 )); endfunction Trim The trim() function removes any whitespace from the start and end of a string. Returns an empty string if the original string contains only whitespace. function main () var myString : String = \" Hello World \" ; myString . trim (); printLn ( myString ); endfunction","title":"Strings"},{"location":"ledger/etch-language/strings/#concatenation","text":"Concatenate strings like this: function main () var myString : String = \"hello\" ; var myInferredString = \"hello again\" ; var myUtf8String = '\u4eba\u5c71\u4eba\u6d77' ; var x : String = null ; printLn ( myString ); printLn ( myInferredString ); printLn ( myInferredString + \" \" + myString ); printLn ( myUtf8String ); // printLn(myString + x); // runtime error: line xx: null reference endfunction","title":"Concatenation"},{"location":"ledger/etch-language/strings/#equality","text":"You can test strings for equality. function main () var myString1 : String = \"hello\" ; var myString2 : String = \"hello\" ; if ( myString1 == myString2 ) printLn ( \"They are equal.\" ); else printLn ( \"They are not equal.\" ); endif endfunction And inequality. function main () var myString1 : String = \"hello\" ; var myString2 : String = \"again\" ; if ( myString1 != myString2 ) printLn ( \"They are not equal.\" ); else printLn ( \"They are equal.\" ); endif endfunction You can do a less than comparison on equal and unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 < myString2 ) printLn ( \"myString1 is less than myString2.\" ); else printLn ( \"myString1 is not less than myString2.\" ); endif endfunction And a less than or equal to comparison on equal and unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 <= myString2 ) printLn ( \"myString1 is less than or equal to myString2.\" ); else printLn ( \"myString1 is not less or equal to than myString2.\" ); endif endfunction You can calculate greater than between two equal or unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 > myString2 ) printLn ( \"myString1 is greater than or equal to myString2.\" ); else printLn ( \"myString1 is not greater than or equal to myString2.\" ); endif endfunction And greater than or equal to also. function main () var myString1 : String = \"a\" ; var myString2 : String = \"a\" ; if ( myString1 >= myString2 ) printLn ( \"myString1 is greater than or equal to myString2.\" ); else printLn ( \"myString1 is not greater than or equal to myString2.\" ); endif endfunction","title":"Equality"},{"location":"ledger/etch-language/strings/#string-functions","text":"You can use the following utility functions for string manipulation:","title":"String functions"},{"location":"ledger/etch-language/strings/#find","text":"The find() function searches a string for the first occurrence of a specified substring. The search is case sensitive. The first character in the string occurs at index 0. Returns the index of the first occurrence of the substring. Returns -1 if the substring is not found. Returns -1 if either the string or the substring are empty. function main () var myString : String = \"Hello World\" ; printLn ( myString . find ( \"o\" )); endfunction","title":"Find"},{"location":"ledger/etch-language/strings/#length","text":"The length() function returns the number of characters in a string. Returns -1 if the string is empty. function main () var myString : String = \"Hello World\" ; printLn ( myString . length ()); endfunction","title":"Length"},{"location":"ledger/etch-language/strings/#reverse","text":"The reverse() function reverses the order of characters in a string. function main () var myString : String = \"xyz\" ; myString . reverse (); printLn ( myString ); endfunction","title":"Reverse"},{"location":"ledger/etch-language/strings/#split","text":"The split() function takes an input string and a character(s) sequence separator to split on and returns an array of strings that does not include the separator. Returns a one element array if there is no separator within it or if the input string is empty. Returns an empty string if more than one separator is encountered consecutively. Returns an empty string as the first element in the output array if the first element of the input is a separator. Returns an empty string as the last element in the output array if the last element of the input is a separator. The following code takes a string and splits it on the separator -- returning an array of strings which it then outputs. function main () var text = ' xxx -- yyy -- zzz ' ; printLn ( text ); var output = text . split ( ' -- ' ); printLn ( output [ 0 ]); printLn ( output [ 1 ]); printLn ( output [ 2 ]); endfunction","title":"Split"},{"location":"ledger/etch-language/strings/#substring","text":"The substr() function extracts a substring from a string, based on specified starting and ending indices (but excluding the final character): string.substr(start, end) The start character in the string occurs at index 0. The end character is excluded from the substring. Returns an empty string if start and end indices are equal. Returns the whole string if start equals 0 and end is equal to the length of the string. Fails if start is greater than end . Fails if start is negative. Fails if end is greater than the length of the string. function main () printLn ( \"Hello World\" . substr ( 6 , 11 )); endfunction","title":"Substring"},{"location":"ledger/etch-language/strings/#trim","text":"The trim() function removes any whitespace from the start and end of a string. Returns an empty string if the original string contains only whitespace. function main () var myString : String = \" Hello World \" ; myString . trim (); printLn ( myString ); endfunction","title":"Trim"},{"location":"ledger/etch-language/syn-annotations/","text":"Etch synergetic contract code includes specific function annotations. These need to be all present or absent, and only one of each type is allowed. @problem specifies a problem. @objective measures the solution to a given problem. @work creates a solution from a random number/nonce. @clear finishes the competition, zeros everything, and saves the solution. You can find an example of a synergetic contract and these annotations here .","title":"Synergetic contract annotations"},{"location":"ledger/etch-language/syntax/","text":"Syntax The etch language integrates with the Fetch.ai Ledger project. It is designed to run on a number of platforms. etch is inspired by Rust, C++, and Python, but it also has some idiosyncrasies. The etch language is extremely restrictive to avoid costly errors on the ledger. See Smart Contract section for more information. etch is a statically typed language and static typing is enforced by the compiler. Note Blocks of code require no delimiters. White space is ignored. Indentation is recommended. You can extend and customise etch in C++. We show you how to do that here . Let's take a closer look at etch . Declarations Explicitly declare the type: function main () var myvariable : String ; endfunction In some cases, type can be inferred: function main () var myvariable = \"hello\" ; endfunction Assign a value like this: function main () var myvariable : String = \"hello\" ; endfunction For multivariate types, all the types must be declared: var multitype - variable - name : Type < Type < Type >> (); Not declaring the variable type and inferrable value results in a compilation error: function main () var myVariable ; endfunction Failed to compile . line 3 : error at ';' , expected ':' or '=' Failed to compile . Main Initially, all our code snippets execute inside the main function: function main () // stuff endfunction Keywords Here is a current list of etch keywords: var if endif else for endfor while endwhile function endfunction break continue return persistent sharded use as any @init @action @problem @objective @work @clear Comments Both line and block comments are possible: // a single comment inside a function /* ..lines of commented out stuff inside and outside functions */ Annotations etch code for smart contracts includes annotated functions. These are more like Java method annotations and not at all like Python decorators: @init is a constructor method that initialises the contract. @action is a function which defines transactions on the ledger that change state. @query is a function that allows you to query data residing on the ledger. There are further annotations for synergetic contracts. Find out about these functions and more in the section on smart contracts .","title":"Syntax"},{"location":"ledger/etch-language/syntax/#declarations","text":"Explicitly declare the type: function main () var myvariable : String ; endfunction In some cases, type can be inferred: function main () var myvariable = \"hello\" ; endfunction Assign a value like this: function main () var myvariable : String = \"hello\" ; endfunction For multivariate types, all the types must be declared: var multitype - variable - name : Type < Type < Type >> (); Not declaring the variable type and inferrable value results in a compilation error: function main () var myVariable ; endfunction Failed to compile . line 3 : error at ';' , expected ':' or '=' Failed to compile .","title":"Declarations"},{"location":"ledger/etch-language/syntax/#main","text":"Initially, all our code snippets execute inside the main function: function main () // stuff endfunction","title":"Main"},{"location":"ledger/etch-language/syntax/#keywords","text":"Here is a current list of etch keywords: var if endif else for endfor while endwhile function endfunction break continue return persistent sharded use as any @init @action @problem @objective @work @clear","title":"Keywords"},{"location":"ledger/etch-language/syntax/#comments","text":"Both line and block comments are possible: // a single comment inside a function /* ..lines of commented out stuff inside and outside functions */","title":"Comments"},{"location":"ledger/etch-language/syntax/#annotations","text":"etch code for smart contracts includes annotated functions. These are more like Java method annotations and not at all like Python decorators: @init is a constructor method that initialises the contract. @action is a function which defines transactions on the ledger that change state. @query is a function that allows you to query data residing on the ledger. There are further annotations for synergetic contracts. Find out about these functions and more in the section on smart contracts .","title":"Annotations"},{"location":"ledger/etch-language/tensor/","text":"A Tensor is a vector or matrix type having multiple dimensions. In etch it is the n-dimensional matrix type used by the mathematics and machine learning libraries. Declare and initialise Declare and initialise a Tensor by first defining the size of its dimensions. We do that with a one dimensional array of 64 bit unsigned integers: Array<UInt64> . Note There is conceptually no limit to how many dimensions a `Tensor` object can have, although there are practical limitations set by the `etch` implementation which the documentation highlights. The following code sets up a two dimensional Tensor object's shape by declaring an array with length equal to two. We give the first dimension three elements and the second dimension four. Finally, the code takes the array, builds the Tensor , and prints the default Fixed64 values contained within. function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 4u64 ; var tensor = Tensor ( tensor_shape ); printLn ( tensor . toString ()); endfunction toString Print a Tensor object with no more than two dimensions with the toString() function. function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . toString ()); endfunction Size Get the size of a Tensor object with the size() function. It returns the total number of elements in the Tensor . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 12u64 ; tensor_shape [ 1 ] = 12u64 ; var tensor = Tensor ( tensor_shape ); printLn ( tensor . size ()); endfunction fromString Use the fromString() function to insert a comma separated string of values into each element of the Tensor . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 4u64 ; tensor_shape [ 1 ] = 1u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . toString ()); var string_vals = \"1.0, 1.0, 1.0, 1.0\" ; tensor . fromString ( string_vals ); printLn ( tensor . toString ()); endfunction Fill Use the fill() function to insert a specific Fixed64 value into each element of the Tensor . The following two dimensional Tensor contains nine elements all set to 7.0 . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fill ( 7.0f p64 ); printLn ( tensor . toString ()); endfunction Fill Random The function fillRandom() inserts random Fixed64 values between 0 and 1 into the Tensor . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . toString ()); endfunction Setters Use setAt() to insert a Fixed64 value at a specific index. 1D The following code creates a one dimensional Tensor object. The dimension has three elements. The code sets specific values at each element with the function setAt(index_u64, value_fp64) . function main () var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 35.0f p64 ); printLn ( tensor . toString ()); endfunction 2D The following code creates a two dimensional Tensor object. Each dimension has three elements. The code sets specific values at each element with the function setAt(index1_u64, index2_u64, value_fp64) . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 2u64 , 35.0f p64 ); printLn ( tensor . toString ()); endfunction 3D The following code creates a three dimensional Tensor object. Each dimension has three elements. The code sets specific values at each element with the function setAt(index1_u64, index2_u64, index3_u64, value_fp64) . function main () var tensor_shape = Array < UInt64 > ( 3 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 0u64 , 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 1u64 , 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 2u64 , 2u64 , 35.0f p64 ); endfunction 4D The following code creates a four dimensional Tensor object. Each dimension has three elements. The code sets specific values at each element with the function setAt(index1_u64, index2_u64, index3_u64, index4_u64, value_fp64) . function main () var tensor_shape = Array < UInt64 > ( 4 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; tensor_shape [ 3 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 0u64 , 0u64 , 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 1u64 , 1u64 , 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 2u64 , 2u64 , 2u64 , 35.0f p64 ); tensor . setAt ( 3u64 , 3u64 , 3u64 , 3u64 , 36.0f p64 ); endfunction Getters The getter function at() is available for one, two, and three dimension Tensor objects. It returns the value of the element at the given dimension. 1D function main () var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 35.0f p64 ); printLn ( tensor . at ( 1u64 )); endfunction 2D function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . at ( 1u64 , 1u64 )); endfunction 3D function main () var tensor_shape = Array < UInt64 > ( 3 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . at ( 1u64 , 1u64 , 1u64 )); endfunction 4D function main () var tensor_shape = Array < UInt64 > ( 4 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; tensor_shape [ 3 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . at ( 1u64 , 1u64 , 1u64 , 1u64 )); endfunction Reshape The function reshape() allows you to reshape an already existing Tensor into a new dimensional shape. Note The `reshape()` function is destructive and the previous `Tensor` data is not preserved. function main () var tensor_shape = Array < UInt64 > ( 2 ); var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); var new_shape = Array < UInt64 > ( 10 ); tensor . reshape ( new_shape ); endfunction Squeeze The function squeeze() returns a copy of the Tensor removing any dimension with size 1. Currently, squeeze() throws an error if there are no dimensions in the Tensor of size 1. function main () var tensor_shape = Array < UInt64 > ( 3 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 1u64 ; tensor_shape [ 2 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fill ( 7.0f p64 ); // reassign tensor tensor = tensor . squeeze (); printLn ( \"Squeezed!\" ); printLn ( tensor . toString ()); endfunction Serialisation A Tensor is serialisable and deserialisable. The following code stores a Tensor in a State object. It then retrieves the State object, gets and prints the Tensor . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 12u64 ; tensor_shape [ 1 ] = 12u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); var serialised_tensor = State < Tensor > ( \"tensor\" ); serialised_tensor . set ( tensor ); var retrieved_tensor = Tensor ( tensor_shape ); retrieved_tensor = serialised_tensor . get (); printLn ( retrieved_tensor . toString ()); endfunction","title":"Tensor"},{"location":"ledger/etch-language/tensor/#declare-and-initialise","text":"Declare and initialise a Tensor by first defining the size of its dimensions. We do that with a one dimensional array of 64 bit unsigned integers: Array<UInt64> . Note There is conceptually no limit to how many dimensions a `Tensor` object can have, although there are practical limitations set by the `etch` implementation which the documentation highlights. The following code sets up a two dimensional Tensor object's shape by declaring an array with length equal to two. We give the first dimension three elements and the second dimension four. Finally, the code takes the array, builds the Tensor , and prints the default Fixed64 values contained within. function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 4u64 ; var tensor = Tensor ( tensor_shape ); printLn ( tensor . toString ()); endfunction","title":"Declare and initialise"},{"location":"ledger/etch-language/tensor/#tostring","text":"Print a Tensor object with no more than two dimensions with the toString() function. function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . toString ()); endfunction","title":"toString"},{"location":"ledger/etch-language/tensor/#size","text":"Get the size of a Tensor object with the size() function. It returns the total number of elements in the Tensor . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 12u64 ; tensor_shape [ 1 ] = 12u64 ; var tensor = Tensor ( tensor_shape ); printLn ( tensor . size ()); endfunction","title":"Size"},{"location":"ledger/etch-language/tensor/#fromstring","text":"Use the fromString() function to insert a comma separated string of values into each element of the Tensor . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 4u64 ; tensor_shape [ 1 ] = 1u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . toString ()); var string_vals = \"1.0, 1.0, 1.0, 1.0\" ; tensor . fromString ( string_vals ); printLn ( tensor . toString ()); endfunction","title":"fromString"},{"location":"ledger/etch-language/tensor/#fill","text":"Use the fill() function to insert a specific Fixed64 value into each element of the Tensor . The following two dimensional Tensor contains nine elements all set to 7.0 . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fill ( 7.0f p64 ); printLn ( tensor . toString ()); endfunction","title":"Fill"},{"location":"ledger/etch-language/tensor/#fill-random","text":"The function fillRandom() inserts random Fixed64 values between 0 and 1 into the Tensor . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . toString ()); endfunction","title":"Fill Random"},{"location":"ledger/etch-language/tensor/#setters","text":"Use setAt() to insert a Fixed64 value at a specific index.","title":"Setters"},{"location":"ledger/etch-language/tensor/#1d","text":"The following code creates a one dimensional Tensor object. The dimension has three elements. The code sets specific values at each element with the function setAt(index_u64, value_fp64) . function main () var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 35.0f p64 ); printLn ( tensor . toString ()); endfunction","title":"1D"},{"location":"ledger/etch-language/tensor/#2d","text":"The following code creates a two dimensional Tensor object. Each dimension has three elements. The code sets specific values at each element with the function setAt(index1_u64, index2_u64, value_fp64) . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 2u64 , 35.0f p64 ); printLn ( tensor . toString ()); endfunction","title":"2D"},{"location":"ledger/etch-language/tensor/#3d","text":"The following code creates a three dimensional Tensor object. Each dimension has three elements. The code sets specific values at each element with the function setAt(index1_u64, index2_u64, index3_u64, value_fp64) . function main () var tensor_shape = Array < UInt64 > ( 3 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 0u64 , 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 1u64 , 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 2u64 , 2u64 , 35.0f p64 ); endfunction","title":"3D"},{"location":"ledger/etch-language/tensor/#4d","text":"The following code creates a four dimensional Tensor object. Each dimension has three elements. The code sets specific values at each element with the function setAt(index1_u64, index2_u64, index3_u64, index4_u64, value_fp64) . function main () var tensor_shape = Array < UInt64 > ( 4 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; tensor_shape [ 3 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 0u64 , 0u64 , 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 1u64 , 1u64 , 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 2u64 , 2u64 , 2u64 , 35.0f p64 ); tensor . setAt ( 3u64 , 3u64 , 3u64 , 3u64 , 36.0f p64 ); endfunction","title":"4D"},{"location":"ledger/etch-language/tensor/#getters","text":"The getter function at() is available for one, two, and three dimension Tensor objects. It returns the value of the element at the given dimension.","title":"Getters"},{"location":"ledger/etch-language/tensor/#1d_1","text":"function main () var tensor_shape = Array < UInt64 > ( 1 ); tensor_shape [ 0 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . setAt ( 0u64 , 33.0f p64 ); tensor . setAt ( 1u64 , 34.0f p64 ); tensor . setAt ( 2u64 , 35.0f p64 ); printLn ( tensor . at ( 1u64 )); endfunction","title":"1D"},{"location":"ledger/etch-language/tensor/#2d_1","text":"function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . at ( 1u64 , 1u64 )); endfunction","title":"2D"},{"location":"ledger/etch-language/tensor/#3d_1","text":"function main () var tensor_shape = Array < UInt64 > ( 3 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . at ( 1u64 , 1u64 , 1u64 )); endfunction","title":"3D"},{"location":"ledger/etch-language/tensor/#4d_1","text":"function main () var tensor_shape = Array < UInt64 > ( 4 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 3u64 ; tensor_shape [ 2 ] = 3u64 ; tensor_shape [ 3 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); printLn ( tensor . at ( 1u64 , 1u64 , 1u64 , 1u64 )); endfunction","title":"4D"},{"location":"ledger/etch-language/tensor/#reshape","text":"The function reshape() allows you to reshape an already existing Tensor into a new dimensional shape. Note The `reshape()` function is destructive and the previous `Tensor` data is not preserved. function main () var tensor_shape = Array < UInt64 > ( 2 ); var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); var new_shape = Array < UInt64 > ( 10 ); tensor . reshape ( new_shape ); endfunction","title":"Reshape"},{"location":"ledger/etch-language/tensor/#squeeze","text":"The function squeeze() returns a copy of the Tensor removing any dimension with size 1. Currently, squeeze() throws an error if there are no dimensions in the Tensor of size 1. function main () var tensor_shape = Array < UInt64 > ( 3 ); tensor_shape [ 0 ] = 3u64 ; tensor_shape [ 1 ] = 1u64 ; tensor_shape [ 2 ] = 3u64 ; var tensor = Tensor ( tensor_shape ); tensor . fill ( 7.0f p64 ); // reassign tensor tensor = tensor . squeeze (); printLn ( \"Squeezed!\" ); printLn ( tensor . toString ()); endfunction","title":"Squeeze"},{"location":"ledger/etch-language/tensor/#serialisation","text":"A Tensor is serialisable and deserialisable. The following code stores a Tensor in a State object. It then retrieves the State object, gets and prints the Tensor . function main () var tensor_shape = Array < UInt64 > ( 2 ); tensor_shape [ 0 ] = 12u64 ; tensor_shape [ 1 ] = 12u64 ; var tensor = Tensor ( tensor_shape ); tensor . fillRandom (); var serialised_tensor = State < Tensor > ( \"tensor\" ); serialised_tensor . set ( tensor ); var retrieved_tensor = Tensor ( tensor_shape ); retrieved_tensor = serialised_tensor . get (); printLn ( retrieved_tensor . toString ()); endfunction","title":"Serialisation"},{"location":"ledger/etch-language/training-pairs/","text":"TrainingPair is a custom etch class used to load data into a DataLoader . A TrainingPair contains pairs of training data and the corresponding training label coming from two Tensor types. Declare and initialise a TrainingPair . function main () var trainingPair = TrainingPair ( tensor1 , tensor2 ); endfunction The code below builds two Tensor types, then creates a TrainingPair type with them. function main () var shape = Array < UInt64 > ( 2 ); shape [ 0 ] = 28u64 ; shape [ 1 ] = 28u64 ; var tensor1 = Tensor ( shape ); shape [ 0 ] = 1u64 ; shape [ 1 ] = 10u64 ; var tensor2 = Tensor ( shape ); var trainingPair = TrainingPair ( tensor1 , tensor2 ); endfunction","title":"Training pairs"},{"location":"ledger/etch-language/transaction/","text":"The Transaction type provides access to data pertaining to a currently invoking transaction on a running smart contract. To access the Transaction type you need a Context . getContext() Call getContext() from within a permitted specific annotated function . From here, use the transaction() function to return the Transaction data. var context = getContext (); var tx = context . transaction (); With the variable tx , you now have access to a number of transaction functions. digest() The digest() function returns the hash of the transaction in UInt256 form. var context = getContext (); var tx = context . transaction (); var tx_digest = tx . digest (); from() The from() function returns the Address of the transaction sender. var context = getContext (); var tx = context . transaction (); var tx_sender = tx . from (); transfers() transfers() returns an array of Transfer types. var context = getContext (); var tx = context . transaction (); var tx_transfer = tx . transfers (); getTotalTransferAmount() The getTotalTransferAmount() returns a value for the total transfer amount in UInt64 . var context = getContext (); var tx = context . transaction (); var tx_total_amount = tx . getTotalTransferAmount (); validFrom() The validFrom() function returns the starting block index. var context = getContext (); var tx = context . transaction (); var tx_valid_from = tx . validFrom (); validUntil() The validUntil() function returns a future block index. var context = getContext (); var tx = context . transaction (); var tx_valid_until = tx . validUntil (); chargeRate() The chargeRate() function returns the charge rate in UInt64 . var context = getContext (); var tx = context . transaction (); var tx_charge_rate = tx . chargeRate (); chargeLimit() The chargeLimit() function returns the limit to the transaction charge in UInt64 . var context = getContext (); var tx = context . transaction (); var tx_charge_limit = tx . chargeLimit (); contractDigest() The contractDigest() function returns the hash of the contract string in UInt256 form. var context = getContext (); var tx = context . transaction (); var tx_contract_digest = tx . contractDigest (); contractAddress() The contractAddress() function returns the unique contract Address . var context = getContext (); var tx = context . transaction (); var tx_contract_address = tx . contractAddress (); action() The action() function returns the name of the currently invoking @action function. var context = getContext (); var tx = context . transaction (); var tx_action = tx . action (); signatories() The signatories() function returns an array of Address types. var context = getContext (); var tx = context . transaction (); var tx_signatories = tx . signatories (); Example Note Coming soon.","title":"Transaction"},{"location":"ledger/etch-language/transaction/#getcontext","text":"Call getContext() from within a permitted specific annotated function . From here, use the transaction() function to return the Transaction data. var context = getContext (); var tx = context . transaction (); With the variable tx , you now have access to a number of transaction functions.","title":"getContext()"},{"location":"ledger/etch-language/transaction/#digest","text":"The digest() function returns the hash of the transaction in UInt256 form. var context = getContext (); var tx = context . transaction (); var tx_digest = tx . digest ();","title":"digest()"},{"location":"ledger/etch-language/transaction/#from","text":"The from() function returns the Address of the transaction sender. var context = getContext (); var tx = context . transaction (); var tx_sender = tx . from ();","title":"from()"},{"location":"ledger/etch-language/transaction/#transfers","text":"transfers() returns an array of Transfer types. var context = getContext (); var tx = context . transaction (); var tx_transfer = tx . transfers ();","title":"transfers()"},{"location":"ledger/etch-language/transaction/#gettotaltransferamount","text":"The getTotalTransferAmount() returns a value for the total transfer amount in UInt64 . var context = getContext (); var tx = context . transaction (); var tx_total_amount = tx . getTotalTransferAmount ();","title":"getTotalTransferAmount()"},{"location":"ledger/etch-language/transaction/#validfrom","text":"The validFrom() function returns the starting block index. var context = getContext (); var tx = context . transaction (); var tx_valid_from = tx . validFrom ();","title":"validFrom()"},{"location":"ledger/etch-language/transaction/#validuntil","text":"The validUntil() function returns a future block index. var context = getContext (); var tx = context . transaction (); var tx_valid_until = tx . validUntil ();","title":"validUntil()"},{"location":"ledger/etch-language/transaction/#chargerate","text":"The chargeRate() function returns the charge rate in UInt64 . var context = getContext (); var tx = context . transaction (); var tx_charge_rate = tx . chargeRate ();","title":"chargeRate()"},{"location":"ledger/etch-language/transaction/#chargelimit","text":"The chargeLimit() function returns the limit to the transaction charge in UInt64 . var context = getContext (); var tx = context . transaction (); var tx_charge_limit = tx . chargeLimit ();","title":"chargeLimit()"},{"location":"ledger/etch-language/transaction/#contractdigest","text":"The contractDigest() function returns the hash of the contract string in UInt256 form. var context = getContext (); var tx = context . transaction (); var tx_contract_digest = tx . contractDigest ();","title":"contractDigest()"},{"location":"ledger/etch-language/transaction/#contractaddress","text":"The contractAddress() function returns the unique contract Address . var context = getContext (); var tx = context . transaction (); var tx_contract_address = tx . contractAddress ();","title":"contractAddress()"},{"location":"ledger/etch-language/transaction/#action","text":"The action() function returns the name of the currently invoking @action function. var context = getContext (); var tx = context . transaction (); var tx_action = tx . action ();","title":"action()"},{"location":"ledger/etch-language/transaction/#signatories","text":"The signatories() function returns an array of Address types. var context = getContext (); var tx = context . transaction (); var tx_signatories = tx . signatories ();","title":"signatories()"},{"location":"ledger/etch-language/transaction/#example","text":"Note Coming soon.","title":"Example"},{"location":"ledger/etch-language/variables/","text":"Variables etch is a statically-typed programming language. The behaviour of value and reference types (primitives and non-primitives in Java) is the same as in other high level languages such as C++, Java, .Net, and Python. Declare a variable with the keyword var . Declare numeric values with literals where possible. Naming Variable naming follows the same rules as C++. function main () var ABC = 0 ; var abc = 1 ; var _abc = 2 ; // var *abc = 3; // error at '*', expected variable name // var 123 = 4; // error at '123', expected variable name var a123 = 5 ; var a_123 = 6 ; endfunction Integers Integers can be signed or unsigned and are currently restricted to the width range 8-256 bits (1 to 32 bytes). They are declared as signed Int8 , Int16 , Int32 , Int64 , and unsigned UInt8 , UInt16 , UInt32 , UInt64 , UInt256 . Further, and in the same order, they can be declared with postfix literals i8 , i16 , i32 , i64 , u8 , u16 , u32 , and u64 . The UInt256 label will be supplied in a future version. Int32 is the compiler default so you don't need to explicitly declare this type. Warn Negative unsigned integers are dealt with in the same way C++ deals with them. They return a positive wrapped result dependent on size. Below is a selection of example integer assignations. function main () // declaring the default signed positive 32 bit integer type var int32bit_default = 42 ; // declaring negative value var int32bit : Int32 = - 42 ; printLn ( toString ( int32bit_default )); printLn ( toString ( int32bit )); endfunction function main () // assigning various signed integer types explicitly and with label var int8a = 0 i8 ; printLn ( toString ( int8a )); var int8b : Int8 = - 1 i8 ; printLn ( toString ( int8b )); var int16a = 2 i16 ; printLn ( toString ( int16a )); var int16b : Int16 = - 3 i16 ; printLn ( toString ( int16b )); endfunction function main () // Int32 is default but can be explicit also var int32a = 0 i32 ; printLn ( toString ( int32a )); var int32b : Int32 = - 1 i32 ; printLn ( toString ( int32b )); var int64a = 2 i64 ; printLn ( toString ( int64a )); var int64b : Int64 = - 3 i64 ; printLn ( toString ( int64b )); endfunction function main () // assigning various unsigned integer types var uint8a = 0u8 ; printLn ( toString ( uint8a )); var uint8b : UInt8 = 1u8 ; printLn ( toString ( uint8b )); var uint16a = 2u16 ; printLn ( toString ( uint16a )); var uint16b : UInt16 = 3u16 ; printLn ( toString ( uint16b )); endfunction function main () // assigning various unsigned integer types var uint32a = 0u32 ; printLn ( toString ( uint32a )); var uint32b : UInt32 = 1u32 ; printLn ( toString ( uint32b )); var uint64a = 2u64 ; printLn ( toString ( uint64a )); var uint64b : UInt64 = 3u64 ; printLn ( toString ( uint64b )); endfunction 32 byte unsigned integer Build a UInt256 from a UInt64 literal, like this: function main () var uint256 = UInt256 ( 100u64 ); printLn ( toString ( uint256 )); endfunction UInt256 variables are printed in hexadecimal for brevity. Fixed point decimals Low and high precision calculations can be performed by the use of Fixed point types. Fixed point variables are available as Fixed32 , Fixed64 and Fixed128 types. Fixed point types use half of the high bits for the integer part and the low half bits for the fractional part. More specifically the split is done as following: Type Integer bits Fractional bits Fixed32 16 16 Fixed64 32 32 Fixed128 64 64 You must declare Fixed Point variables with the postfix literals fp32 , fp64 and fp128 . function main () var fixed32bit : Fixed32 = 32.1f p32 ; var fixed64bit : Fixed64 = 64.1f p64 ; var fixed128bit : Fixed128 = 64.1f p128 ; printLn ( toString ( fixed32bit )); printLn ( toString ( fixed64bit )); printLn ( toString ( fixed128bit )); endfunction For brevity, you do not need the full declaration. function main () var fixed32bit = - 32.0f p32 ; var fixed64bit = - 64.0f p64 ; var fixed128bit = - 128.0f p128 ; printLn ( toString ( fixed32bit )); printLn ( toString ( fixed64bit )); printLn ( toString ( fixed128bit )); endfunction Make sure you are aware of the precision limits for fixed point decimals in etch . Type Minimum value Maximum value Fixed32 -32766.9999 32766.9999 Fixed64 -2147483646.999999999 2147483646.999999999 Fixed128 -9223372036854775806.10000000000000000000 9223372036854775806.10000000000000000000 For up to date information tolerance, maximum exponent, and number of decimal places for fixed point types, please check the comments . Boolean Declare and initialise Bool types as follows: function main () var myFBool : Bool = false ; var myTBool : Bool = true ; printLn ( toString ( myFBool )); printLn ( toString ( myTBool )); endfunction Strings Declare and initialise strings as follows: function main () var myString : String = \"hello\" ; var myInferredString = \"hello again\" ; var x : String = null ; printLn ( myString ); printLn ( myInferredString ); printLn ( myInferredString + \" \" + myString ); printLn ( x ); endfunction Find out more about etch Strings here . Arrays You must explicitly declare array element types and array size. Array<Type>(size) declares an array with elements of type Type and size size . function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( toString ( myArray [ 3 ])); for ( i in 0 : 5 ) printLn ( toString ( myArray [ i ])); endfor printLn ( myArray ); endfunction Find out more about etch Arrays here . Buffer Create a Buffer byte array type like this, where the Buffer size is defined by a UInt32 type. function main () var myBuffer = Buffer ( 8 ); endfunction A Buffer is the medium for data transport/exchange between other types, such as SHA256 and UInt256 . A parallel representation is the Array<UInt8> type. Maps Declare the dictionary Map type with Map<KeyType, ValueType>() . A duplicate key overrides the previous duplicate entry. The function count() returns an Int32 value representing the number of entries in the Map . function main () var myMap = Map < String , Int32 > (); myMap [ \"balance1\" ] = 1000 ; myMap [ \"balance2\" ] = 2000 ; myMap [ \"balance3\" ] = 3000 ; printLn ( toString ( myMap [ \"balance1\" ])); printLn ( toString ( myMap [ \"balance2\" ])); printLn ( toString ( myMap [ \"balance3\" ])); printLn ( toString ( myMap . count ())); endfunction Note Coming soon: common `Map` operations. StructuredData StructuredData is another Map type containing key/value pairs. Declare a StructuredData type with var variable_name = StructuredData(); . Add key/value pairs with the variable_name.set(key, value); function. There is no appreciable size limit. Keys must be strings. No duplicate keys allowed. A duplicate key overrides the previous duplicate entry. Values can be any primitive, string, or array of primitives. An important difference to the Map type is that a StructuredData type can generate yaml , json , or similar. function main () var data = StructuredData (); data . set ( \"key1\" , 200 i32 ); data . set ( \"key2\" , 500u64 ); data . set ( \"key3\" , \"hello world\" ); printLn ( toString ( data . getInt32 ( \"key1\" ))); printLn ( toString ( data . getUInt64 ( \"key2\" ))); printLn ( data . getString ( \"key3\" )); endfunction State A State is a data structure used by etch smart contracts for storing and querying data on the Fetch.ai Ledger shards. Unique identifiers for the ledger data are created at State construction time. These are unique to the smart contract alone. Declare and initialise a State type with State<ValueType>(\"ledger_identifier\") . function main () var myState = State<Int32> ( \"account\" ) ; endfunction Getters and setters are available for State types. In the example, values set with the set() function map to the unique ledger identifier account . function main () var myState = State < Int32 > ( \"account\" ); myState . set ( 10 ); printLn ( \"My state var value = \" + toString ( myState . get ())); endfunction Find out more about etch States here . ShardedState Like State , a ShardedState is also used for reading and writing data to the Fetch.ai Ledger. ShardedState manipulates State types behind the scenes but, for etch programmer purposes, a ShardedState operates like a Map with key/value pairs. Keys must be either String or Address types. Value types are declared at construction time. No duplicate keys allowed. A duplicate key overrides the previous duplicate entry. Declare and initialise a ShardedState . var my_sharded_state = ShardedState < ValueType > ( \"ledger_identifier\" ) Call set() on it to create a key/value pair. Print a value using get() with a key and a default value. function main () var myShardedState = ShardedState < Int32 > ( \"account1\" ); myShardedState . set ( \"salary\" , 45000 i32 ); printLn ( toString ( myShardedState . get ( \"salary\" , 0 i32 ))); endfunction Find out more about etch ShardedState types here . Address The cryptographic Address type is currently represented by a 64 byte binary canonical ECDSA public key which is then base 58 encoded. Declare and initialise an Address like this: function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); endfunction Find out more about the etch Address type here . Mathematical, ML, and AI etch provides powerful mathematical, machine learning, and AI specific data types and functions. For more details on the mathematical computation functions above, please check the section on maths functions here . For more details on the machine learning implementations, please check the section on machine learning functions here . Type casting There is no implicit type casting in etch . If you need a specific non-default numerical type, you can make an explicit cast of the default Int32 and Fixed64 types. Use to<Type>Name(variable_to_cast) . function main () // signed 32 bit integer type var int32bit = 42 ; // cast to Int8 var int8Variable = toInt8 ( int32bit ); // cast to Int16 var int16Variable = toInt16 ( int32bit ); // cast to Int64 var int64Variable = toInt64 ( int32bit ); // cast to UInt8 var uint8Variable = toUInt8 ( int32bit ); // cast to UInt16 var uint16Variable = toUInt16 ( int32bit ); // cast to UInt32 var uint32Variable = toUInt32 ( int32bit ); // cast to UInt64 var uint64Variable = toUInt64 ( int32bit ); // cast to UInt256 // var uint256Variable = toUInt256(int32bit); // coming soon // fixed point casting var fixed32 : Fixed32 = 32.1f p32 ; var fixed64 : Fixed64 = 64.1f p64 ; // cast Fixed32 to Int32 var int32var = toInt32 ( fixed32 ); // cast Fixed64 to Fixed32 var fixed32Variable = toFixed32 ( fixed64 ); // cast Int32 to Fixed64 var fixed64variable = toFixed64 ( int32bit ); // cast to string var stringVariable = toString ( int32bit ); endfunction Data size In the table below, we detail the memory size of each data type. Warning Currently, the const value cannot be given precisely and varies depending on whether we are talking about in-memory or in-permanent size. For more information on the integer size ranges, please see the MessagePack specification . Type Memory size Int8 1-2 byte Int16 1-3 bytes Int32 1-5 bytes Int64 1-9 bytes UInt8 1-2 byte UInt16 1-3 bytes UInt32 1-5 bytes UInt64 1-9 bytes UInt256 32 bytes Fixed32 4 bytes Fixed64 8 bytes Fixed128 16 bytes Bool 1 byte String len(string) + const Array len(Array<Type>) * sizeof(Type) + const Map len(Map<K, V>) * (sizeof(KeyType) + sizeof(ValueType)) + const StructuredData len(StructuredData<K, V>) * (sizeof(KeyType) + sizeof(ValueType)) + const State sizeof(Type) + const ShardedState len(ShardedState<K, V>) * (sizeof(KeyType) + sizeof(ValueType)) + const Address 32 bytes Scope etch scripts have no traditional global variables. They do, however, have persistent global types that represent any State or ShardedState type residing on the Fetch.ai Ledger. Find out more about persistent global types here. Null Reference types can be set to null. function main () // var myInt = null ; // error: unable to infer type var str : String = null ; var myArray : Array < Int32 > = null ; var myMap : Map < Int32 , Int32 > = null ; var myState : State < Int32 > = null ; var myAddress : Address = null ; var myString : String = null ; printLn ( myString ); // (nullptr) endfunction Default values Certain types not explicitly initialised receive a default value. Type Default value Int8 0 Int16 0 Int32 0 Int64 0 UInt8 0 UInt16 0 UInt32 0 UInt64 0 UInt256 tbc Fixed32 0.0 Fixed64 0.0 Fixed128 0.0 Bool false String no default","title":"Variables"},{"location":"ledger/etch-language/variables/#naming","text":"Variable naming follows the same rules as C++. function main () var ABC = 0 ; var abc = 1 ; var _abc = 2 ; // var *abc = 3; // error at '*', expected variable name // var 123 = 4; // error at '123', expected variable name var a123 = 5 ; var a_123 = 6 ; endfunction","title":"Naming"},{"location":"ledger/etch-language/variables/#integers","text":"Integers can be signed or unsigned and are currently restricted to the width range 8-256 bits (1 to 32 bytes). They are declared as signed Int8 , Int16 , Int32 , Int64 , and unsigned UInt8 , UInt16 , UInt32 , UInt64 , UInt256 . Further, and in the same order, they can be declared with postfix literals i8 , i16 , i32 , i64 , u8 , u16 , u32 , and u64 . The UInt256 label will be supplied in a future version. Int32 is the compiler default so you don't need to explicitly declare this type. Warn Negative unsigned integers are dealt with in the same way C++ deals with them. They return a positive wrapped result dependent on size. Below is a selection of example integer assignations. function main () // declaring the default signed positive 32 bit integer type var int32bit_default = 42 ; // declaring negative value var int32bit : Int32 = - 42 ; printLn ( toString ( int32bit_default )); printLn ( toString ( int32bit )); endfunction function main () // assigning various signed integer types explicitly and with label var int8a = 0 i8 ; printLn ( toString ( int8a )); var int8b : Int8 = - 1 i8 ; printLn ( toString ( int8b )); var int16a = 2 i16 ; printLn ( toString ( int16a )); var int16b : Int16 = - 3 i16 ; printLn ( toString ( int16b )); endfunction function main () // Int32 is default but can be explicit also var int32a = 0 i32 ; printLn ( toString ( int32a )); var int32b : Int32 = - 1 i32 ; printLn ( toString ( int32b )); var int64a = 2 i64 ; printLn ( toString ( int64a )); var int64b : Int64 = - 3 i64 ; printLn ( toString ( int64b )); endfunction function main () // assigning various unsigned integer types var uint8a = 0u8 ; printLn ( toString ( uint8a )); var uint8b : UInt8 = 1u8 ; printLn ( toString ( uint8b )); var uint16a = 2u16 ; printLn ( toString ( uint16a )); var uint16b : UInt16 = 3u16 ; printLn ( toString ( uint16b )); endfunction function main () // assigning various unsigned integer types var uint32a = 0u32 ; printLn ( toString ( uint32a )); var uint32b : UInt32 = 1u32 ; printLn ( toString ( uint32b )); var uint64a = 2u64 ; printLn ( toString ( uint64a )); var uint64b : UInt64 = 3u64 ; printLn ( toString ( uint64b )); endfunction","title":"Integers"},{"location":"ledger/etch-language/variables/#32-byte-unsigned-integer","text":"Build a UInt256 from a UInt64 literal, like this: function main () var uint256 = UInt256 ( 100u64 ); printLn ( toString ( uint256 )); endfunction UInt256 variables are printed in hexadecimal for brevity.","title":"32 byte unsigned integer"},{"location":"ledger/etch-language/variables/#fixed-point-decimals","text":"Low and high precision calculations can be performed by the use of Fixed point types. Fixed point variables are available as Fixed32 , Fixed64 and Fixed128 types. Fixed point types use half of the high bits for the integer part and the low half bits for the fractional part. More specifically the split is done as following: Type Integer bits Fractional bits Fixed32 16 16 Fixed64 32 32 Fixed128 64 64 You must declare Fixed Point variables with the postfix literals fp32 , fp64 and fp128 . function main () var fixed32bit : Fixed32 = 32.1f p32 ; var fixed64bit : Fixed64 = 64.1f p64 ; var fixed128bit : Fixed128 = 64.1f p128 ; printLn ( toString ( fixed32bit )); printLn ( toString ( fixed64bit )); printLn ( toString ( fixed128bit )); endfunction For brevity, you do not need the full declaration. function main () var fixed32bit = - 32.0f p32 ; var fixed64bit = - 64.0f p64 ; var fixed128bit = - 128.0f p128 ; printLn ( toString ( fixed32bit )); printLn ( toString ( fixed64bit )); printLn ( toString ( fixed128bit )); endfunction Make sure you are aware of the precision limits for fixed point decimals in etch . Type Minimum value Maximum value Fixed32 -32766.9999 32766.9999 Fixed64 -2147483646.999999999 2147483646.999999999 Fixed128 -9223372036854775806.10000000000000000000 9223372036854775806.10000000000000000000 For up to date information tolerance, maximum exponent, and number of decimal places for fixed point types, please check the comments .","title":"Fixed point decimals"},{"location":"ledger/etch-language/variables/#boolean","text":"Declare and initialise Bool types as follows: function main () var myFBool : Bool = false ; var myTBool : Bool = true ; printLn ( toString ( myFBool )); printLn ( toString ( myTBool )); endfunction","title":"Boolean"},{"location":"ledger/etch-language/variables/#strings","text":"Declare and initialise strings as follows: function main () var myString : String = \"hello\" ; var myInferredString = \"hello again\" ; var x : String = null ; printLn ( myString ); printLn ( myInferredString ); printLn ( myInferredString + \" \" + myString ); printLn ( x ); endfunction Find out more about etch Strings here .","title":"Strings"},{"location":"ledger/etch-language/variables/#arrays","text":"You must explicitly declare array element types and array size. Array<Type>(size) declares an array with elements of type Type and size size . function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( toString ( myArray [ 3 ])); for ( i in 0 : 5 ) printLn ( toString ( myArray [ i ])); endfor printLn ( myArray ); endfunction Find out more about etch Arrays here .","title":"Arrays"},{"location":"ledger/etch-language/variables/#buffer","text":"Create a Buffer byte array type like this, where the Buffer size is defined by a UInt32 type. function main () var myBuffer = Buffer ( 8 ); endfunction A Buffer is the medium for data transport/exchange between other types, such as SHA256 and UInt256 . A parallel representation is the Array<UInt8> type.","title":"Buffer"},{"location":"ledger/etch-language/variables/#maps","text":"Declare the dictionary Map type with Map<KeyType, ValueType>() . A duplicate key overrides the previous duplicate entry. The function count() returns an Int32 value representing the number of entries in the Map . function main () var myMap = Map < String , Int32 > (); myMap [ \"balance1\" ] = 1000 ; myMap [ \"balance2\" ] = 2000 ; myMap [ \"balance3\" ] = 3000 ; printLn ( toString ( myMap [ \"balance1\" ])); printLn ( toString ( myMap [ \"balance2\" ])); printLn ( toString ( myMap [ \"balance3\" ])); printLn ( toString ( myMap . count ())); endfunction Note Coming soon: common `Map` operations.","title":"Maps"},{"location":"ledger/etch-language/variables/#structureddata","text":"StructuredData is another Map type containing key/value pairs. Declare a StructuredData type with var variable_name = StructuredData(); . Add key/value pairs with the variable_name.set(key, value); function. There is no appreciable size limit. Keys must be strings. No duplicate keys allowed. A duplicate key overrides the previous duplicate entry. Values can be any primitive, string, or array of primitives. An important difference to the Map type is that a StructuredData type can generate yaml , json , or similar. function main () var data = StructuredData (); data . set ( \"key1\" , 200 i32 ); data . set ( \"key2\" , 500u64 ); data . set ( \"key3\" , \"hello world\" ); printLn ( toString ( data . getInt32 ( \"key1\" ))); printLn ( toString ( data . getUInt64 ( \"key2\" ))); printLn ( data . getString ( \"key3\" )); endfunction","title":"StructuredData"},{"location":"ledger/etch-language/variables/#state","text":"A State is a data structure used by etch smart contracts for storing and querying data on the Fetch.ai Ledger shards. Unique identifiers for the ledger data are created at State construction time. These are unique to the smart contract alone. Declare and initialise a State type with State<ValueType>(\"ledger_identifier\") . function main () var myState = State<Int32> ( \"account\" ) ; endfunction Getters and setters are available for State types. In the example, values set with the set() function map to the unique ledger identifier account . function main () var myState = State < Int32 > ( \"account\" ); myState . set ( 10 ); printLn ( \"My state var value = \" + toString ( myState . get ())); endfunction Find out more about etch States here .","title":"State"},{"location":"ledger/etch-language/variables/#shardedstate","text":"Like State , a ShardedState is also used for reading and writing data to the Fetch.ai Ledger. ShardedState manipulates State types behind the scenes but, for etch programmer purposes, a ShardedState operates like a Map with key/value pairs. Keys must be either String or Address types. Value types are declared at construction time. No duplicate keys allowed. A duplicate key overrides the previous duplicate entry. Declare and initialise a ShardedState . var my_sharded_state = ShardedState < ValueType > ( \"ledger_identifier\" ) Call set() on it to create a key/value pair. Print a value using get() with a key and a default value. function main () var myShardedState = ShardedState < Int32 > ( \"account1\" ); myShardedState . set ( \"salary\" , 45000 i32 ); printLn ( toString ( myShardedState . get ( \"salary\" , 0 i32 ))); endfunction Find out more about etch ShardedState types here .","title":"ShardedState"},{"location":"ledger/etch-language/variables/#address","text":"The cryptographic Address type is currently represented by a 64 byte binary canonical ECDSA public key which is then base 58 encoded. Declare and initialise an Address like this: function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); endfunction Find out more about the etch Address type here .","title":"Address"},{"location":"ledger/etch-language/variables/#mathematical-ml-and-ai","text":"etch provides powerful mathematical, machine learning, and AI specific data types and functions. For more details on the mathematical computation functions above, please check the section on maths functions here . For more details on the machine learning implementations, please check the section on machine learning functions here .","title":"Mathematical, ML, and AI"},{"location":"ledger/etch-language/variables/#type-casting","text":"There is no implicit type casting in etch . If you need a specific non-default numerical type, you can make an explicit cast of the default Int32 and Fixed64 types. Use to<Type>Name(variable_to_cast) . function main () // signed 32 bit integer type var int32bit = 42 ; // cast to Int8 var int8Variable = toInt8 ( int32bit ); // cast to Int16 var int16Variable = toInt16 ( int32bit ); // cast to Int64 var int64Variable = toInt64 ( int32bit ); // cast to UInt8 var uint8Variable = toUInt8 ( int32bit ); // cast to UInt16 var uint16Variable = toUInt16 ( int32bit ); // cast to UInt32 var uint32Variable = toUInt32 ( int32bit ); // cast to UInt64 var uint64Variable = toUInt64 ( int32bit ); // cast to UInt256 // var uint256Variable = toUInt256(int32bit); // coming soon // fixed point casting var fixed32 : Fixed32 = 32.1f p32 ; var fixed64 : Fixed64 = 64.1f p64 ; // cast Fixed32 to Int32 var int32var = toInt32 ( fixed32 ); // cast Fixed64 to Fixed32 var fixed32Variable = toFixed32 ( fixed64 ); // cast Int32 to Fixed64 var fixed64variable = toFixed64 ( int32bit ); // cast to string var stringVariable = toString ( int32bit ); endfunction","title":"Type casting"},{"location":"ledger/etch-language/variables/#data-size","text":"In the table below, we detail the memory size of each data type. Warning Currently, the const value cannot be given precisely and varies depending on whether we are talking about in-memory or in-permanent size. For more information on the integer size ranges, please see the MessagePack specification . Type Memory size Int8 1-2 byte Int16 1-3 bytes Int32 1-5 bytes Int64 1-9 bytes UInt8 1-2 byte UInt16 1-3 bytes UInt32 1-5 bytes UInt64 1-9 bytes UInt256 32 bytes Fixed32 4 bytes Fixed64 8 bytes Fixed128 16 bytes Bool 1 byte String len(string) + const Array len(Array<Type>) * sizeof(Type) + const Map len(Map<K, V>) * (sizeof(KeyType) + sizeof(ValueType)) + const StructuredData len(StructuredData<K, V>) * (sizeof(KeyType) + sizeof(ValueType)) + const State sizeof(Type) + const ShardedState len(ShardedState<K, V>) * (sizeof(KeyType) + sizeof(ValueType)) + const Address 32 bytes","title":"Data size"},{"location":"ledger/etch-language/variables/#scope","text":"etch scripts have no traditional global variables. They do, however, have persistent global types that represent any State or ShardedState type residing on the Fetch.ai Ledger. Find out more about persistent global types here.","title":"Scope"},{"location":"ledger/etch-language/variables/#null","text":"Reference types can be set to null. function main () // var myInt = null ; // error: unable to infer type var str : String = null ; var myArray : Array < Int32 > = null ; var myMap : Map < Int32 , Int32 > = null ; var myState : State < Int32 > = null ; var myAddress : Address = null ; var myString : String = null ; printLn ( myString ); // (nullptr) endfunction","title":"Null"},{"location":"ledger/etch-language/variables/#default-values","text":"Certain types not explicitly initialised receive a default value. Type Default value Int8 0 Int16 0 Int32 0 Int64 0 UInt8 0 UInt16 0 UInt32 0 UInt64 0 UInt256 tbc Fixed32 0.0 Fixed64 0.0 Fixed128 0.0 Bool false String no default","title":"Default values"},{"location":"ledger/etch-language/examples/dft/","text":"function main () var inreal = Array < Fixed64 > ( 1000 ); var inimag = Array < Fixed64 > ( 1000 ); var outreal = Array < Fixed64 > ( 1000 ); var outimag = Array < Fixed64 > ( 1000 ); for ( i in 0 : inreal . count ()) inreal [ i ] = toFixed64 ( rand ( 0 , 1000 )); inimag [ i ] = toFixed64 ( rand ( 0 , 1000 )); endfor dft ( inreal , inimag , outreal , outimag ); //printLn(inreal); //printLn(inimag); //printLn(outreal); //printLn(outimag); endfunction function dft ( inreal : Array < Fixed64 > , inimag : Array < Fixed64 > , outreal : Array < Fixed64 > , outimag : Array < Fixed64 > ) var n = inreal . count (); var angle = 0.0f p64 ; for ( k in 0 : n ) var sumreal = 0.0f p64 ; var sumimag = 0.0f p64 ; for ( t in 0 : n ) angle = 2.0f p64 * 3.142f p64 * toFixed64 ( t ) * toFixed64 ( k ) / toFixed64 ( n ); sumreal += inreal [ t ] * cos ( angle ) + inimag [ t ] * sin ( angle ); sumimag += - inreal [ t ] * sin ( angle ) + inimag [ t ] * cos ( angle ); endfor outreal [ k ] = sumreal ; outimag [ k ] = sumimag ; endfor endfunction","title":"Discrete Fourier Transformation"},{"location":"ledger/etch-language/examples/fetch-logo/","text":"Drawing the Fetch logo function main () // printLn ( \"Hello, everyone. Let's do some drawing.\" ); // // Some messing about to test something; the for range of 0:0 (start/end) means we // can't *not* iterate, which is worthy of discussion. for ( i in 0 : 0 ) // printLn(\"A-TEST: Wish we didn't see this - \" + toString(i)); endfor for ( i in 0 : 1 ) // printLn(\"B-TEST: And this should be once, but it's twice - \" + toString(i)); endfor // // Declare logo array (for string building) and the starting values: var fetchLogo = Array < Int32 > ( 64 * 64 ); var leftAmount : Int32 = 60 ; var rightAmount : Int32 = 0 ; // // Flip flop does an aspect ratio correction if enabled: var flipFlop : Bool = false ; var enableFlipFlop : Bool = true ; for ( y in 0 : 63 ) // // Reset the array line, then add left and right with space between: for ( i in 0 : 63 ) fetchLogo [ i ] = 0 ; endfor for ( leftBit in 0 : leftAmount ) fetchLogo [ leftBit ] = 1 ; endfor var cursor = leftAmount + 3 ; for ( rightBit in 0 : rightAmount ) // -- see discussion point in header fetchLogo [ cursor + rightBit ] = 1 ; endfor // // Adjust for next line: leftAmount -- ; rightAmount ++ ; // // Now render the line, skipping every other if we're in that // mode: if ( false == enableFlipFlop || ( enableFlipFlop && flipFlop )) var logoLine : String = \"\" ; for ( stringIndex in 0 : 63 ) if ( 0 == fetchLogo [ stringIndex ]) logoLine = logoLine + \" \" ; else logoLine = logoLine + \"*\" ; endif endfor printLn ( logoLine ); endif // // Invert flipflop for next iteration: flipFlop = ! flipFlop ; endfor endfunction","title":"Fetch logo"},{"location":"ledger/etch-language/examples/mandelbrot/","text":"Drawing the Mandelbrot set // TWS, April 28th, Mandelbrot Set (simple version): function main () // printLn ( \"Mandelbrot Set\" ); // // The \"screen\" size and the screen itself (double height for mirrored set): var xMax : Int32 = 100 ; var yMax : Int32 = 32 ; var halfOffset : Int32 = yMax * xMax ; var screen = Array < String > ( xMax * ( yMax * 2 )); var maxIterations : Int32 = 230 ; var maxSprites : Fixed64 = 32.0f p64 ; // // Draw the mandelbrot set: for ( pixelY in 0 : yMax - 1 ) for ( pixelX in 0 : xMax - 1 ) // // Scale X to mandlebrot scale (x -2.5 to 1): var xLocal : Fixed64 = toFixed64 ( pixelX ); xLocal = (( xLocal / toFixed64 ( xMax )) * 3.5f p64 ) - 2.5f p64 ; // // Now Y to -1 to 1: var yLocal : Fixed64 = toFixed64 ( pixelY ); yLocal = yLocal / toFixed64 ( yMax ); // // Now let's do the algorithm bit: var x : Fixed64 = 0.0f p64 ; var y : Fixed64 = 0.0f p64 ; var iteration : Int32 = 0 ; while ((( x * x ) + ( y * y )) <= 4.0f p64 && iteration < maxIterations ) var xTemp = ( x * x ) - ( y * y ) + xLocal ; y = 2.0f p64 * x * y + yLocal ; x = xTemp ; iteration ++ ; endwhile // // Render based on iteration achieved: var colourSlide : Fixed64 = ( toFixed64 ( iteration ) / toFixed64 ( maxIterations )); var colourIndex : Int32 = toInt32 ( colourSlide * maxSprites ); // // Pick a character according to colourIndex (iterations achieved): var insertCharacter : String = \" \" ; if ( colourIndex < 2 ) insertCharacter = \" \" ; elseif ( colourIndex < 6 ) insertCharacter = \".\" ; elseif ( colourIndex < 10 ) insertCharacter = \"'\" ; elseif ( colourIndex < 20 ) insertCharacter = \"+\" ; else insertCharacter = \"*\" ; endif // // Bottom half of mandlebrot set: var bIndex : Int32 = halfOffset + ( pixelY * xMax ) + pixelX ; screen [ bIndex ] = insertCharacter ; // // Top mirror half: var inverseY = yMax - pixelY ; var tIndex : Int32 = ( inverseY * xMax ) + pixelX ; screen [ tIndex ] = insertCharacter ; endfor endfor // // Render the buffer out: for ( y in 0 : ( yMax * 2 ) - 1 ) var line : String = \"\" ; for ( x in 0 : xMax - 1 ) // // Build the line, deal with my own stupidity with the screen array // by testing for NULL: var index : Int32 = ( y * xMax ) + x ; if ( screen [ index ] == null ) line = line + \" \" ; else line = line + screen [ index ]; endif endfor // // Output this line and proceed to next: printLn ( line ); endfor endfunction","title":"Mandelbrot"},{"location":"ledger/etch-language/examples/searching-algorithms/","text":"Creating a search algorithm Linear search function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; var search_for = 48 ; var found : Bool ; found = linear_search ( myArray , search_for ); printLn ( toString ( search_for ) + \" is in the list? : \" + toString ( found )); endfunction function linear_search ( an_array : Array < Int32 > , search_for : Int32 ) : Bool var found : Bool = false ; for ( i in 0 : an_array . count ()) if ( an_array [ i ] == search_for ) found = true ; endif endfor return found ; endfunction Binary search function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; var search_for = 40 ; var found : Bool ; found = binary_search ( myArray , search_for ); printLn ( toString ( search_for ) + \" is in the list? : \" + toString ( found )); endfunction function binary_search ( an_array : Array < Int32 > , search_for : Int32 ) : Bool var start = 0 ; var end = an_array . count (); var found : Bool = false ; while ( start < end && found == false ) var midpoint = ( start + end ) / 2 ; if ( search_for == an_array [ midpoint ] ) found = true ; elseif ( search_for < an_array [ midpoint ] ) end = midpoint - 1 ; else start = midpoint + 1 ; endif endwhile return found ; endfunction","title":"Searching algorithms"},{"location":"ledger/etch-language/examples/searching-algorithms/#linear-search","text":"function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; var search_for = 48 ; var found : Bool ; found = linear_search ( myArray , search_for ); printLn ( toString ( search_for ) + \" is in the list? : \" + toString ( found )); endfunction function linear_search ( an_array : Array < Int32 > , search_for : Int32 ) : Bool var found : Bool = false ; for ( i in 0 : an_array . count ()) if ( an_array [ i ] == search_for ) found = true ; endif endfor return found ; endfunction","title":"Linear search"},{"location":"ledger/etch-language/examples/searching-algorithms/#binary-search","text":"function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; var search_for = 40 ; var found : Bool ; found = binary_search ( myArray , search_for ); printLn ( toString ( search_for ) + \" is in the list? : \" + toString ( found )); endfunction function binary_search ( an_array : Array < Int32 > , search_for : Int32 ) : Bool var start = 0 ; var end = an_array . count (); var found : Bool = false ; while ( start < end && found == false ) var midpoint = ( start + end ) / 2 ; if ( search_for == an_array [ midpoint ] ) found = true ; elseif ( search_for < an_array [ midpoint ] ) end = midpoint - 1 ; else start = midpoint + 1 ; endif endwhile return found ; endfunction","title":"Binary search"},{"location":"ledger/etch-language/examples/sorting-algorithms/","text":"Designing a sorting algorithm Bubble sort function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 41 ; myArray [ 1 ] = 40 ; myArray [ 2 ] = 43 ; myArray [ 3 ] = 44 ; myArray [ 4 ] = 42 ; print ( \"Unsorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); bubble_sort ( myArray ); print ( \"Sorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); endfunction function bubble_sort ( an_array : Array < Int32 > ) var more_swaps : Bool = true ; while ( more_swaps == true ) more_swaps = false ; for ( i in 0 : an_array . count () - 1 ) if ( an_array [ i ] > an_array [ i + 1 ]) more_swaps = true ; var temp = an_array [ i ]; an_array [ i ] = an_array [ i + 1 ]; an_array [ i + 1 ] = temp ; endif endfor endwhile endfunction Insertion sort function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 41 ; myArray [ 1 ] = 40 ; myArray [ 2 ] = 43 ; myArray [ 3 ] = 44 ; myArray [ 4 ] = 42 ; print ( \"Unsorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); insertion_sort ( myArray ); print ( \"Sorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); endfunction function insertion_sort ( an_array : Array < Int32 > ) for ( index in 1 : an_array . count ()) var currentvalue = an_array [ index ]; var position = index ; while (( position >= 1 ) && ( an_array [ position - 1 ] > currentvalue )) an_array [ position ] = an_array [ position - 1 ]; position = position - 1 ; endwhile an_array [ position ] = currentvalue ; endfor endfunction Merge sort function main () // needs to be an even number length var a_list = Array < UInt32 > ( 15 ); for ( i in 0 : a_list . count ()) a_list [ i ] = rand ( 0u32 , 1000u32 ); endfor printLn ( a_list ); merge ( a_list ); printLn ( a_list ); endfunction function merge ( a_list : Array < UInt32 > ) // print ( \"Splitting \" ); printLn ( a_list ); if ( a_list . count () > 1 ) var mid = a_list . count () / 2 ; var left_half = Array < UInt32 > ( mid ); var right_half = Array < UInt32 > ( mid ); if ( a_list . count () % 2 != 0 ) right_half = Array < UInt32 > ( mid + 1 ); endif for ( x in 0 : mid ) left_half [ x ] = a_list [ x ]; endfor var count = 0 ; for ( y in mid : a_list . count ()) right_half [ count ] = a_list [ y ]; count += 1 ; endfor // print(\"Left half \"); printLn(left_half); // print(\"Right half \"); printLn(right_half); merge ( left_half ); merge ( right_half ); var i = 0 ; var j = 0 ; var k = 0 ; while ( i < left_half . count () && j < right_half . count ()) if ( left_half [ i ] < right_half [ j ]) a_list [ k ] = left_half [ i ]; i += 1 ; else a_list [ k ] = right_half [ j ]; j += 1 ; endif k = k + 1 ; endwhile while ( i < left_half . count ()) a_list [ k ] = left_half [ i ]; i += 1 ; k += 1 ; endwhile while ( j < right_half . count ()) a_list [ k ] = right_half [ j ]; j += 1 ; k += 1 ; endwhile endif //print(\"Merging \"); printLn(a_list); endfunction Quick sort function main () var a_list = Array < Int32 > ( 15 ); for ( i in 0 : a_list . count ()) a_list [ i ] = rand ( 0 , 1000 ); endfor var n = a_list . count (); printLn ( a_list ); quick_sort ( a_list , 0 , n - 1 ); printLn ( a_list ); endfunction function quick_sort ( a_list : Array < Int32 > , low : Int32 , high : Int32 ) var pi = 0 ; if ( low < high ) // get the partition index pi = partition ( a_list , low , high ); quick_sort ( a_list , low , pi - 1 ); quick_sort ( a_list , pi + 1 , high ); endif endfunction function partition ( a_list : Array < Int32 > , low : Int32 , high : Int32 ) : Int32 var pivot = rand ( low , high ); // swap random pivot with high var temp = a_list [ high ]; a_list [ high ] = a_list [ pivot ]; a_list [ pivot ] = temp ; // track next pivot index var new_pivot_index = low - 1 ; for ( index in low : high ) if ( a_list [ index ] < a_list [ high ]) new_pivot_index = new_pivot_index + 1 ; temp = a_list [ new_pivot_index ]; a_list [ new_pivot_index ] = a_list [ index ]; a_list [ index ] = temp ; endif endfor // swap pivot to new spot temp = a_list [ new_pivot_index + 1 ]; a_list [ new_pivot_index + 1 ] = a_list [ high ]; a_list [ high ] = temp ; return new_pivot_index + 1 ; endfunction","title":"Sorting algorithms"},{"location":"ledger/etch-language/examples/sorting-algorithms/#bubble-sort","text":"function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 41 ; myArray [ 1 ] = 40 ; myArray [ 2 ] = 43 ; myArray [ 3 ] = 44 ; myArray [ 4 ] = 42 ; print ( \"Unsorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); bubble_sort ( myArray ); print ( \"Sorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); endfunction function bubble_sort ( an_array : Array < Int32 > ) var more_swaps : Bool = true ; while ( more_swaps == true ) more_swaps = false ; for ( i in 0 : an_array . count () - 1 ) if ( an_array [ i ] > an_array [ i + 1 ]) more_swaps = true ; var temp = an_array [ i ]; an_array [ i ] = an_array [ i + 1 ]; an_array [ i + 1 ] = temp ; endif endfor endwhile endfunction","title":"Bubble sort"},{"location":"ledger/etch-language/examples/sorting-algorithms/#insertion-sort","text":"function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 41 ; myArray [ 1 ] = 40 ; myArray [ 2 ] = 43 ; myArray [ 3 ] = 44 ; myArray [ 4 ] = 42 ; print ( \"Unsorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); insertion_sort ( myArray ); print ( \"Sorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); endfunction function insertion_sort ( an_array : Array < Int32 > ) for ( index in 1 : an_array . count ()) var currentvalue = an_array [ index ]; var position = index ; while (( position >= 1 ) && ( an_array [ position - 1 ] > currentvalue )) an_array [ position ] = an_array [ position - 1 ]; position = position - 1 ; endwhile an_array [ position ] = currentvalue ; endfor endfunction","title":"Insertion sort"},{"location":"ledger/etch-language/examples/sorting-algorithms/#merge-sort","text":"function main () // needs to be an even number length var a_list = Array < UInt32 > ( 15 ); for ( i in 0 : a_list . count ()) a_list [ i ] = rand ( 0u32 , 1000u32 ); endfor printLn ( a_list ); merge ( a_list ); printLn ( a_list ); endfunction function merge ( a_list : Array < UInt32 > ) // print ( \"Splitting \" ); printLn ( a_list ); if ( a_list . count () > 1 ) var mid = a_list . count () / 2 ; var left_half = Array < UInt32 > ( mid ); var right_half = Array < UInt32 > ( mid ); if ( a_list . count () % 2 != 0 ) right_half = Array < UInt32 > ( mid + 1 ); endif for ( x in 0 : mid ) left_half [ x ] = a_list [ x ]; endfor var count = 0 ; for ( y in mid : a_list . count ()) right_half [ count ] = a_list [ y ]; count += 1 ; endfor // print(\"Left half \"); printLn(left_half); // print(\"Right half \"); printLn(right_half); merge ( left_half ); merge ( right_half ); var i = 0 ; var j = 0 ; var k = 0 ; while ( i < left_half . count () && j < right_half . count ()) if ( left_half [ i ] < right_half [ j ]) a_list [ k ] = left_half [ i ]; i += 1 ; else a_list [ k ] = right_half [ j ]; j += 1 ; endif k = k + 1 ; endwhile while ( i < left_half . count ()) a_list [ k ] = left_half [ i ]; i += 1 ; k += 1 ; endwhile while ( j < right_half . count ()) a_list [ k ] = right_half [ j ]; j += 1 ; k += 1 ; endwhile endif //print(\"Merging \"); printLn(a_list); endfunction","title":"Merge sort"},{"location":"ledger/etch-language/examples/sorting-algorithms/#quick-sort","text":"function main () var a_list = Array < Int32 > ( 15 ); for ( i in 0 : a_list . count ()) a_list [ i ] = rand ( 0 , 1000 ); endfor var n = a_list . count (); printLn ( a_list ); quick_sort ( a_list , 0 , n - 1 ); printLn ( a_list ); endfunction function quick_sort ( a_list : Array < Int32 > , low : Int32 , high : Int32 ) var pi = 0 ; if ( low < high ) // get the partition index pi = partition ( a_list , low , high ); quick_sort ( a_list , low , pi - 1 ); quick_sort ( a_list , pi + 1 , high ); endif endfunction function partition ( a_list : Array < Int32 > , low : Int32 , high : Int32 ) : Int32 var pivot = rand ( low , high ); // swap random pivot with high var temp = a_list [ high ]; a_list [ high ] = a_list [ pivot ]; a_list [ pivot ] = temp ; // track next pivot index var new_pivot_index = low - 1 ; for ( index in low : high ) if ( a_list [ index ] < a_list [ high ]) new_pivot_index = new_pivot_index + 1 ; temp = a_list [ new_pivot_index ]; a_list [ new_pivot_index ] = a_list [ index ]; a_list [ index ] = temp ; endif endfor // swap pivot to new spot temp = a_list [ new_pivot_index + 1 ]; a_list [ new_pivot_index + 1 ] = a_list [ high ]; a_list [ high ] = temp ; return new_pivot_index + 1 ; endfunction","title":"Quick sort"},{"location":"ledger/examples/block-number/","text":"Run the following Python script and embedded smart contract to test the getBlockNumber() function. You need to run this against a running node on localhost port 8100 . Details for running a node are here . from fetchai . ledger . api import LedgerApi from fetchai . ledger . contract import SmartContract from fetchai . ledger . crypto import Entity , Address CONTRACT_TEXT = \"\"\" @ action function set_block_number_state () State < UInt64 > ( ' block_number_state ' ). set ( getBlockNumber ()); endfunction @ query function query_block_number_state () : UInt64 return State < UInt64 > ( ' block_number_state ' ). get ( 0u64 ); endfunction \"\"\" def main () : entity1 = Entity () # build the ledger API api = LedgerApi ( ' 127.0.0.1 ' , 8100 ) # create wealth so that we have the funds to be able to create contracts on the network api . sync ( api . tokens . wealth ( entity1 , 100000 )) # create the smart contract contract = SmartContract ( CONTRACT_TEXT ) # deploy the contract to the network api . sync ( api . contracts . create ( entity1 , contract , 2000 )) api . sync ( contract . action ( api , ' set_block_number_state ' , 400 , [ entity1 ])) print ( contract . query ( api , ' query_block_number_state ' )) if __name__ == ' __main__ ' : main ()","title":"Block number"},{"location":"ledger/installation/installation-mac/","text":"Installing and building the ledger on Mac Supported platforms MacOS Darwin 10.13x and higher (64bit) Initial setup Get homebrew: /usr/bin/ruby -e \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install ) \" Install dependencies: brew install cmake openssl git python Or with MacPorts: port install cmake openssl git python If you use homebrew , edit your ~/.bash_profile : export OPENSSL_ROOT_DIR = \"/usr/local/Cellar/openssl/`ls /usr/local/Cellar/openssl/ | sort | tail -1`\" Add the git alias: git config --global alias.pullall '!f(){ git pull \"$@\" && git submodule sync --recursive && git submodule update --init --recursive; }; f' Download the ledger code If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.9.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation. Build the ledger From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the etch library: make etch Possible gotchas To avoid issues with OpenSSL, run the following: cmake -DOPENSSL_ROOT_DIR = /usr/local/ssl -DOPENSSL_LIBRARIES = /usr/local/ssl/lib","title":"MacOS"},{"location":"ledger/installation/installation-mac/#installing-and-building-the-ledger-on-mac","text":"","title":"Installing and building the ledger on Mac"},{"location":"ledger/installation/installation-mac/#supported-platforms","text":"MacOS Darwin 10.13x and higher (64bit)","title":"Supported platforms"},{"location":"ledger/installation/installation-mac/#initial-setup","text":"Get homebrew: /usr/bin/ruby -e \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install ) \" Install dependencies: brew install cmake openssl git python Or with MacPorts: port install cmake openssl git python If you use homebrew , edit your ~/.bash_profile : export OPENSSL_ROOT_DIR = \"/usr/local/Cellar/openssl/`ls /usr/local/Cellar/openssl/ | sort | tail -1`\" Add the git alias: git config --global alias.pullall '!f(){ git pull \"$@\" && git submodule sync --recursive && git submodule update --init --recursive; }; f'","title":"Initial setup"},{"location":"ledger/installation/installation-mac/#download-the-ledger-code","text":"If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.9.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation.","title":"Download the ledger code"},{"location":"ledger/installation/installation-mac/#build-the-ledger","text":"From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the etch library: make etch","title":"Build the ledger"},{"location":"ledger/installation/installation-mac/#possible-gotchas","text":"To avoid issues with OpenSSL, run the following: cmake -DOPENSSL_ROOT_DIR = /usr/local/ssl -DOPENSSL_LIBRARIES = /usr/local/ssl/lib","title":"Possible gotchas"},{"location":"ledger/installation/installation-redhat/","text":"Installing and building the ledger on Linux Redhat Initial setup Set environment variables: export CC = clang export CXX = clang++ Install dependencies: yum install -y sudo yum install -y make yum install -y cmake yum install -y libpng-devel yum install -y zlib-devel yum install -y openssl-devel yum install -y python36-devel ( replace 36 with your version of Python3 ) yum install -y clang yum install -y epel-release ( dnf install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm ) yum install -y python-pip ( prb. already installed ) yum install -y git pip2 install --upgrade pip pip3 install --upgrade pip pip install --upgrade cldoc yum install -y autoconf yum install -y automake yum install -y wget yum install -y which yum install -y tree Download the ledger code If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.9.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation. Build the ledger From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the etch library: make etch","title":"Redhat"},{"location":"ledger/installation/installation-redhat/#installing-and-building-the-ledger-on-linux-redhat","text":"","title":"Installing and building the ledger on Linux Redhat"},{"location":"ledger/installation/installation-redhat/#initial-setup","text":"Set environment variables: export CC = clang export CXX = clang++ Install dependencies: yum install -y sudo yum install -y make yum install -y cmake yum install -y libpng-devel yum install -y zlib-devel yum install -y openssl-devel yum install -y python36-devel ( replace 36 with your version of Python3 ) yum install -y clang yum install -y epel-release ( dnf install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm ) yum install -y python-pip ( prb. already installed ) yum install -y git pip2 install --upgrade pip pip3 install --upgrade pip pip install --upgrade cldoc yum install -y autoconf yum install -y automake yum install -y wget yum install -y which yum install -y tree","title":"Initial setup"},{"location":"ledger/installation/installation-redhat/#download-the-ledger-code","text":"If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.9.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation.","title":"Download the ledger code"},{"location":"ledger/installation/installation-redhat/#build-the-ledger","text":"From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the etch library: make etch","title":"Build the ledger"},{"location":"ledger/installation/installation-ubuntu/","text":"Installing and building the ledger on Linux Ubuntu Initial setup Set environment variables in /etc/profile : export CC = clang export CXX = clang++ Update: sudo apt-get update Install dependencies: apt-get install build-essential clang git cmake libssl-dev doxygen python3-dev python3-pip python3-venv Update: sudo apt-get update Add the git alias: git config --global alias.pullall '!f(){ git pull \"$@\" && git submodule sync --recursive && git submodule update --init --recursive; }; f' Download the ledger code If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.9.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation. Build the ledger From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the etch library: make etch","title":"Ubuntu"},{"location":"ledger/installation/installation-ubuntu/#installing-and-building-the-ledger-on-linux-ubuntu","text":"","title":"Installing and building the ledger on Linux Ubuntu"},{"location":"ledger/installation/installation-ubuntu/#initial-setup","text":"Set environment variables in /etc/profile : export CC = clang export CXX = clang++ Update: sudo apt-get update Install dependencies: apt-get install build-essential clang git cmake libssl-dev doxygen python3-dev python3-pip python3-venv Update: sudo apt-get update Add the git alias: git config --global alias.pullall '!f(){ git pull \"$@\" && git submodule sync --recursive && git submodule update --init --recursive; }; f'","title":"Initial setup"},{"location":"ledger/installation/installation-ubuntu/#download-the-ledger-code","text":"If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.9.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation.","title":"Download the ledger code"},{"location":"ledger/installation/installation-ubuntu/#build-the-ledger","text":"From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the etch library: make etch","title":"Build the ledger"},{"location":"ledger/machine-learning/","text":"Machine Learning Fetch.ai has developed a machine learning library that is a generalised toolkit for building and running these type of applications on distributed ledger nodes. This means neural networks can be trained and run on or off chain depending on what is needed for your application. Machine learning operations may be invoked with the Etch language, used to write smart contracts native to the Fetch.ai platform. Like PyTorch and TensorFlow the library focuses on building, training, and running computational graphs, in order to implement neural networks for deep learning. In contrast with these frameworks, the Fetch.ai machine learning library is fully compatible with integer mathematics, implemented with Etch FixedPoint data types (and Tensors containing them). As a result, every neural network and complex mathematical operation in the library will produce numerically identical results across any hardware and software architecture. This means that every machine learning operation taking place on the ledger will be verifiable by every other node in the network. If you are new to Etch, the language used to write smart contracts native to the Fetch.ai platform, the quickstart section demonstrates how to train and run a neural network. This can be useful for trying out ideas, or simply using the Fetch.ai machine learning library for standalone applications. To extend this further we need to understand how to train or run a neural net on-chain. This smart contract example demonstrates how to rework this neural network to train and run on chain. Finally, this synergetic contract example covers synergetic contracts; this is useful for coordinating between on-chain and off-chain work. This is great for executing expensive computations off-chain but coordinating/managing the work on-chain.","title":"Introduction"},{"location":"ledger/machine-learning/#machine-learning","text":"Fetch.ai has developed a machine learning library that is a generalised toolkit for building and running these type of applications on distributed ledger nodes. This means neural networks can be trained and run on or off chain depending on what is needed for your application. Machine learning operations may be invoked with the Etch language, used to write smart contracts native to the Fetch.ai platform. Like PyTorch and TensorFlow the library focuses on building, training, and running computational graphs, in order to implement neural networks for deep learning. In contrast with these frameworks, the Fetch.ai machine learning library is fully compatible with integer mathematics, implemented with Etch FixedPoint data types (and Tensors containing them). As a result, every neural network and complex mathematical operation in the library will produce numerically identical results across any hardware and software architecture. This means that every machine learning operation taking place on the ledger will be verifiable by every other node in the network. If you are new to Etch, the language used to write smart contracts native to the Fetch.ai platform, the quickstart section demonstrates how to train and run a neural network. This can be useful for trying out ideas, or simply using the Fetch.ai machine learning library for standalone applications. To extend this further we need to understand how to train or run a neural net on-chain. This smart contract example demonstrates how to rework this neural network to train and run on chain. Finally, this synergetic contract example covers synergetic contracts; this is useful for coordinating between on-chain and off-chain work. This is great for executing expensive computations off-chain but coordinating/managing the work on-chain.","title":"Machine Learning"},{"location":"ledger/machine-learning/basic-etch-example/","text":"AI in Etch The etch language is used for executing applications in the Fetch VM, which is required for writing smart contracts on the Fetch Ledger. Writing machine learning applications in the etch language should be familiar for developers with machine learning experience in other frameworks. Let's look at an example of training a fully connected neural net to predict house prices for the boston housing dataset. Boston Housing Price Prediction function main () // read in training and test data if ( System . Argc () != 5 ) print ( \"Usage: SCRIPT_FILE -- PATH/TO/BOSTON_TRAIN_DATA.CSV PATH/TO/BOSTON_TRAIN_LABELS.CSV PATH/TO/BOSTON_TEST_DATA.CSV PATH/TO/BOSTON_TEST_LABELS.CSV \" ); return ; endif var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); // set up a model architecture var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); // train the model var batch_size = 10u64 ; model . fit ( data , label , batch_size ); // evaluate performance var loss = model . evaluate (); // make predictions on all test data var predictions = model . predict ( test_data ); endfunction Above is code example for an etch script that trains a fully connected model on csv's read in from the command line. We can break it down into the following steps: Load in some data files. In this case we use the Boston Housing Dataset . Define a sequential model with three fully connected layers. Compile the model, specifying the loss function and optimiser. Train the model by fitting it to the training data. Evaluate performance on the model Make a prediction on the test data Let's take a closer look. Setup the etch vm If you haven't yet run an etch script, make sure you can do so from the console. Instructions are here . Input file check First, the code checks for the correct the number of input files. if ( System . Argc () != 5 ) print ( \"Usage: SCRIPT_FILE -- PATH/TO/BOSTON_TRAIN_DATA.CSV PATH/TO/BOSTON_TRAIN_LABELS.CSV PATH/TO/BOSTON_TEST_DATA.CSV PATH/TO/BOSTON_TEST_LABELS.CSV \" ); return ; endif Load the input data Next, we load the input data from the files. var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); Set up the model First, we create a Model type and set a flag on it that describes what kind of Model we want. The sequential model allows us to manually add the layers. We then add our layers to the model specifying the layer type ('dense'), input size (must match the data for the first layer), neurons in layer / output size (must match the label size for the final layer), and lastly an optional activation type (here we use a rectified linear unit for the first two layers, and no activation for the final layer). Finally, we compile the model using the 'mean squared error' loss function, and the 'adam' optimiser. var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); Train the model Training the model once set up is easy; we just call fit with the data, labels, and chosen batch size. var batch_size = 10u64 ; model . fit ( data , label , batch_size ); Evaluate the model Evaluating the model will, by default, return the training loss; but other metrics may be specified. var loss = model . evaluate (); Make predictions on the model Finally we make house price predictions by passing in the test data. Since the test_data contains input data for multiple houses, the output tensor contains multiple predictions. var predictions = model . predict ( test_data ); Run the script Run the script from the ledger repo adding the input files as input arguments with the following. . / etch boston - training . etch -- 1 st - file 2 nd - file 3 rd - file 4 th - file","title":"AI in Etch"},{"location":"ledger/machine-learning/basic-etch-example/#ai-in-etch","text":"The etch language is used for executing applications in the Fetch VM, which is required for writing smart contracts on the Fetch Ledger. Writing machine learning applications in the etch language should be familiar for developers with machine learning experience in other frameworks. Let's look at an example of training a fully connected neural net to predict house prices for the boston housing dataset.","title":"AI in Etch"},{"location":"ledger/machine-learning/basic-etch-example/#boston-housing-price-prediction","text":"function main () // read in training and test data if ( System . Argc () != 5 ) print ( \"Usage: SCRIPT_FILE -- PATH/TO/BOSTON_TRAIN_DATA.CSV PATH/TO/BOSTON_TRAIN_LABELS.CSV PATH/TO/BOSTON_TEST_DATA.CSV PATH/TO/BOSTON_TEST_LABELS.CSV \" ); return ; endif var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); // set up a model architecture var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); // train the model var batch_size = 10u64 ; model . fit ( data , label , batch_size ); // evaluate performance var loss = model . evaluate (); // make predictions on all test data var predictions = model . predict ( test_data ); endfunction Above is code example for an etch script that trains a fully connected model on csv's read in from the command line. We can break it down into the following steps: Load in some data files. In this case we use the Boston Housing Dataset . Define a sequential model with three fully connected layers. Compile the model, specifying the loss function and optimiser. Train the model by fitting it to the training data. Evaluate performance on the model Make a prediction on the test data Let's take a closer look.","title":"Boston Housing Price Prediction"},{"location":"ledger/machine-learning/basic-etch-example/#setup-the-etch-vm","text":"If you haven't yet run an etch script, make sure you can do so from the console. Instructions are here .","title":"Setup the etch vm"},{"location":"ledger/machine-learning/basic-etch-example/#input-file-check","text":"First, the code checks for the correct the number of input files. if ( System . Argc () != 5 ) print ( \"Usage: SCRIPT_FILE -- PATH/TO/BOSTON_TRAIN_DATA.CSV PATH/TO/BOSTON_TRAIN_LABELS.CSV PATH/TO/BOSTON_TEST_DATA.CSV PATH/TO/BOSTON_TEST_LABELS.CSV \" ); return ; endif","title":"Input file check"},{"location":"ledger/machine-learning/basic-etch-example/#load-the-input-data","text":"Next, we load the input data from the files. var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 ));","title":"Load the input data"},{"location":"ledger/machine-learning/basic-etch-example/#set-up-the-model","text":"First, we create a Model type and set a flag on it that describes what kind of Model we want. The sequential model allows us to manually add the layers. We then add our layers to the model specifying the layer type ('dense'), input size (must match the data for the first layer), neurons in layer / output size (must match the label size for the final layer), and lastly an optional activation type (here we use a rectified linear unit for the first two layers, and no activation for the final layer). Finally, we compile the model using the 'mean squared error' loss function, and the 'adam' optimiser. var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" );","title":"Set up the model"},{"location":"ledger/machine-learning/basic-etch-example/#train-the-model","text":"Training the model once set up is easy; we just call fit with the data, labels, and chosen batch size. var batch_size = 10u64 ; model . fit ( data , label , batch_size );","title":"Train the model"},{"location":"ledger/machine-learning/basic-etch-example/#evaluate-the-model","text":"Evaluating the model will, by default, return the training loss; but other metrics may be specified. var loss = model . evaluate ();","title":"Evaluate the model"},{"location":"ledger/machine-learning/basic-etch-example/#make-predictions-on-the-model","text":"Finally we make house price predictions by passing in the test data. Since the test_data contains input data for multiple houses, the output tensor contains multiple predictions. var predictions = model . predict ( test_data );","title":"Make predictions on the model"},{"location":"ledger/machine-learning/basic-etch-example/#run-the-script","text":"Run the script from the ledger repo adding the input files as input arguments with the following. . / etch boston - training . etch -- 1 st - file 2 nd - file 3 rd - file 4 th - file","title":"Run the script"},{"location":"ledger/machine-learning/getting-started/","text":"Using the machine learning library Let's look at an example of how to use the Fetch.ai machine learning library to train a neural network in a standalone application. This example will predict house prices for the Boston Housing Dataset, which can be downloaded from here . The implementation is based on the Etch language , which is also used to write smart contracts on the Fetch.ai ledger; you saw a very brief example in the previous section. Instructions to set up an Etch development environment can be found here . Loading input data An Etch program running outside of a ledger environment needs a main() function as its entry point. Note Please include all the code snippets listed below inside the main() function. Since the input is provided via multiple CSV files, the main() function firstly has to check the correct number of files is provided, then load the input data from them: function main () if ( System . Argc () != 5 ) print ( \"Usage: SCRIPT_FILE -- PATH/TO/BOSTON_TRAIN_DATA.CSV PATH/TO/BOSTON_TRAIN_LABELS.CSV PATH/TO/BOSTON_TEST_DATA.CSV PATH/TO/BOSTON_TEST_LABELS.CSV \" ); return ; endif var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); endfunction Setting up the model We then create a Model type and set a flag on it that describes what kind of Model we want. A sequential model allows us to manually add layers specifying: Type: dense in this example refers to a fully-connected layer where every neuron in the layer is connected to every input and every output. Input size: must match the data for the first layer Neurons in layer / output size: must match the label size for the final layer Activation type (optional): here we use a rectified linear unit for the first two layers, and no activation for the final layer Finally, we compile the model using the mse (mean squared error) loss function, and the adam optimiser. var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); Training and evaluating the model Training the model once set up is easy: we just call fit with the data, labels, and chosen batch size. var batch_size = 10u64 ; model . fit ( data , label , batch_size ); Evaluating the model will return the training loss by default, but other metrics may be specified. var loss = model . evaluate (); Making predictions on the model Finally, we make house price predictions by passing in the test data. Since test_data contains input data for multiple houses, the output tensor contains multiple predictions. var predictions = model . predict ( test_data ); Running the script The script can be run from the root of the ledger folder, passing the input files as arguments with the following: ./etch boston-training.etch -- 1st-file 2nd-file 3rd-file 4th-file","title":"Getting started"},{"location":"ledger/machine-learning/getting-started/#using-the-machine-learning-library","text":"Let's look at an example of how to use the Fetch.ai machine learning library to train a neural network in a standalone application. This example will predict house prices for the Boston Housing Dataset, which can be downloaded from here . The implementation is based on the Etch language , which is also used to write smart contracts on the Fetch.ai ledger; you saw a very brief example in the previous section. Instructions to set up an Etch development environment can be found here .","title":"Using the machine learning library"},{"location":"ledger/machine-learning/getting-started/#loading-input-data","text":"An Etch program running outside of a ledger environment needs a main() function as its entry point. Note Please include all the code snippets listed below inside the main() function. Since the input is provided via multiple CSV files, the main() function firstly has to check the correct number of files is provided, then load the input data from them: function main () if ( System . Argc () != 5 ) print ( \"Usage: SCRIPT_FILE -- PATH/TO/BOSTON_TRAIN_DATA.CSV PATH/TO/BOSTON_TRAIN_LABELS.CSV PATH/TO/BOSTON_TEST_DATA.CSV PATH/TO/BOSTON_TEST_LABELS.CSV \" ); return ; endif var data = readCSV ( System . Argv ( 1 )); var label = readCSV ( System . Argv ( 2 )); var test_data = readCSV ( System . Argv ( 3 )); var test_label = readCSV ( System . Argv ( 4 )); endfunction","title":"Loading input data"},{"location":"ledger/machine-learning/getting-started/#setting-up-the-model","text":"We then create a Model type and set a flag on it that describes what kind of Model we want. A sequential model allows us to manually add layers specifying: Type: dense in this example refers to a fully-connected layer where every neuron in the layer is connected to every input and every output. Input size: must match the data for the first layer Neurons in layer / output size: must match the label size for the final layer Activation type (optional): here we use a rectified linear unit for the first two layers, and no activation for the final layer Finally, we compile the model using the mse (mean squared error) loss function, and the adam optimiser. var model = Model ( \"sequential\" ); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" );","title":"Setting up the model"},{"location":"ledger/machine-learning/getting-started/#training-and-evaluating-the-model","text":"Training the model once set up is easy: we just call fit with the data, labels, and chosen batch size. var batch_size = 10u64 ; model . fit ( data , label , batch_size ); Evaluating the model will return the training loss by default, but other metrics may be specified. var loss = model . evaluate ();","title":"Training and evaluating the model"},{"location":"ledger/machine-learning/getting-started/#making-predictions-on-the-model","text":"Finally, we make house price predictions by passing in the test data. Since test_data contains input data for multiple houses, the output tensor contains multiple predictions. var predictions = model . predict ( test_data );","title":"Making predictions on the model"},{"location":"ledger/machine-learning/getting-started/#running-the-script","text":"The script can be run from the root of the ledger folder, passing the input files as arguments with the following: ./etch boston-training.etch -- 1st-file 2nd-file 3rd-file 4th-file","title":"Running the script"},{"location":"ledger/machine-learning/library-architecture/","text":"Machine Learning library architecture The following block diagram shows the inheritance structure for some of the key components of the ML library. Note This is work in progress. Graph Graph represents a computational graph made up of nodes. A Graph must be a directed acyclic graph (DAG). Therefore, when adding nodes, the inputs to the nodes must be specified and must never result in a cycle. Graph manages saving and loading existing graph states (a state dictionary) and checking for node name collisions. Nodes are positions in the graph which know from which other nodes to draw inputs. They are able to perform forward and backward computation according to a particular operation, or Op . Each node is associated with a particular Op and this defines the specifics of what happens whenever the forward or backward methods are called. Often the forward method calls upon an existing maths function from the maths library; for example the addition Op called on the maths library implementation of Add . The backward method computes the gradient associated with the forward operation given a particular error signal. Ops To inject data into the computational Graph , special Ops are required that can have data assigned to them. These are placeholders. Weights are a specialisation of placeholders in that the data assigned to them is randomly initialised and their data is trainable via back-propagation. Finally there may be further specialisations of weights, such as embeddings, that offer additional functionality with respect to accessing and updating the data. Layers Layers , which inherit from SubGraphs , are wrappers around multiple Ops that are commonly repeated. For example, a fully connected layer which wraps the dot product between the weights and the input tensor, followed by the addition of the bias tensor, and possibly also followed by an activation function. DataLoaders DataLoaders manage input training data when training the weights in the neural network. They are responsible for parsing data into a format compatible with the rest of the machine learning library and then sampling the data for training and testing. A specific DataLoader is often needed for each machine learning problem, as input data formats will tend to vary. However, the DataLoader abstract class mandates the necessary methods for all DataLoaders . Integer mathematics The use of floats and doubles on different architectures is almost always going to result in tiny differences at extremely high levels of precision for two main reasons: The IEEE 754 standard for floating-point arithmetic does not guarantee that the same program will deliver identical results on all conforming systems The C++ standard does not enforce IEEE 754 For many applications this is no problem. However, the Fetch.ai ledger will be computing and storing the results of complex mathematical operations in smart contracts, and these results will be cryptographically hashed. These hashes will need to be absolutely identical on every architecture attempting to verify them. This is not possible with existing machine learning frameworks. In order to overcome this issue, the machine learning library is compatible with Etch FixedPoint data types and Tensors built with them. FixedPoint data types implement integer mathematics, guaranteeing identical results on different architectures. Notes for working with the C++ machine learning library Every Op must have a DESCRIPTOR . This generates a unique node name when name collisions are detected in a graph. It is also used for logging/error reporting. Node names are not guaranteed to be identical to the input string specified by the developer on AddNode . This is because the graph automatically resolves name collisions such that every node is uniquely named. The function ComputeOutputShape for classes that inherit from Ops is expensive and should only be used for initialisation or in ASSERT . On Forward you can use output.shape() instead and for Backward there is error_signal.shape() . Batch dimension is always trailing dimension. If you work with a single data point, it needs to have trailing dimension of size 1. DataLoaders are designed to return a pair of {Label,{Data}} where Data are in vector.","title":"Architecture"},{"location":"ledger/machine-learning/library-architecture/#machine-learning-library-architecture","text":"The following block diagram shows the inheritance structure for some of the key components of the ML library. Note This is work in progress.","title":"Machine Learning library architecture"},{"location":"ledger/machine-learning/library-architecture/#graph","text":"Graph represents a computational graph made up of nodes. A Graph must be a directed acyclic graph (DAG). Therefore, when adding nodes, the inputs to the nodes must be specified and must never result in a cycle. Graph manages saving and loading existing graph states (a state dictionary) and checking for node name collisions. Nodes are positions in the graph which know from which other nodes to draw inputs. They are able to perform forward and backward computation according to a particular operation, or Op . Each node is associated with a particular Op and this defines the specifics of what happens whenever the forward or backward methods are called. Often the forward method calls upon an existing maths function from the maths library; for example the addition Op called on the maths library implementation of Add . The backward method computes the gradient associated with the forward operation given a particular error signal.","title":"Graph"},{"location":"ledger/machine-learning/library-architecture/#ops","text":"To inject data into the computational Graph , special Ops are required that can have data assigned to them. These are placeholders. Weights are a specialisation of placeholders in that the data assigned to them is randomly initialised and their data is trainable via back-propagation. Finally there may be further specialisations of weights, such as embeddings, that offer additional functionality with respect to accessing and updating the data.","title":"Ops"},{"location":"ledger/machine-learning/library-architecture/#layers","text":"Layers , which inherit from SubGraphs , are wrappers around multiple Ops that are commonly repeated. For example, a fully connected layer which wraps the dot product between the weights and the input tensor, followed by the addition of the bias tensor, and possibly also followed by an activation function.","title":"Layers"},{"location":"ledger/machine-learning/library-architecture/#dataloaders","text":"DataLoaders manage input training data when training the weights in the neural network. They are responsible for parsing data into a format compatible with the rest of the machine learning library and then sampling the data for training and testing. A specific DataLoader is often needed for each machine learning problem, as input data formats will tend to vary. However, the DataLoader abstract class mandates the necessary methods for all DataLoaders .","title":"DataLoaders"},{"location":"ledger/machine-learning/library-architecture/#integer-mathematics","text":"The use of floats and doubles on different architectures is almost always going to result in tiny differences at extremely high levels of precision for two main reasons: The IEEE 754 standard for floating-point arithmetic does not guarantee that the same program will deliver identical results on all conforming systems The C++ standard does not enforce IEEE 754 For many applications this is no problem. However, the Fetch.ai ledger will be computing and storing the results of complex mathematical operations in smart contracts, and these results will be cryptographically hashed. These hashes will need to be absolutely identical on every architecture attempting to verify them. This is not possible with existing machine learning frameworks. In order to overcome this issue, the machine learning library is compatible with Etch FixedPoint data types and Tensors built with them. FixedPoint data types implement integer mathematics, guaranteeing identical results on different architectures.","title":"Integer mathematics"},{"location":"ledger/machine-learning/library-architecture/#notes-for-working-with-the-c-machine-learning-library","text":"Every Op must have a DESCRIPTOR . This generates a unique node name when name collisions are detected in a graph. It is also used for logging/error reporting. Node names are not guaranteed to be identical to the input string specified by the developer on AddNode . This is because the graph automatically resolves name collisions such that every node is uniquely named. The function ComputeOutputShape for classes that inherit from Ops is expensive and should only be used for initialisation or in ASSERT . On Forward you can use output.shape() instead and for Backward there is error_signal.shape() . Batch dimension is always trailing dimension. If you work with a single data point, it needs to have trailing dimension of size 1. DataLoaders are designed to return a pair of {Label,{Data}} where Data are in vector.","title":"Notes for working with the C++ machine learning library"},{"location":"ledger/machine-learning/smart-contract-example/","text":"AI in Smart Contracts The quickstart example demonstrates how to train and execute neural networks in the Etch language locally. This example focuses on reworking that example as a smart contract that can be executed entirely on-chain. // initial set up creates the model and persistent data @ init function setup ( owner : Address ) use model_state ; var model = model_state . get ( Model ( \"sequential\" )); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); model_state . set ( model ); endfunction // pass in some data, train the model with it, save the updated model to state @ action function train ( data : Tensor , label : Tensor ) use model_state ; var model = model_state . get (); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); model_state . set ( model ); endfunction // get the current training loss of the model @ query function evaluate () : Tensor use model_state ; var model = model_state . get (); var loss = model . evaluate (); return loss ; endfunction // make a prediction with the model based on input data passed to function @ query function predict ( data : Tensor ) : Tensor use model_state ; var model = model_state . get (); var prediction = model . predict ( data ); return prediction ; endfunction Above is a simple smart contract for setting up the same neural network as before to make predictions on the boston housing data set. The main differences from the previous etch example are: persistent storage seperately callable functions function decorators Persistent storage The ledger maintains a state database for smart contracts to store objects. In this example we indicate our intention to access the model in the state database with use model_state , we store our model in the state database using set() , and we recover it for use with get() . It's important to consider carefully what make sense to store in the state database, and what should be managed locally. A full explanation of persistent storage is given here . Separately callable functions In this example the train , evaluate , and predict functions are all separately callable. This allows users to contribute to training the model, or utilise the model for prediction independently. Function decorators Finally, this example utilises the function decorators @init , @action , and @query . @init specifies the function to execute when the contract is first registered, this ensures that the model is created upon construction. After this subsequent @action and @query functions may be invoked, the former of which are permitted to read and write to the state database, whereas the latter may only read from it; this is useful because it allows model predictions to be made 'between blocks', whereas training and updating the model would need to be written to the state database and would hence occur only when each new block is added. Advanced customisation With these new tools we can rewrite this smart contract to be more efficient, depending on what we wish to accomplish. For example, if we expect various agents to occassionally provide new data, but we want to train the model asynchronously with these data dumps, we might want to store that data in a state, and define a separate function for training the model that reads the previously stored data from state; e.g. // set input data @ action function setData ( in_data : String ) use data_state ; var data = data_state . get (); data . fromString ( in_data ); endfunction // set label @ action function setLabel ( in_label : String ) use label_state ; var label = label_state . get (); label . fromString ( in_label ); endfunction // load data and label from state and train the model with it @ action function train () use model_state ; use data_state ; use label_state ; var model = model_state . get (); var data = data_state . get (); var label = label_state . get (); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); model_state . set ( model ); endfunction Similarly, it may be too expensive to train the model on-chain, and we may instead wish to simply over-write the model with one we have trained off-chain. This is also easily accomplishable: // set input data @ action function setModel ( in_model : String ) use model_state ; var model = model_state . get (); model = model . deserializeFromString ( in_model ); model_state . set ( model ); endfunction To take this idea further, we may wish to perform most of the expensive work off-chain but automate/manage it on-chain. This would be an ideal application for a synergetic contract .","title":"AI in smart contracts"},{"location":"ledger/machine-learning/smart-contract-example/#ai-in-smart-contracts","text":"The quickstart example demonstrates how to train and execute neural networks in the Etch language locally. This example focuses on reworking that example as a smart contract that can be executed entirely on-chain. // initial set up creates the model and persistent data @ init function setup ( owner : Address ) use model_state ; var model = model_state . get ( Model ( \"sequential\" )); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); model_state . set ( model ); endfunction // pass in some data, train the model with it, save the updated model to state @ action function train ( data : Tensor , label : Tensor ) use model_state ; var model = model_state . get (); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); model_state . set ( model ); endfunction // get the current training loss of the model @ query function evaluate () : Tensor use model_state ; var model = model_state . get (); var loss = model . evaluate (); return loss ; endfunction // make a prediction with the model based on input data passed to function @ query function predict ( data : Tensor ) : Tensor use model_state ; var model = model_state . get (); var prediction = model . predict ( data ); return prediction ; endfunction Above is a simple smart contract for setting up the same neural network as before to make predictions on the boston housing data set. The main differences from the previous etch example are: persistent storage seperately callable functions function decorators","title":"AI in Smart Contracts"},{"location":"ledger/machine-learning/smart-contract-example/#persistent-storage","text":"The ledger maintains a state database for smart contracts to store objects. In this example we indicate our intention to access the model in the state database with use model_state , we store our model in the state database using set() , and we recover it for use with get() . It's important to consider carefully what make sense to store in the state database, and what should be managed locally. A full explanation of persistent storage is given here .","title":"Persistent storage"},{"location":"ledger/machine-learning/smart-contract-example/#separately-callable-functions","text":"In this example the train , evaluate , and predict functions are all separately callable. This allows users to contribute to training the model, or utilise the model for prediction independently.","title":"Separately callable functions"},{"location":"ledger/machine-learning/smart-contract-example/#function-decorators","text":"Finally, this example utilises the function decorators @init , @action , and @query . @init specifies the function to execute when the contract is first registered, this ensures that the model is created upon construction. After this subsequent @action and @query functions may be invoked, the former of which are permitted to read and write to the state database, whereas the latter may only read from it; this is useful because it allows model predictions to be made 'between blocks', whereas training and updating the model would need to be written to the state database and would hence occur only when each new block is added.","title":"Function decorators"},{"location":"ledger/machine-learning/smart-contract-example/#advanced-customisation","text":"With these new tools we can rewrite this smart contract to be more efficient, depending on what we wish to accomplish. For example, if we expect various agents to occassionally provide new data, but we want to train the model asynchronously with these data dumps, we might want to store that data in a state, and define a separate function for training the model that reads the previously stored data from state; e.g. // set input data @ action function setData ( in_data : String ) use data_state ; var data = data_state . get (); data . fromString ( in_data ); endfunction // set label @ action function setLabel ( in_label : String ) use label_state ; var label = label_state . get (); label . fromString ( in_label ); endfunction // load data and label from state and train the model with it @ action function train () use model_state ; use data_state ; use label_state ; var model = model_state . get (); var data = data_state . get (); var label = label_state . get (); var batch_size = 10u64 ; model . fit ( data , label , batch_size ); model_state . set ( model ); endfunction Similarly, it may be too expensive to train the model on-chain, and we may instead wish to simply over-write the model with one we have trained off-chain. This is also easily accomplishable: // set input data @ action function setModel ( in_model : String ) use model_state ; var model = model_state . get (); model = model . deserializeFromString ( in_model ); model_state . set ( model ); endfunction To take this idea further, we may wish to perform most of the expensive work off-chain but automate/manage it on-chain. This would be an ideal application for a synergetic contract .","title":"Advanced customisation"},{"location":"ledger/machine-learning/synergetic-contract-example/","text":"AI in Synergetic Contracts The previous example demonstrated how to train and execute neural networks in a smart contract. That's useful if you want to set up fully on-chain machine learning, but it also allows you to perform the compute intensive parts of the work off-chain and then load the model directly into smart contract state and use it to make predictions on-chain (trading off a certain amount of model transparency for efficiency/cost). In this example we'll take this even further with a synergetic contract; this allows off-chain components of work to be specified in the contract. This could be extremely valuable if, for example, you wanted to set up a competition or auction in a contract where miners could take part to do expensive work training a machine learning model in exchange for a chance at winning the rewrad. Then the resulting best model could be uploaded onto the ledger for all to use. Simple Synergetic Contract Note This developer documentation is a work in progress. If you spot any errors please open an issue [here](https://github.com/fetchai/docs). // set up a problem around training a machine learning model @ problem function createProblem ( data : Tensor , label : Tensor ) use model_state ; use data_state ; use label_state ; var model = model_state . get ( Model ( \"sequential\" )); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); model_state . set ( model ); endfunction // evaluates performance as the loss function of the model after training @ objective function evaluateWork ( in_model : String ) use model_state ; var model = model_state . get (); model . fromString ( in_model ); return model . evaluate (); endfunction // the work of training the model @ objective function doWork ( in_model : String , nonce : UInt256 ) : String use model_state ; use data_state ; use label_state ; var model = model_state . get (); model . fromString ( in_model ); // update the learning rate of the local model var lr = nonce . toFixed64 () % 1.0f p64 ; model . setLearningRate ( lr ); // train the model var batch_size = 10u64 ; var data = data_state . get (); var label = label_state . get (); model . fit ( data , label , batch_size ); // return the serialised model return model . toString (); endfunction // set the new model to be the specified winner @ clear function applyWork ( in_model : String ) use model_state ; var model = model_state . get (); model . fromString ( in_model ); model_state . set ( model ); endfunction // make a prediction with the model based on input data passed to function @ query function predict ( data : Tensor ) : Tensor use model_state ; var model = model_state . get (); var prediction = model . predict ( data ); return prediction ; endfunction // query the current model performance @ query function evaluate () : Tensor use model_state ; var model = model_state . get (); return model . evaluate (); endfunction A common machine learning task that requires parallelisation is the hyper-parameter search phase. Engineers will perform this when they understand the general architecture/approach that they want to take to produce a machine laerning model, but they don't know the best combination of hyper-parameters (such as learning rate, regularisation settings, dropout rates, etc.). Often the best solution is to simple try out many different combinations of parameters and find out what seems to have worked well; this is called hyper-parameter search. Above is a trivial example of a synergetic contract for setting up a competition where multiple miners can take part in hyper-parameter search in order to receive rewards for their work. Here we attempt to train the same boston housing regression neural network as in the prior examples but with one key difference: each miner that wishes to take part invokes doWork which has the result of using a unique nonce for determining the learning rate at which they train the model. In a serious implementation we would likely have many hyperparameters to search over and sensible ranges and resolutions for each hyper-parameter. We might also add further sophistication such as building into the contract an algorithm for guiding a random walk through hyper-parameter space across miners. Hopefully, however, this example serves to illustrate what is possible on the fetch ledger with synergetic contracts. To learn more about synergetic contracts take a look at this further documentation .","title":"AI in synergetic contracts"},{"location":"ledger/machine-learning/synergetic-contract-example/#ai-in-synergetic-contracts","text":"The previous example demonstrated how to train and execute neural networks in a smart contract. That's useful if you want to set up fully on-chain machine learning, but it also allows you to perform the compute intensive parts of the work off-chain and then load the model directly into smart contract state and use it to make predictions on-chain (trading off a certain amount of model transparency for efficiency/cost). In this example we'll take this even further with a synergetic contract; this allows off-chain components of work to be specified in the contract. This could be extremely valuable if, for example, you wanted to set up a competition or auction in a contract where miners could take part to do expensive work training a machine learning model in exchange for a chance at winning the rewrad. Then the resulting best model could be uploaded onto the ledger for all to use.","title":"AI in Synergetic Contracts"},{"location":"ledger/machine-learning/synergetic-contract-example/#simple-synergetic-contract","text":"Note This developer documentation is a work in progress. If you spot any errors please open an issue [here](https://github.com/fetchai/docs). // set up a problem around training a machine learning model @ problem function createProblem ( data : Tensor , label : Tensor ) use model_state ; use data_state ; use label_state ; var model = model_state . get ( Model ( \"sequential\" )); model . add ( \"dense\" , 13u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 10u64 , \"relu\" ); model . add ( \"dense\" , 10u64 , 1u64 ); model . compile ( \"mse\" , \"adam\" ); model_state . set ( model ); endfunction // evaluates performance as the loss function of the model after training @ objective function evaluateWork ( in_model : String ) use model_state ; var model = model_state . get (); model . fromString ( in_model ); return model . evaluate (); endfunction // the work of training the model @ objective function doWork ( in_model : String , nonce : UInt256 ) : String use model_state ; use data_state ; use label_state ; var model = model_state . get (); model . fromString ( in_model ); // update the learning rate of the local model var lr = nonce . toFixed64 () % 1.0f p64 ; model . setLearningRate ( lr ); // train the model var batch_size = 10u64 ; var data = data_state . get (); var label = label_state . get (); model . fit ( data , label , batch_size ); // return the serialised model return model . toString (); endfunction // set the new model to be the specified winner @ clear function applyWork ( in_model : String ) use model_state ; var model = model_state . get (); model . fromString ( in_model ); model_state . set ( model ); endfunction // make a prediction with the model based on input data passed to function @ query function predict ( data : Tensor ) : Tensor use model_state ; var model = model_state . get (); var prediction = model . predict ( data ); return prediction ; endfunction // query the current model performance @ query function evaluate () : Tensor use model_state ; var model = model_state . get (); return model . evaluate (); endfunction A common machine learning task that requires parallelisation is the hyper-parameter search phase. Engineers will perform this when they understand the general architecture/approach that they want to take to produce a machine laerning model, but they don't know the best combination of hyper-parameters (such as learning rate, regularisation settings, dropout rates, etc.). Often the best solution is to simple try out many different combinations of parameters and find out what seems to have worked well; this is called hyper-parameter search. Above is a trivial example of a synergetic contract for setting up a competition where multiple miners can take part in hyper-parameter search in order to receive rewards for their work. Here we attempt to train the same boston housing regression neural network as in the prior examples but with one key difference: each miner that wishes to take part invokes doWork which has the result of using a unique nonce for determining the learning rate at which they train the model. In a serious implementation we would likely have many hyperparameters to search over and sensible ranges and resolutions for each hyper-parameter. We might also add further sophistication such as building into the contract an algorithm for guiding a random walk through hyper-parameter space across miners. Hopefully, however, this example serves to illustrate what is possible on the fetch ledger with synergetic contracts. To learn more about synergetic contracts take a look at this further documentation .","title":"Simple Synergetic Contract"},{"location":"ledger/python-ledger-api/python-api-install/","text":"Build the Python libraries like this: pip3 install -U fetchai-ledger-api Or, download and install the Python library which interacts with a running ledger node. git clone git@github.com:fetchai/ledger-api-py.git -b release/v0.9.x Tip Make sure you are on the latest release branch in order to have the latest features. Install the library with the following command: cd ledger - api - py / python3 setup . py install Find out how to build a smart contract using the Python API here .","title":"Installation"},{"location":"ledger/python-ledger-api/examples/block-number/","text":"Run the following Python script and embedded smart contract to test the getBlockNumber() function. You need to run this against a running node on localhost port 8100 . Details for running a node are here . from fetchai . ledger . api import LedgerApi from fetchai . ledger . contract import SmartContract from fetchai . ledger . crypto import Entity , Address CONTRACT_TEXT = \"\"\" @ action function set_block_number_state () State < UInt64 > ( ' block_number_state ' ). set ( getBlockNumber ()); endfunction @ query function query_block_number_state () : UInt64 return State < UInt64 > ( ' block_number_state ' ). get ( 0u64 ); endfunction \"\"\" def main () : entity1 = Entity () # build the ledger API api = LedgerApi ( ' 127.0.0.1 ' , 8100 ) # create wealth so that we have the funds to be able to create contracts on the network api . sync ( api . tokens . wealth ( entity1 , 100000 )) # create the smart contract contract = SmartContract ( CONTRACT_TEXT ) # deploy the contract to the network api . sync ( api . contracts . create ( entity1 , contract , 2000 )) api . sync ( contract . action ( api , ' set_block_number_state ' , 400 , [ entity1 ])) print ( contract . query ( api , ' query_block_number_state ' )) if __name__ == ' __main__ ' : main ()","title":"Block Number"},{"location":"ledger/smart-contracts/etch-smart-contracts/","text":"Etch smart contracts Smart contract code runs on the etch virtual machine. All ledger nodes contain the etch VM and smart contract code. The identity of a smart contract is calculated by performing a SHA256 hash on the contract code string as an initial step. Next, a further SHA256 hash is calculated from the previous result concatenated with a public key Address which represents the contract owner. On the ledger, the etch VM stores the contract identity, the contract source code, and the data resources that are mapped by a data.json file. With this information, the etch VM performs a modulo 16 calculation to decide where to store the data on the ledger, i.e. onto which shard. Note Coming soon: details on how developers may dictate the sharding storage design for a smart contract. Smart contract addresses etch smart contracts have a unique identification protocol for addressing on the Fetch.ai Ledger. etch smart contract identifiers are a SHA256 hash of the contract source code which is then Base64 encoded and finally concatenated with the Base64 encoded owner's public key. Using this identifier, smart contract functions are accessible with a subsequent . plus function name. Data confirmation If you run an etch contract in the simulator containing one or more State types and flag the compiler with -data and a filename, it will create a json file containing the details of the data that will be stored on the ledger. ./etch *filename* -data data.json If we run one of the above code examples in this way, data.json may contain the following: { \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" : \"8403000000000000\" }","title":"Smart contracts in Etch"},{"location":"ledger/smart-contracts/etch-smart-contracts/#smart-contract-addresses","text":"etch smart contracts have a unique identification protocol for addressing on the Fetch.ai Ledger. etch smart contract identifiers are a SHA256 hash of the contract source code which is then Base64 encoded and finally concatenated with the Base64 encoded owner's public key. Using this identifier, smart contract functions are accessible with a subsequent . plus function name.","title":"Smart contract addresses"},{"location":"ledger/smart-contracts/etch-smart-contracts/#data-confirmation","text":"If you run an etch contract in the simulator containing one or more State types and flag the compiler with -data and a filename, it will create a json file containing the details of the data that will be stored on the ledger. ./etch *filename* -data data.json If we run one of the above code examples in this way, data.json may contain the following: { \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" : \"8403000000000000\" }","title":"Data confirmation"},{"location":"ledger/smart-contracts/executing-smart-contract-code/","text":"Executing smart contract code Locally To run smart contract code on your local machine, first download, build, and run a ledger node. You can find out how to do that here . If you have previously been running ledger constellation nodes, you should remove the databases as they will be incompatible with a fresh node. rm *.db Build the Python API libraries like this: pip3 install -U fetchai-ledger-api Simple transfer example in Python If you want to examine the code in more detail and look at some examples, you may prefer to clone or download the repo. git clone https://github.com/fetchai/ledger-api-py.git And run the installation script: python3 ledger-api-py/setup.py install In your favourite Python IDE, open the create_and_send.py script in the examples directory. This script creates two Entity objects, sets a balance of 1000 tokens on your_identity , and makes a transfer to other_identity . from fetchai.ledger.api import LedgerApi from fetchai.ledger.crypto import Identity , Entity HOST = '127.0.0.1' PORT = 8100 def main (): # create the APIs api = LedgerApi ( HOST , PORT ) # generate a random identity your_identity = Entity () other_identity = Entity () print ( 'Balance Before:' , api . tokens . balance ( your_identity )) # create the balance print ( 'Submitting wealth creation...' ) api . sync ( api . tokens . wealth ( your_identity , 1000 )) print ( 'Balance after wealth:' , api . tokens . balance ( your_identity )) # submit and wait for the transfer to be complete print ( 'Submitting transfer...' ) api . sync ( api . tokens . transfer ( your_identity , other_identity , 250 , 20 )) print ( 'Balance 1:' , api . tokens . balance ( your_identity )) print ( 'Balance 2:' , api . tokens . balance ( other_identity )) if __name__ == '__main__' : main () Tip Make sure you have the correct port number for the running ledger node. You should see the following results when running the script. Balance Before: 0 Submitting wealth creation... Balance after wealth: 1000 Submitting transfer... Balance 1 : 749 Balance 2 : 250 Embedding contract code Smart contract code is embedded into a Python script as a string. The smart contract below resembles the contracts.py script in the examples folder, except the State definitions are in line with etch updates. from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import SmartContract from fetchai.ledger.crypto import Entity , Address CONTRACT_TEXT = \"\"\" @init function setup(owner : Address) var owner_balance = State<UInt64>(owner); owner_balance.set(1000000u64); endfunction @action function transfer(from: Address, to: Address, amount: UInt64) // define the accounts var from_account = State<UInt64>(from); var to_account = State<UInt64>(to); // if new sets to 0u // Check if the sender has enough balance to proceed if (from_account.get(0u64) >= amount) // update the account balances from_account.set(from_account.get(0u64) - amount); to_account.set(to_account.get(0u64) + amount); endif endfunction @query function balance(address: Address) : UInt64 var account = State<UInt64>(address); return account.get(0u64); endfunction \"\"\" From here, you can create a Python SmartContract type and feed it the contract string. Then deploy the contract with the Python LedgerApi . The code below takes the CONTRACT_TEXT string above and deploys it to the ledger along with details of the contract owner and the fee. # create the smart contract contract = SmartContract ( CONTRACT_TEXT ) # deploy the contract to the network api . sync ( api . contracts . create ( owner , contract , 2000 )) Public keys Generate a public key for your smart contract, or Agent , with the Entity class in the Python API crypto package which generates a full private/public key object having a number of useful functions available on it. Instantiate an Entity object and wrap it in an Address type to generate the public key. from fetchai.ledger.crypto import Entity , Address entity = Entity () entity_address = Address ( entity ) print ( entity_address ) There are many more functions available for Entity and Address which will be documented in due course. Test network You can run the examples on our test network, replacing the hostname and port. HOST = 'bootstrap.fetch.ai' PORT = 80 However, you will need some FET tokens and an Address . We show you how to get some test FET and set up the Fetch Wallet in the next section. Public network Note In development.","title":"Executing smart contracts"},{"location":"ledger/smart-contracts/executing-smart-contract-code/#locally","text":"To run smart contract code on your local machine, first download, build, and run a ledger node. You can find out how to do that here . If you have previously been running ledger constellation nodes, you should remove the databases as they will be incompatible with a fresh node. rm *.db Build the Python API libraries like this: pip3 install -U fetchai-ledger-api","title":"Locally"},{"location":"ledger/smart-contracts/executing-smart-contract-code/#simple-transfer-example-in-python","text":"If you want to examine the code in more detail and look at some examples, you may prefer to clone or download the repo. git clone https://github.com/fetchai/ledger-api-py.git And run the installation script: python3 ledger-api-py/setup.py install In your favourite Python IDE, open the create_and_send.py script in the examples directory. This script creates two Entity objects, sets a balance of 1000 tokens on your_identity , and makes a transfer to other_identity . from fetchai.ledger.api import LedgerApi from fetchai.ledger.crypto import Identity , Entity HOST = '127.0.0.1' PORT = 8100 def main (): # create the APIs api = LedgerApi ( HOST , PORT ) # generate a random identity your_identity = Entity () other_identity = Entity () print ( 'Balance Before:' , api . tokens . balance ( your_identity )) # create the balance print ( 'Submitting wealth creation...' ) api . sync ( api . tokens . wealth ( your_identity , 1000 )) print ( 'Balance after wealth:' , api . tokens . balance ( your_identity )) # submit and wait for the transfer to be complete print ( 'Submitting transfer...' ) api . sync ( api . tokens . transfer ( your_identity , other_identity , 250 , 20 )) print ( 'Balance 1:' , api . tokens . balance ( your_identity )) print ( 'Balance 2:' , api . tokens . balance ( other_identity )) if __name__ == '__main__' : main () Tip Make sure you have the correct port number for the running ledger node. You should see the following results when running the script. Balance Before: 0 Submitting wealth creation... Balance after wealth: 1000 Submitting transfer... Balance 1 : 749 Balance 2 : 250","title":"Simple transfer example in Python"},{"location":"ledger/smart-contracts/executing-smart-contract-code/#embedding-contract-code","text":"Smart contract code is embedded into a Python script as a string. The smart contract below resembles the contracts.py script in the examples folder, except the State definitions are in line with etch updates. from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import SmartContract from fetchai.ledger.crypto import Entity , Address CONTRACT_TEXT = \"\"\" @init function setup(owner : Address) var owner_balance = State<UInt64>(owner); owner_balance.set(1000000u64); endfunction @action function transfer(from: Address, to: Address, amount: UInt64) // define the accounts var from_account = State<UInt64>(from); var to_account = State<UInt64>(to); // if new sets to 0u // Check if the sender has enough balance to proceed if (from_account.get(0u64) >= amount) // update the account balances from_account.set(from_account.get(0u64) - amount); to_account.set(to_account.get(0u64) + amount); endif endfunction @query function balance(address: Address) : UInt64 var account = State<UInt64>(address); return account.get(0u64); endfunction \"\"\" From here, you can create a Python SmartContract type and feed it the contract string. Then deploy the contract with the Python LedgerApi . The code below takes the CONTRACT_TEXT string above and deploys it to the ledger along with details of the contract owner and the fee. # create the smart contract contract = SmartContract ( CONTRACT_TEXT ) # deploy the contract to the network api . sync ( api . contracts . create ( owner , contract , 2000 ))","title":"Embedding contract code"},{"location":"ledger/smart-contracts/executing-smart-contract-code/#public-keys","text":"Generate a public key for your smart contract, or Agent , with the Entity class in the Python API crypto package which generates a full private/public key object having a number of useful functions available on it. Instantiate an Entity object and wrap it in an Address type to generate the public key. from fetchai.ledger.crypto import Entity , Address entity = Entity () entity_address = Address ( entity ) print ( entity_address ) There are many more functions available for Entity and Address which will be documented in due course.","title":"Public keys"},{"location":"ledger/smart-contracts/executing-smart-contract-code/#test-network","text":"You can run the examples on our test network, replacing the hostname and port. HOST = 'bootstrap.fetch.ai' PORT = 80 However, you will need some FET tokens and an Address . We show you how to get some test FET and set up the Fetch Wallet in the next section.","title":"Test network"},{"location":"ledger/smart-contracts/executing-smart-contract-code/#public-network","text":"Note In development.","title":"Public network"},{"location":"ledger/smart-contracts/executing-synergetic-code/","text":"Executing synergetic contract code Warning Synergetic contracts are currently an experimental feature. To test synergetic contracts, run a ledger node in synergetic mode using specific flags. ./constellation -standalone -block-interval 1000 -experimental synergetic,naive-synergetic-mining In the Python API examples folder, take a look at the synergetic.py script. import os import random import json from fetchai.ledger.api import LedgerApi from fetchai.ledger.crypto import Entity , Address from fetchai.ledger.contract import SynergeticContract CONTRACT_TEXT = \"\"\" @problem function createProblem(data : Array<StructuredData>) : Int32 var value = 0; for (i in 0:data.count()) value += data[i].getInt32(\"value\"); endfor return value; endfunction @objective function evaluateWork(problem : Int32, solution : Int32 ) : Int64 return abs(toInt64(problem) - toInt64(solution)); endfunction @work function doWork(problem : Int32, nonce : UInt256) : Int32 return nonce.toInt32(); endfunction @clear function applyWork(problem : Int32, solution : Int32) var result = State<Int32>(\"solution\"); result.set(solution); endfunction \"\"\" def main (): # create the API api = LedgerApi ( '127.0.0.1' , 8100 ) # create an entity and provide it some wealth print ( 'Setup...' ) entity = Entity () api . sync ( api . tokens . wealth ( entity , 100000000 )) print ( 'Setup...complete' ) # create the contract on the ledger synergy_contract = SynergeticContract ( CONTRACT_TEXT ) print ( synergy_contract . digest ) api . sync ( api . contracts . create ( entity , synergy_contract , 4096 )) # create a whole series of random data to submit to the DAG random_ints = [ random . randint ( 0 , 200 ) for _ in range ( 4000 )] api . sync ([ api . synergetic . submit_data ( entity , synergy_contract . digest , value = value ) for value in random_ints ]) if __name__ == '__main__' : main () In the synergetic contract example above, the @problem function sets up a calculation over an array and returns the value. The @objective function evaluates the work done on the problem giving a measure as to how close the current solution is to the correct result. The @doWork function returns a nonce to kick start the calculations. The @clear function tidies up once a solution has been found and saves the correct result to the ledger.","title":"Executing synergetic contracts"},{"location":"ledger/smart-contracts/fees/","text":"Fetch.ai charges developers for computation and storage of data on the Fetch.ai Ledger in a manner which incentivises good coding practices. With the best use of Fetch.ai Ledger types such as State and ShardedState , you can limit the fees by distributing data storage over a minimum number of shards. Fees rise in a linear manner per number of shards up to the maximum number of shards. Note The following information details the current implementation which is likely to change. Calculating charge units Storing data on the Fetch network costs 2 units per byte. Performing computation on the Fetch network costs 1 unit per operation. TOTAL_UNITS = (( 2 *storage ) + computation ) * number of shards You can find out the total size of etch variables here . Calculating total transaction fee To calculate the transaction fee, multiply the total units by the charge rate given in FET or denominations thereof. TOTAL_FEE = TOTAL_UNITS * CHARGE_RATE The Fetch.ai Ledger uses the charge rate to prioritise the order of the incoming transactions in the same way as the Ethereum and Bitcoin networks do with gas and transaction fees respectively.","title":"Fees"},{"location":"ledger/smart-contracts/fees/#calculating-charge-units","text":"Storing data on the Fetch network costs 2 units per byte. Performing computation on the Fetch network costs 1 unit per operation. TOTAL_UNITS = (( 2 *storage ) + computation ) * number of shards You can find out the total size of etch variables here .","title":"Calculating charge units"},{"location":"ledger/smart-contracts/fees/#calculating-total-transaction-fee","text":"To calculate the transaction fee, multiply the total units by the charge rate given in FET or denominations thereof. TOTAL_FEE = TOTAL_UNITS * CHARGE_RATE The Fetch.ai Ledger uses the charge rate to prioritise the order of the incoming transactions in the same way as the Ethereum and Bitcoin networks do with gas and transaction fees respectively.","title":"Calculating total transaction fee"},{"location":"ledger/smart-contracts/memory/","text":"Memory State and ShardedState store data on the shards that make up the ledger. There are a configurable number of parallel shards on the ledger that accept permanent, irreversible storage. Developers have to pay to store data on ledger shards so they should take care when constructing State and ShardedState types to avoid unnecessary fees. Ensuring that smart contract data is evenly spread across ledger shards is the most efficient and economical way to code and execute smart contracts in etch . The trick is to ensure that etch code avoids taking up too much memory on a single shard or taking up too much memory on too many shards as more memory costs more to deploy. It is possible to exceed etch imposed limits on data storage in which case an etch smart contract will fail. Design considerations You can visualise the ledger shards as a series of swim lanes. Data etches onto a shard depending on the smart contract design. The contents of a State etch onto a single shard on the ledger. For example, function main () var myState1 = State < Int32 > ( \"balance\" ); myState1 . set ( 200 ); endfunction The above integer value may etch onto a shard like this: This is an economical way to manage memory on the ledger shards. However, there are scenarios in which State data etches onto the ledger in an inefficient way. Aggregate functions may store too much data on too many shards on the ledger if coded inappropriately. Code like this can block other users and slow the network. Data fees will reflect this. For example, given a vote() function such as the one below, the code may aggregate the vote tracking State variables in an inefficient manner. function main () vote (); endfunction function vote () // declare and set politics account var race_for_prime_minister = \"hustings\" ; var votes_for = State < Int32 > ( race_for_prime_minister ); votes_for . set ( 0 ); var votes_against = State < Int32 > ( race_for_prime_minister ); votes_against . set ( 0 ); var votes_total = State < Int32 > ( race_for_prime_minister ); votes_total . set ( 0 ); var votes_sum = State < Int32 > ( race_for_prime_minister ); votes_sum . set ( 0 ); // ..and further along.. if ( true ) // update the aggregate votes for votes_for . set ( votes_for . get () + 1 ); else // update the aggregate votes against votes_against . set ( votes_against . get () + 1 ); endif // update the aggregate of total votes votes_sum . set ( votes_total . get () + 1 ); endfunction Each time a State increments, the new data value takes up a new memory space on the shard. The ledger shards could look something like this after the vote() function runs over a short period of time. This is highly uneconomical. Every aggregate value for a single State takes up its own spot on a ledger shard. Furthermore, multiple States take up multiple shards. Data is chargeable per lane in order to disincentivise code like the above which can slow the network. There are better approaches to the voting problem. For example, by encapsulating the data with a ShardedState and performing calculations in functions outside the ledger. function main () vote (); endfunction function vote () var fors = ShardedState < Int32 > ( \"votes_for\" ); fors . set ( \"Alice\" , increment ( fors . get ( \"Alice\" , 0 ))); // etc. endfunction function increment ( x : Int32 ) : Int32 var y = x + 1 ; return y ; endfunction","title":"Memory"},{"location":"ledger/smart-contracts/memory/#design-considerations","text":"You can visualise the ledger shards as a series of swim lanes. Data etches onto a shard depending on the smart contract design. The contents of a State etch onto a single shard on the ledger. For example, function main () var myState1 = State < Int32 > ( \"balance\" ); myState1 . set ( 200 ); endfunction The above integer value may etch onto a shard like this: This is an economical way to manage memory on the ledger shards. However, there are scenarios in which State data etches onto the ledger in an inefficient way. Aggregate functions may store too much data on too many shards on the ledger if coded inappropriately. Code like this can block other users and slow the network. Data fees will reflect this. For example, given a vote() function such as the one below, the code may aggregate the vote tracking State variables in an inefficient manner. function main () vote (); endfunction function vote () // declare and set politics account var race_for_prime_minister = \"hustings\" ; var votes_for = State < Int32 > ( race_for_prime_minister ); votes_for . set ( 0 ); var votes_against = State < Int32 > ( race_for_prime_minister ); votes_against . set ( 0 ); var votes_total = State < Int32 > ( race_for_prime_minister ); votes_total . set ( 0 ); var votes_sum = State < Int32 > ( race_for_prime_minister ); votes_sum . set ( 0 ); // ..and further along.. if ( true ) // update the aggregate votes for votes_for . set ( votes_for . get () + 1 ); else // update the aggregate votes against votes_against . set ( votes_against . get () + 1 ); endif // update the aggregate of total votes votes_sum . set ( votes_total . get () + 1 ); endfunction Each time a State increments, the new data value takes up a new memory space on the shard. The ledger shards could look something like this after the vote() function runs over a short period of time. This is highly uneconomical. Every aggregate value for a single State takes up its own spot on a ledger shard. Furthermore, multiple States take up multiple shards. Data is chargeable per lane in order to disincentivise code like the above which can slow the network. There are better approaches to the voting problem. For example, by encapsulating the data with a ShardedState and performing calculations in functions outside the ledger. function main () vote (); endfunction function vote () var fors = ShardedState < Int32 > ( \"votes_for\" ); fors . set ( \"Alice\" , increment ( fors . get ( \"Alice\" , 0 ))); // etc. endfunction function increment ( x : Int32 ) : Int32 var y = x + 1 ; return y ; endfunction","title":"Design considerations"},{"location":"ledger/smart-contracts/pipenv/","text":"pipenv The wrapper libraries supporting creation and deployment of etch smart contracts are in Python. We therefore advise developing and testing your smart contracts from within a Python environment. Do this with pipenv . Find out about pipenv here , including installation instructions. Once installed, develop and test from within an environment shell. pipenv shell","title":"Development environment"},{"location":"ledger/smart-contracts/pipenv/#pipenv","text":"The wrapper libraries supporting creation and deployment of etch smart contracts are in Python. We therefore advise developing and testing your smart contracts from within a Python environment. Do this with pipenv . Find out about pipenv here , including installation instructions. Once installed, develop and test from within an environment shell. pipenv shell","title":"pipenv"},{"location":"ledger/smart-contracts/prediction_agent/","text":"Building a prediction agent TODO: Yet to be written.","title":"Building a prediction agent"},{"location":"ledger/smart-contracts/prediction_agent/#building-a-prediction-agent","text":"TODO: Yet to be written.","title":"Building a prediction agent"},{"location":"ledger/smart-contracts/public-keys/","text":"","title":"Public keys"},{"location":"ledger/smart-contracts/smart-contract-intro/","text":"Introduction to Smart Contracts Quote A smart contract is a computer protocol intended to digitally facilitate, verify, or enforce the negotiation or performance of a contract. Smart contracts allow the performance of credible transactions without third parties. These transactions are trackable and irreversible. Source: Wikipedia . A smart contract facilitates, verifies, and enforces a transaction between two or more parties on a distributed ledger or blockchain. Smart contracts store transactional data on the permanent and irreversible blockchain ledger and, on doing so, change the state of the ledger. Smart contract programming languages are scripting languages specific to the cryptocurrency or platform, such Bitcoin's Script or Ethereum's Solidity. Fetch.ai smart contracts run on the etch virtual machine (VM) which is a logical computation layer used to execute smart contract code. The etch VM and smart contract code reside on every node of the distributed Fetch.ai Ledger. Smart contracts can be used for voting applications, crowdfunding, auctions, multi-signature wallets, identity verification, and much more. etch builds up smart contracts using persistent global representations of State and ShardedState data structures, and the Address type which represents account owners and gives access to respective balances. The Ledger Smart contract transactions are etched onto the Fetch.ai distributed ledger, or blockchain, and are therefore permanent, traceable, and irreversible. The Fetch.ai Ledger is the blockchain foundation of the etch VM. Quick start instructions for spinning up a Fetch.ai Ledger node are here . The Fetch.ai Ledger is unlike more traditional blockchain designs. Instead of a single chain of truth, the Fetch.ai Ledger is sharded into parallel lanes. This blockchain sharding design speeds up the network as contracts can execute concurrently. For Fetch.ai Ledger developer documentation, click here . Determinism In computer science, determinism ensures that an input to an algorithm will always produce the same output. When designing etch smart contract code which will execute on Fetch.ai Ledger nodes, it is essential to avoid non-deterministic behaviour that may break consensus. Any code that causes separate nodes to have different values for the same thing may break consensus. Smart contract developers should therefore consider the following: Randomness: along with random functions, non-deterministic randomness can arise in other places, such as Hash Map implementations and Map iterations, for example. Concurrency: multiple processes targeting the same state transactions can break consensus. Ill-considered imports: e.g. libraries containing non-deterministic functions, such as time functions, or APIs that access external and unpredictable systems. Timestamps: watch out for non-deterministic timestamp implementations. Asynchronous behaviour can break consensus. It may be prudent to implement any essential non-deterministic behaviour outside of smart contract ledger code.","title":"Introduction"},{"location":"ledger/smart-contracts/smart-contract-intro/#the-ledger","text":"Smart contract transactions are etched onto the Fetch.ai distributed ledger, or blockchain, and are therefore permanent, traceable, and irreversible. The Fetch.ai Ledger is the blockchain foundation of the etch VM. Quick start instructions for spinning up a Fetch.ai Ledger node are here . The Fetch.ai Ledger is unlike more traditional blockchain designs. Instead of a single chain of truth, the Fetch.ai Ledger is sharded into parallel lanes. This blockchain sharding design speeds up the network as contracts can execute concurrently. For Fetch.ai Ledger developer documentation, click here .","title":"The Ledger"},{"location":"ledger/smart-contracts/smart-contract-intro/#determinism","text":"In computer science, determinism ensures that an input to an algorithm will always produce the same output. When designing etch smart contract code which will execute on Fetch.ai Ledger nodes, it is essential to avoid non-deterministic behaviour that may break consensus. Any code that causes separate nodes to have different values for the same thing may break consensus. Smart contract developers should therefore consider the following: Randomness: along with random functions, non-deterministic randomness can arise in other places, such as Hash Map implementations and Map iterations, for example. Concurrency: multiple processes targeting the same state transactions can break consensus. Ill-considered imports: e.g. libraries containing non-deterministic functions, such as time functions, or APIs that access external and unpredictable systems. Timestamps: watch out for non-deterministic timestamp implementations. Asynchronous behaviour can break consensus. It may be prudent to implement any essential non-deterministic behaviour outside of smart contract ledger code.","title":"Determinism"},{"location":"ledger/smart-contracts/static-dynamic/","text":"Static contracts A static contract is business logic built at the time the ledger is compiled. The code is unchangeable in the sense that the only way to update the code or deploy new static contracts is to recompile the ledger and distribute new executables to all participants. Note We will demo a Fetch token static contract shortly. Dynamic contracts A smart contract is the second type of business logic found on Fetch ledger nodes. Smart contracts can be deployed at runtime. Find out about Fetch smart contracts in the Smart Contract section here .","title":"Static and dynamic contracts"},{"location":"ledger/smart-contracts/static-dynamic/#static-contracts","text":"A static contract is business logic built at the time the ledger is compiled. The code is unchangeable in the sense that the only way to update the code or deploy new static contracts is to recompile the ledger and distribute new executables to all participants. Note We will demo a Fetch token static contract shortly.","title":"Static contracts"},{"location":"ledger/smart-contracts/static-dynamic/#dynamic-contracts","text":"A smart contract is the second type of business logic found on Fetch ledger nodes. Smart contracts can be deployed at runtime. Find out about Fetch smart contracts in the Smart Contract section here .","title":"Dynamic contracts"},{"location":"ledger/smart-contracts/synergetic/","text":"Introduction to synergetic contracts Synergetic contracts are a new type of smart contract which allows miners to use their computational power to solve useful problems and earn a reward. Anyone can register a problem on the ledger by creating a synergetic contract and inviting miners to solve it. The type of problems that synergetic contracts can solve are complex optimisation problems such as scheduling patient appointments and protein folding . A miner registers as a participant of the synergetic contract and starts calculating towards the problem solution from a random seed generated from a public key. It is a trial and error approach like proof of work. Solutions submitted by miners are verified periodically via a function provided by the synergetic contract. The miner that wins the bounty associated with the problem is the one that provides the best solution, according to this function and before the period expires. In the case of a tie, the winner is randomly chosen among all those that provided the best solution. Note The winning miner is not necessarily the miner who verifies the block.","title":"Synergetic contracts"},{"location":"ledger/smart-contracts/synergetic/#introduction-to-synergetic-contracts","text":"Synergetic contracts are a new type of smart contract which allows miners to use their computational power to solve useful problems and earn a reward. Anyone can register a problem on the ledger by creating a synergetic contract and inviting miners to solve it. The type of problems that synergetic contracts can solve are complex optimisation problems such as scheduling patient appointments and protein folding . A miner registers as a participant of the synergetic contract and starts calculating towards the problem solution from a random seed generated from a public key. It is a trial and error approach like proof of work. Solutions submitted by miners are verified periodically via a function provided by the synergetic contract. The miner that wins the bounty associated with the problem is the one that provides the best solution, according to this function and before the period expires. In the case of a tie, the winner is randomly chosen among all those that provided the best solution. Note The winning miner is not necessarily the miner who verifies the block.","title":"Introduction to synergetic contracts"},{"location":"ledger/walkthrough/","text":"Introduction Welcome to the Fetch.ai ledger walkthrough, which will introduce you to all the steps necessary to use and develop against the ledger, from creating your first address and making a token transfer, to deploying your own smart contracts. All the tutorials are designed to work on testnet and mainnet where applicable. In all cases, we introduce the tools we have and use the various APIs Fetch supports (such as the Python API and JavaScript API ) to interact with the ledger. We would welcome feedback on these walkthroughs, including anything that you feel is missing, not explained in enough detail or could be improved. If you have any suggestions, please open an issue in our repository.","title":"Introduction"},{"location":"ledger/walkthrough/#introduction","text":"Welcome to the Fetch.ai ledger walkthrough, which will introduce you to all the steps necessary to use and develop against the ledger, from creating your first address and making a token transfer, to deploying your own smart contracts. All the tutorials are designed to work on testnet and mainnet where applicable. In all cases, we introduce the tools we have and use the various APIs Fetch supports (such as the Python API and JavaScript API ) to interact with the ledger. We would welcome feedback on these walkthroughs, including anything that you feel is missing, not explained in enough detail or could be improved. If you have any suggestions, please open an issue in our repository.","title":"Introduction"},{"location":"ledger/walkthrough/creating-addresses/","text":"Creating addresses In this tutorial we will focus on how you can get Fetch.ai mainnet/testnet addresses, and stock testnet ones with tokens. First things first, it's the perfect time to install Pocketbook, our command-line based Python wallet and address book. You use this application at your own risk Whilst Fetch.ai have made every effort to ensure its reliability and security, it comes with no warranty. It is intended for the creation and management of Fetch.ai mainnet wallets and transactions between them. You are responsible for the security of your own private keys (see ~/.pocketbook folder). Do not use this application for high-value operations: it is intended for utility operations on the main network. Pocketbook can be easily installed in Linux and on the Mac. Open a terminal window and type: pip3 install -U pocketbook The -U option ensures that if you already have it installed, it will upgrade where applicable. Pocketbook defaults to access the main network. You can change the network using the -n parameter. E.g.: pocketbook -n testnet <command> pocketbook -n mainnet <command> For details of how to use Pocketbook, you can use its help option -h . Creating a new address You can use any of the following methods to create an address. Using Pocketbook Simply run the following command: pocketbook create You will be prompted to enter a name for this key pair, followed by a password for the key. Below is a sample output: Enter name for key: foo Enter password for key...: Confirm password for key.: It is the user's responsibility to store the private key to this securely. Addresses generated inside Pocketbook will have the private keys encrypted and secured, so you don't need to store them manually, but you do need to back them up yourself. Pocketbook stores all information in the ~/.pocketbook folder on your computer. You can back this folder up entirely to store your encrypted private keys. We strongly recommend that you do this regularly and keep the backups in an encrypted safe place in order to provide a mechanism for recovering your accounts. Using the web testnet wallet For testnet addresses only, you can also use our web-based wallet . You will be prompted to enter the password for the address twice. Using the Python Ledger API Installing Pocketbook also installs the Python Ledger API ( GitHub repository ), which enables you to create and interact with addresses programmatically. Let's get started with a simple Python program that generates an address and outputs the private key (hex and in bytes) and the address; you can add the latter to Pocketbook or use to receive tokens from others. from fetchai.ledger.api import LedgerApi , TokenApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address print ( \"My Fetch.ai Address Generator v1.0\" ) # this gets us an API connected to the testnet endpoint: try : api = LedgerApi ( network = \"testnet\" ) except Exception as e : sys . exit ( e ) entity = Entity () print ( \"Private key: \" , entity . private_key_hex ) print ( \" : \" , entity . private_key_bytes ) print ( \" Address: \" , Address ( entity )) For example, if you save the above file into a program called generate_address.py , you can run it and will get a result like this: $ python3 generate_address.py Fetch.ai Address Generator v1.0 Private key: 341f00f7890063eefd3568f2f5c7c310802fd32b3a15a111ac0fbfb4a65ce07b : b'4\\x1f\\x00\\xf7\\x89\\x00c\\xee\\xfd5h\\xf2\\xf5\\xc7\\xc3\\x10\\x80/\\xd3+:\\x15\\xa1\\x11\\xac\\x0f\\xbf\\xb4\\xa6\\\\\\xe0{' Address: 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 Do not use this account This account and its private key are shared with anyone who reads this tutorial. Just to reiterate, any account you wish to use yourself, do not, ever, for any reason, disclose the private key in public, on the internet, or anywhere people can see it . So don't post the output of the above program here! Adding an address to Pocketbook We may now want to add the address we just created (or another provided by other users) to Pocketbook. Once an address is added, you can send tokens to it or query the balance. You can add existing addresses like this: pocketbook -n <network> add <name-for-the-address> <address> For our particular example: pocketbook -n testnet add GeneratedTestnetAddress 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 Listing an address balance You can query the balance of your accounts and address book entries with a command like the following: pocketbook -n <network> list [ -v ] Adding the -v option will display the addresses alongside the names and balances. For our particular example: $ pocketbook -n testnet ls -v Name Type Balance Stake Address GeneratedTestnetAddress addr 0.0 0.0 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5","title":"Creating addresses"},{"location":"ledger/walkthrough/creating-addresses/#creating-addresses","text":"In this tutorial we will focus on how you can get Fetch.ai mainnet/testnet addresses, and stock testnet ones with tokens. First things first, it's the perfect time to install Pocketbook, our command-line based Python wallet and address book. You use this application at your own risk Whilst Fetch.ai have made every effort to ensure its reliability and security, it comes with no warranty. It is intended for the creation and management of Fetch.ai mainnet wallets and transactions between them. You are responsible for the security of your own private keys (see ~/.pocketbook folder). Do not use this application for high-value operations: it is intended for utility operations on the main network. Pocketbook can be easily installed in Linux and on the Mac. Open a terminal window and type: pip3 install -U pocketbook The -U option ensures that if you already have it installed, it will upgrade where applicable. Pocketbook defaults to access the main network. You can change the network using the -n parameter. E.g.: pocketbook -n testnet <command> pocketbook -n mainnet <command> For details of how to use Pocketbook, you can use its help option -h .","title":"Creating addresses"},{"location":"ledger/walkthrough/creating-addresses/#creating-a-new-address","text":"You can use any of the following methods to create an address.","title":"Creating a new address"},{"location":"ledger/walkthrough/creating-addresses/#using-pocketbook","text":"Simply run the following command: pocketbook create You will be prompted to enter a name for this key pair, followed by a password for the key. Below is a sample output: Enter name for key: foo Enter password for key...: Confirm password for key.: It is the user's responsibility to store the private key to this securely. Addresses generated inside Pocketbook will have the private keys encrypted and secured, so you don't need to store them manually, but you do need to back them up yourself. Pocketbook stores all information in the ~/.pocketbook folder on your computer. You can back this folder up entirely to store your encrypted private keys. We strongly recommend that you do this regularly and keep the backups in an encrypted safe place in order to provide a mechanism for recovering your accounts.","title":"Using Pocketbook"},{"location":"ledger/walkthrough/creating-addresses/#using-the-web-testnet-wallet","text":"For testnet addresses only, you can also use our web-based wallet . You will be prompted to enter the password for the address twice.","title":"Using the web testnet wallet"},{"location":"ledger/walkthrough/creating-addresses/#using-the-python-ledger-api","text":"Installing Pocketbook also installs the Python Ledger API ( GitHub repository ), which enables you to create and interact with addresses programmatically. Let's get started with a simple Python program that generates an address and outputs the private key (hex and in bytes) and the address; you can add the latter to Pocketbook or use to receive tokens from others. from fetchai.ledger.api import LedgerApi , TokenApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address print ( \"My Fetch.ai Address Generator v1.0\" ) # this gets us an API connected to the testnet endpoint: try : api = LedgerApi ( network = \"testnet\" ) except Exception as e : sys . exit ( e ) entity = Entity () print ( \"Private key: \" , entity . private_key_hex ) print ( \" : \" , entity . private_key_bytes ) print ( \" Address: \" , Address ( entity )) For example, if you save the above file into a program called generate_address.py , you can run it and will get a result like this: $ python3 generate_address.py Fetch.ai Address Generator v1.0 Private key: 341f00f7890063eefd3568f2f5c7c310802fd32b3a15a111ac0fbfb4a65ce07b : b'4\\x1f\\x00\\xf7\\x89\\x00c\\xee\\xfd5h\\xf2\\xf5\\xc7\\xc3\\x10\\x80/\\xd3+:\\x15\\xa1\\x11\\xac\\x0f\\xbf\\xb4\\xa6\\\\\\xe0{' Address: 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 Do not use this account This account and its private key are shared with anyone who reads this tutorial. Just to reiterate, any account you wish to use yourself, do not, ever, for any reason, disclose the private key in public, on the internet, or anywhere people can see it . So don't post the output of the above program here!","title":"Using the Python Ledger API"},{"location":"ledger/walkthrough/creating-addresses/#adding-an-address-to-pocketbook","text":"We may now want to add the address we just created (or another provided by other users) to Pocketbook. Once an address is added, you can send tokens to it or query the balance. You can add existing addresses like this: pocketbook -n <network> add <name-for-the-address> <address> For our particular example: pocketbook -n testnet add GeneratedTestnetAddress 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5","title":"Adding an address to Pocketbook"},{"location":"ledger/walkthrough/creating-addresses/#listing-an-address-balance","text":"You can query the balance of your accounts and address book entries with a command like the following: pocketbook -n <network> list [ -v ] Adding the -v option will display the addresses alongside the names and balances. For our particular example: $ pocketbook -n testnet ls -v Name Type Balance Stake Address GeneratedTestnetAddress addr 0.0 0.0 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5","title":"Listing an address balance"},{"location":"ledger/walkthrough/smart-contracts/","text":"Deploying and interacting with smart contracts What is a smart contract? A Smart Contract is an agreement with the terms defined as a computer program. The contract exists on a decentralised network, and its execution and transactions can be tracked by anyone and are irreversible. All parties involved can be defined and enforced by the contract and no central authority is required for it to operate. In this tutorial, we are going to deploy a simple \"Hello world\" smart contract developed in Etch (the Fetch.ai smart contract language) and interact with it. @ query function sayHello () : String return \"Hello world\" endfunction This contract has only function annotated as a @query . Queries do not alter state, and they return a value to the caller. A contract can contain many of them. Let's now deploy the contract, assuming it has been saved to a file hello.etch . This can be done using the Python Ledger API. import sys from fetchai.ledger.api import LedgerApi , TokenApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address # The contract we are going to load contract_name = 'hello.etch' # Connect the API to the testnet try : api = LedgerApi ( network = \"testnet\" ) except Exception as e : sys . exit ( e ) # Load the contract and perform some basic checks on it try : contract_text = open ( contract_name , 'r' ) . read () except IOError as e : sys . exit ( 'File not found' ) if 0 == len ( contract_text ): print ( \"Contract is zero length.\" ) sys . exit ( \"Invalid contract\" ) # Private key of the address to deploy from # WARNING: Unencrypted private keys should not be present in production code entity = Entity ( b '... your private key here ...' ) address = Address ( entity ) print ( \"Deploying contract:\" , contract_name , ' \\n ' ) print ( \" Owner:\" , address ) print ( \" Length:\" , len ( contract_text ), \"byte(s)\" ) # Perform the deployment now try : contract = Contract ( contract_text , entity ) gas_fee = 600000 api . sync ( contract . create ( api , entity , gas_fee ), None , 0 ) except Exception as e : sys . exit ( e ); # Deployed, so we can now announce address and owner print ( \" \\n Contract deployed: \\n \" ) print ( \"Address:\" , contract . address ) print ( \" Owner:\" , contract . owner ) # Confirm by querying the contract print ( \" Output:\" , contract . query ( api , 'sayHello' )) If you run the above, having taken these two steps, it will deploy the contract to testnet for you. You'll see something like this: $ python3 deploy.py Deploying contract: hello.etch Owner: 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 Length: 129 byte ( s ) Contract deployed: Address: 2VRHNEDBNfgind7NLmgcGbSvCqc4LX8bMt9Tw9gfyMyk5HXjFS Owner: 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 Output: Hello world Note As with previous examples, everything you see above works on both mainnet and testnet \u2014 just change the api = LedgerApi(network='testnet') line accordingly. Interacting with an already deployed contract There is a catch with the way we have deployed the contract. Once the program completes, we no longer have a way of interacting with the contract! We need to make some changes to our code to: Serialise the contract as a JSON file when we do the initial deployment Read a contract object from the serialised JSON file and then interact with that So let's look at how we do this: try : contract = Contract ( contract_text , entity ) gas_fee = 600000 api . sync ( contract . create ( api , entity , gas_fee ), None , 0 ) with open ( 'hello_contract.json' , 'w' ) as contract_info : contract . dump ( contract_info ) except Exception as e : sys . exit ( e ); You will see that we have added two extra lines that will save the contract as a JSON file. We can \"reconstitute\" the contract from this file to allow us to interact with it further. Here is a new Python script which you can save as interact_with_existing.py : import sys from fetchai.ledger.api import LedgerApi , TokenApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address # Connect the API to the testnet try : api = LedgerApi ( network = \"testnet\" ) except Exception as e : sys . exit ( e ) # Create a contract from our previously saved one contract_name = 'hello_contract.json' try : with open ( contract_name , 'r' ) as contract_info : contract = Contract . load ( contract_info ) except Exception as e : sys . exit ( e ) # Private key of the address to deploy from # WARNING: Unencrypted private keys should not be present in production code entity = Entity ( b '... your private key here ...' ) address = Address ( entity ) # Confirm by querying the contract print ( \"Querying existing contract:\" , contract_name , ' \\n ' ) print ( \"Output:\" , contract . query ( api , 'sayHello' )) And when run, the output should look like the following: $ python3 interact_with_existing.py Querying existing contract: hello_contract.json Output: Hello world Learn more about smart contract development You can check the following for more interesting smart contract examples: Fungible token contract example Synergetic contracts , one of our experimental features We also have an Etch playground that you can use to learn the Etch language. Please note that we don't recommend it as the environment to develop contracts.","title":"Deploying smart contracts"},{"location":"ledger/walkthrough/smart-contracts/#deploying-and-interacting-with-smart-contracts","text":"What is a smart contract? A Smart Contract is an agreement with the terms defined as a computer program. The contract exists on a decentralised network, and its execution and transactions can be tracked by anyone and are irreversible. All parties involved can be defined and enforced by the contract and no central authority is required for it to operate. In this tutorial, we are going to deploy a simple \"Hello world\" smart contract developed in Etch (the Fetch.ai smart contract language) and interact with it. @ query function sayHello () : String return \"Hello world\" endfunction This contract has only function annotated as a @query . Queries do not alter state, and they return a value to the caller. A contract can contain many of them. Let's now deploy the contract, assuming it has been saved to a file hello.etch . This can be done using the Python Ledger API. import sys from fetchai.ledger.api import LedgerApi , TokenApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address # The contract we are going to load contract_name = 'hello.etch' # Connect the API to the testnet try : api = LedgerApi ( network = \"testnet\" ) except Exception as e : sys . exit ( e ) # Load the contract and perform some basic checks on it try : contract_text = open ( contract_name , 'r' ) . read () except IOError as e : sys . exit ( 'File not found' ) if 0 == len ( contract_text ): print ( \"Contract is zero length.\" ) sys . exit ( \"Invalid contract\" ) # Private key of the address to deploy from # WARNING: Unencrypted private keys should not be present in production code entity = Entity ( b '... your private key here ...' ) address = Address ( entity ) print ( \"Deploying contract:\" , contract_name , ' \\n ' ) print ( \" Owner:\" , address ) print ( \" Length:\" , len ( contract_text ), \"byte(s)\" ) # Perform the deployment now try : contract = Contract ( contract_text , entity ) gas_fee = 600000 api . sync ( contract . create ( api , entity , gas_fee ), None , 0 ) except Exception as e : sys . exit ( e ); # Deployed, so we can now announce address and owner print ( \" \\n Contract deployed: \\n \" ) print ( \"Address:\" , contract . address ) print ( \" Owner:\" , contract . owner ) # Confirm by querying the contract print ( \" Output:\" , contract . query ( api , 'sayHello' )) If you run the above, having taken these two steps, it will deploy the contract to testnet for you. You'll see something like this: $ python3 deploy.py Deploying contract: hello.etch Owner: 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 Length: 129 byte ( s ) Contract deployed: Address: 2VRHNEDBNfgind7NLmgcGbSvCqc4LX8bMt9Tw9gfyMyk5HXjFS Owner: 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 Output: Hello world Note As with previous examples, everything you see above works on both mainnet and testnet \u2014 just change the api = LedgerApi(network='testnet') line accordingly.","title":"Deploying and interacting with smart contracts"},{"location":"ledger/walkthrough/smart-contracts/#interacting-with-an-already-deployed-contract","text":"There is a catch with the way we have deployed the contract. Once the program completes, we no longer have a way of interacting with the contract! We need to make some changes to our code to: Serialise the contract as a JSON file when we do the initial deployment Read a contract object from the serialised JSON file and then interact with that So let's look at how we do this: try : contract = Contract ( contract_text , entity ) gas_fee = 600000 api . sync ( contract . create ( api , entity , gas_fee ), None , 0 ) with open ( 'hello_contract.json' , 'w' ) as contract_info : contract . dump ( contract_info ) except Exception as e : sys . exit ( e ); You will see that we have added two extra lines that will save the contract as a JSON file. We can \"reconstitute\" the contract from this file to allow us to interact with it further. Here is a new Python script which you can save as interact_with_existing.py : import sys from fetchai.ledger.api import LedgerApi , TokenApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address # Connect the API to the testnet try : api = LedgerApi ( network = \"testnet\" ) except Exception as e : sys . exit ( e ) # Create a contract from our previously saved one contract_name = 'hello_contract.json' try : with open ( contract_name , 'r' ) as contract_info : contract = Contract . load ( contract_info ) except Exception as e : sys . exit ( e ) # Private key of the address to deploy from # WARNING: Unencrypted private keys should not be present in production code entity = Entity ( b '... your private key here ...' ) address = Address ( entity ) # Confirm by querying the contract print ( \"Querying existing contract:\" , contract_name , ' \\n ' ) print ( \"Output:\" , contract . query ( api , 'sayHello' )) And when run, the output should look like the following: $ python3 interact_with_existing.py Querying existing contract: hello_contract.json Output: Hello world","title":"Interacting with an already deployed contract"},{"location":"ledger/walkthrough/smart-contracts/#learn-more-about-smart-contract-development","text":"You can check the following for more interesting smart contract examples: Fungible token contract example Synergetic contracts , one of our experimental features We also have an Etch playground that you can use to learn the Etch language. Please note that we don't recommend it as the environment to develop contracts.","title":"Learn more about smart contract development"},{"location":"ledger/walkthrough/testnet-tokens/","text":"Getting testnet tokens In order to get testnet tokens, you first need to create an address. Please see the tutorial describing several available ways to do so. When you have an address, you'll need some tokens to operate in the network. There are three easy ways of getting tokens on testnet. Using the token tap Please visit the token tap page in our testnet block explorer, paste the address in and press the DISPENSE button. Wait 30-60 seconds and voila, you'll have 10-500 test-FET just like that. Using the example account from the tutorial about creating addresses , you can send the above \"free for all\" account tokens by pasting 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 into the address box. Transferring tokens from another account you have It's easy, you can use Pocketbook and it takes no time at all. Just use a command like the following: pocketbook -n testnet transfer destination_account_name AMOUNT source_account_name And you're done! Asking in the developer Slack channel You can also request tokens on our developer Slack . We have tons, and we're happy to send large amounts if you need them for specific contracts or tests. Don't be shy , we want you to get stuff done. It may take a day or two, but we'll do our best to make it quick.","title":"Getting testnet tokens"},{"location":"ledger/walkthrough/testnet-tokens/#getting-testnet-tokens","text":"In order to get testnet tokens, you first need to create an address. Please see the tutorial describing several available ways to do so. When you have an address, you'll need some tokens to operate in the network. There are three easy ways of getting tokens on testnet.","title":"Getting testnet tokens"},{"location":"ledger/walkthrough/testnet-tokens/#using-the-token-tap","text":"Please visit the token tap page in our testnet block explorer, paste the address in and press the DISPENSE button. Wait 30-60 seconds and voila, you'll have 10-500 test-FET just like that. Using the example account from the tutorial about creating addresses , you can send the above \"free for all\" account tokens by pasting 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 into the address box.","title":"Using the token tap"},{"location":"ledger/walkthrough/testnet-tokens/#transferring-tokens-from-another-account-you-have","text":"It's easy, you can use Pocketbook and it takes no time at all. Just use a command like the following: pocketbook -n testnet transfer destination_account_name AMOUNT source_account_name And you're done!","title":"Transferring tokens from another account you have"},{"location":"ledger/walkthrough/testnet-tokens/#asking-in-the-developer-slack-channel","text":"You can also request tokens on our developer Slack . We have tons, and we're happy to send large amounts if you need them for specific contracts or tests. Don't be shy , we want you to get stuff done. It may take a day or two, but we'll do our best to make it quick.","title":"Asking in the developer Slack channel"},{"location":"ledger/walkthrough/transfers-and-balances/","text":"Making transfers In order to make transfers in the network, you first need to create an address. Please see the tutorial describing several available ways to do so. We'll be using the address we minted in that tutorial, 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 . Note that if you use the same address, we might all be fighting over the same test tokens! :) Using Pocketbook You can use Pocketbook to send tokens to someone who has provided you with their address, but obviously you won't know their private key. In order to do so, you need to use a command like the following: pocketbook -n <network> transfer <destination-name> <amount> <signer ( source ) > For our particular example: $ pocketbook -n testnet transfer GeneratedTestnetAddress 100 TestNetAddress Network....: testnet From.......: TestNetAddress Signer(s)..: TestNetAddress Destination: GeneratedTestnetAddress: 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 Amount.....: 100.0000000000 FET Fee........: 0.0000000001 FET Total......: 100.0000000001 FET (Amount + Fee) Press enter to continue Enter password for key TestNetAddress: Submitting TX... Submitting TX...complete And now, if we check the balance, we see: $ pocketbook -n testnet ls -v Name Type Balance Stake Address GeneratedTestnetAddress addr 100.0 0.0 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 Using the Python Ledger API Now let's do the same thing, but this time programmatically. The minimum code to show the balance in an address is: from fetchai.ledger.api import LedgerApi , TokenApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address # Connect the API to the testnet endpoint try : api = LedgerApi ( network = \"testnet\" ) except Exception as e : sys . exit ( e ) # Show balance # Correct from the smallest FET unit to actual FET for nicer display units_in_fet = 10000000000 print ( \"Balance:\" , api . tokens . balance ( \"2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5\" ) / 10000000000 ) And the output when it is executed is: $ python3 balance.py Balance: 100.0 Voila, it is 100 FET, as expected after the transfer in the previous section (although it may not be when you get to that account!). Now let's transfer 10 FET out of this account to another one that I have created. Here is the code required to do it: from fetchai.ledger.api import LedgerApi, TokenApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity, Address # Connect the API to the testnet endpoint try: api = LedgerApi(network=\"testnet\") except Exception as e: sys.exit(e) # Create our source address (WARNING: this is a shared private key used in # the tutorial. You MUST NOT store keys in plain sight like this!) entity = Entity(b'4\\x1f\\x00\\xf7\\x89\\x00c\\xee\\xfd5h\\xf2\\xf5\\xc7\\xc3\\x10\\x80/\\xd3+:\\x15\\xa1\\x11\\xac\\x0f\\xbf\\xb4\\xa6\\\\\\xe0{') address = Address(entity) # Set target address target_address = \"2QaAtmWr7xcaqKfncWrtY6izkjk81nfGWkusoMNd1wri2FS7so\" amount = 10 # Show balances before the transfer # Correct from the smallest FET unit to actual FET for nicer display units_in_fet = 10000000000 print(\"Source balance before:\", api.tokens.balance(address) / units_in_fet) print(\"Target balance before:\", api.tokens.balance(target_address) / units_in_fet) # Trigger the transaction try: api.sync(api.tokens.transfer(entity, target_address, amount * units_in_fet, 20)) except Exception as e: sys.exit(e) # Show balances after the transfer print(\"Source balance after:\", api.tokens.balance(address) / units_in_fet) print(\"Target balance after:\", api.tokens.balance(target_address) / units_in_fet) And this is the output of the program: $ python3 simple_transfer.py Source balance before: 100.0 Target balance before: 0.0 Source balance after: 89.9999999999 Target balance after: 10.0 Do not expose private keys in source code For the sake of simplicity, in this code snippet we are exposing the private key in the source code, which is very bad practice . Better ways of handling this would be: Pass in the key as a command line parameter Pass in the encrypted key, ask for password, decrypt and use","title":"Making transfers"},{"location":"ledger/walkthrough/transfers-and-balances/#making-transfers","text":"In order to make transfers in the network, you first need to create an address. Please see the tutorial describing several available ways to do so. We'll be using the address we minted in that tutorial, 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 . Note that if you use the same address, we might all be fighting over the same test tokens! :)","title":"Making transfers"},{"location":"ledger/walkthrough/transfers-and-balances/#using-pocketbook","text":"You can use Pocketbook to send tokens to someone who has provided you with their address, but obviously you won't know their private key. In order to do so, you need to use a command like the following: pocketbook -n <network> transfer <destination-name> <amount> <signer ( source ) > For our particular example: $ pocketbook -n testnet transfer GeneratedTestnetAddress 100 TestNetAddress Network....: testnet From.......: TestNetAddress Signer(s)..: TestNetAddress Destination: GeneratedTestnetAddress: 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5 Amount.....: 100.0000000000 FET Fee........: 0.0000000001 FET Total......: 100.0000000001 FET (Amount + Fee) Press enter to continue Enter password for key TestNetAddress: Submitting TX... Submitting TX...complete And now, if we check the balance, we see: $ pocketbook -n testnet ls -v Name Type Balance Stake Address GeneratedTestnetAddress addr 100.0 0.0 2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5","title":"Using Pocketbook"},{"location":"ledger/walkthrough/transfers-and-balances/#using-the-python-ledger-api","text":"Now let's do the same thing, but this time programmatically. The minimum code to show the balance in an address is: from fetchai.ledger.api import LedgerApi , TokenApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address # Connect the API to the testnet endpoint try : api = LedgerApi ( network = \"testnet\" ) except Exception as e : sys . exit ( e ) # Show balance # Correct from the smallest FET unit to actual FET for nicer display units_in_fet = 10000000000 print ( \"Balance:\" , api . tokens . balance ( \"2uGQSyM56XfkaFeoyYib2dt4rvFwVZ6if5JREZd54d1sNehEQ5\" ) / 10000000000 ) And the output when it is executed is: $ python3 balance.py Balance: 100.0 Voila, it is 100 FET, as expected after the transfer in the previous section (although it may not be when you get to that account!). Now let's transfer 10 FET out of this account to another one that I have created. Here is the code required to do it: from fetchai.ledger.api import LedgerApi, TokenApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity, Address # Connect the API to the testnet endpoint try: api = LedgerApi(network=\"testnet\") except Exception as e: sys.exit(e) # Create our source address (WARNING: this is a shared private key used in # the tutorial. You MUST NOT store keys in plain sight like this!) entity = Entity(b'4\\x1f\\x00\\xf7\\x89\\x00c\\xee\\xfd5h\\xf2\\xf5\\xc7\\xc3\\x10\\x80/\\xd3+:\\x15\\xa1\\x11\\xac\\x0f\\xbf\\xb4\\xa6\\\\\\xe0{') address = Address(entity) # Set target address target_address = \"2QaAtmWr7xcaqKfncWrtY6izkjk81nfGWkusoMNd1wri2FS7so\" amount = 10 # Show balances before the transfer # Correct from the smallest FET unit to actual FET for nicer display units_in_fet = 10000000000 print(\"Source balance before:\", api.tokens.balance(address) / units_in_fet) print(\"Target balance before:\", api.tokens.balance(target_address) / units_in_fet) # Trigger the transaction try: api.sync(api.tokens.transfer(entity, target_address, amount * units_in_fet, 20)) except Exception as e: sys.exit(e) # Show balances after the transfer print(\"Source balance after:\", api.tokens.balance(address) / units_in_fet) print(\"Target balance after:\", api.tokens.balance(target_address) / units_in_fet) And this is the output of the program: $ python3 simple_transfer.py Source balance before: 100.0 Target balance before: 0.0 Source balance after: 89.9999999999 Target balance after: 10.0 Do not expose private keys in source code For the sake of simplicity, in this code snippet we are exposing the private key in the source code, which is very bad practice . Better ways of handling this would be: Pass in the key as a command line parameter Pass in the encrypted key, ask for password, decrypt and use","title":"Using the Python Ledger API"},{"location":"oef/","text":"The Open Economic Framework is the Fetch.ai decentralised virtual environment that supplies and supports APIs for autonomous third-party software agents, also known as Autonomous Economic Agents (AEAs). Autonomous Economic Agents are digital entities that run complex dynamic decision-making algorithms for application owners and clients. The Fetch.ai blockchain ledger ensures the truth and integrity of the entire system. The OEF documentation will show you how to build and register an agent, how to advertise and search for services, and explain how the negotiation protocol works. We have detailed API documentation in Python and a set of working examples you can try out. But before you can do anything at all, you need to be running a node. Let's get that sorted right away.","title":"Home"},{"location":"oef/advertising/","text":"// Popup window code function newPopup(url) { popupWindow = window.open( url,'popUpWindow','height=600px,width=900px,left=500,top=60,resizable=yes,scrollbars=yes,toolbar=yes,menubar=yes,location=no,directories=no,status=no') } Agents advertise their services with schemas. Schemas describe services in a language agnostic manner, after which they are serialised by the SDK. Defining schemas A schema describes an agent, service, or resource with a set of attributes . To specify data models and descriptions in Python use the oef.schema module . Attributes An attribute is an abstract definition of a property. It is identified by a name that must be unique in a given schema. Each attribute has a type which specifies possible values. Currently, we support the following attribute types: strings integers booleans floats locations (latitude, longitude) An attribute of a schema can be optional in the case where an attribute is inapplicable. Attributes can also have descriptions. Let's look at a bookshop scenario. A bookshop may like to include the following properties of its books as attributes in the SDK: title author genre (e.g. science fiction, horror) year of publication average rating (average of the ratings between 0 and 5) ISBN code Whether it is available as e-book. For example, in Python, using the AttributeSchema class, we instantiate Attributes with attribute name, type, whether it is a required attribute, and a description: from oef.schema import AttributeSchema , Location attr_title = AttributeSchema ( \"title\" , str , True , \"The title of the book.\" ) attr_author = AttributeSchema ( \"author\" , str , True , \"The author of the book.\" ) attr_genre = AttributeSchema ( \"genre\" , str , True , \"The genre of the book.\" ) attr_year = AttributeSchema ( \"year\" , int , True , \"The year of publication of the book.\" ) attr_avg_rat = AttributeSchema ( \"average_rating\" , float , False , \"The average rating of the book.\" ) attr_isbn = AttributeSchema ( \"ISBN\" , str , True , \"The ISBN.\" ) attr_ebook = AttributeSchema ( \"ebook_available\" , bool , False , \"If the book can be sold as an e-book.\" ) attr_bookshop = AttributeSchema ( \"bookshop_pos\" , Location , False , \"The location of the bookshop where you can find the book\" ) Data model A DataModel is a set of attributes . Let's group the book attributes into a DataModel called book . In Python, this looks like this: from oef.schema import DataModel book_model = DataModel ( \"book\" , [ attr_title , attr_author , attr_genre , attr_year , attr_avg_rat , attr_isbn , attr_ebook , attr_bookshop ], \"A data model to describe books.\" ) A DataModel class requires a name, a list of attributes, and an optional description. Description A Description is an instantiated data model. Instantiated Description classes for the bookshop may look like this: from oef.schema import Description It = Description ({ \"title\" : \"It\" , \"author\" : \"Stephen King\" , \"genre\" : \"horror\" , \"year\" : 1986 , \"average_rating\" : 4.5 , \"ISBN\" : \"0-670-81302-8\" , \"ebook_available\" : True , \"bookshop_pos\" : Location ( 52.2057092 , 0.1183431 ) }, book_model ) _1984 = Description ({ \"title\" : \"1984\" , \"author\" : \"George Orwell\" , \"genre\" : \"novel\" , \"year\" : 1949 , \"ISBN\" : \"978-0451524935\" , \"ebook_available\" : False }, book_model ) Attributes are instantiated as part of a Description using a dictionary where: key = the name of the attributes. value = the values associated with the attribute key. Note that in the latter book we were able to omit the average_rating field because it was optional. In the oef-sdk-python/examples/weather folder, you will find the weather_schema.py file describing the data advertised by a weather service. from oef.schema import DataModel , AttributeSchema WIND_SPEED_ATTR = AttributeSchema ( \"wind_speed\" , bool , is_attribute_required = True , attribute_description = \"Provides wind speed measurements.\" ) TEMPERATURE_ATTR = AttributeSchema ( \"temperature\" , bool , is_attribute_required = True , attribute_description = \"Provides temperature measurements.\" ) AIR_PRESSURE_ATTR = AttributeSchema ( \"air_pressure\" , bool , is_attribute_required = True , attribute_description = \"Provides air pressure measurements.\" ) HUMIDITY_ATTR = AttributeSchema ( \"humidity\" , bool , is_attribute_required = True , attribute_description = \"Provides humidity measurements.\" ) WEATHER_DATA_MODEL = DataModel ( \"weather_data\" , [ WIND_SPEED_ATTR , TEMPERATURE_ATTR , AIR_PRESSURE_ATTR , HUMIDITY_ATTR ], \"All possible weather data.\" ) The WeatherStation class in the same directory, implements the behaviour of the weather station by creating a service description that mirrors the schema. weather_service_description = Description ( { \"wind_speed\" : False , \"temperature\" : True , \"air_pressure\" : True , \"humidity\" : True , }, WEATHER_DATA_MODEL ) Searching for schemas Agents searching for services do not have to match the advertised schema precisely as the OEF executes a fuzzy search algorithm/learned matching.","title":"Advertising"},{"location":"oef/advertising/#defining-schemas","text":"A schema describes an agent, service, or resource with a set of attributes . To specify data models and descriptions in Python use the oef.schema module .","title":"Defining schemas"},{"location":"oef/advertising/#attributes","text":"An attribute is an abstract definition of a property. It is identified by a name that must be unique in a given schema. Each attribute has a type which specifies possible values. Currently, we support the following attribute types: strings integers booleans floats locations (latitude, longitude) An attribute of a schema can be optional in the case where an attribute is inapplicable. Attributes can also have descriptions. Let's look at a bookshop scenario. A bookshop may like to include the following properties of its books as attributes in the SDK: title author genre (e.g. science fiction, horror) year of publication average rating (average of the ratings between 0 and 5) ISBN code Whether it is available as e-book. For example, in Python, using the AttributeSchema class, we instantiate Attributes with attribute name, type, whether it is a required attribute, and a description: from oef.schema import AttributeSchema , Location attr_title = AttributeSchema ( \"title\" , str , True , \"The title of the book.\" ) attr_author = AttributeSchema ( \"author\" , str , True , \"The author of the book.\" ) attr_genre = AttributeSchema ( \"genre\" , str , True , \"The genre of the book.\" ) attr_year = AttributeSchema ( \"year\" , int , True , \"The year of publication of the book.\" ) attr_avg_rat = AttributeSchema ( \"average_rating\" , float , False , \"The average rating of the book.\" ) attr_isbn = AttributeSchema ( \"ISBN\" , str , True , \"The ISBN.\" ) attr_ebook = AttributeSchema ( \"ebook_available\" , bool , False , \"If the book can be sold as an e-book.\" ) attr_bookshop = AttributeSchema ( \"bookshop_pos\" , Location , False , \"The location of the bookshop where you can find the book\" )","title":"Attributes"},{"location":"oef/advertising/#data-model","text":"A DataModel is a set of attributes . Let's group the book attributes into a DataModel called book . In Python, this looks like this: from oef.schema import DataModel book_model = DataModel ( \"book\" , [ attr_title , attr_author , attr_genre , attr_year , attr_avg_rat , attr_isbn , attr_ebook , attr_bookshop ], \"A data model to describe books.\" ) A DataModel class requires a name, a list of attributes, and an optional description.","title":"Data model"},{"location":"oef/advertising/#description","text":"A Description is an instantiated data model. Instantiated Description classes for the bookshop may look like this: from oef.schema import Description It = Description ({ \"title\" : \"It\" , \"author\" : \"Stephen King\" , \"genre\" : \"horror\" , \"year\" : 1986 , \"average_rating\" : 4.5 , \"ISBN\" : \"0-670-81302-8\" , \"ebook_available\" : True , \"bookshop_pos\" : Location ( 52.2057092 , 0.1183431 ) }, book_model ) _1984 = Description ({ \"title\" : \"1984\" , \"author\" : \"George Orwell\" , \"genre\" : \"novel\" , \"year\" : 1949 , \"ISBN\" : \"978-0451524935\" , \"ebook_available\" : False }, book_model ) Attributes are instantiated as part of a Description using a dictionary where: key = the name of the attributes. value = the values associated with the attribute key. Note that in the latter book we were able to omit the average_rating field because it was optional. In the oef-sdk-python/examples/weather folder, you will find the weather_schema.py file describing the data advertised by a weather service. from oef.schema import DataModel , AttributeSchema WIND_SPEED_ATTR = AttributeSchema ( \"wind_speed\" , bool , is_attribute_required = True , attribute_description = \"Provides wind speed measurements.\" ) TEMPERATURE_ATTR = AttributeSchema ( \"temperature\" , bool , is_attribute_required = True , attribute_description = \"Provides temperature measurements.\" ) AIR_PRESSURE_ATTR = AttributeSchema ( \"air_pressure\" , bool , is_attribute_required = True , attribute_description = \"Provides air pressure measurements.\" ) HUMIDITY_ATTR = AttributeSchema ( \"humidity\" , bool , is_attribute_required = True , attribute_description = \"Provides humidity measurements.\" ) WEATHER_DATA_MODEL = DataModel ( \"weather_data\" , [ WIND_SPEED_ATTR , TEMPERATURE_ATTR , AIR_PRESSURE_ATTR , HUMIDITY_ATTR ], \"All possible weather data.\" ) The WeatherStation class in the same directory, implements the behaviour of the weather station by creating a service description that mirrors the schema. weather_service_description = Description ( { \"wind_speed\" : False , \"temperature\" : True , \"air_pressure\" : True , \"humidity\" : True , }, WEATHER_DATA_MODEL )","title":"Description"},{"location":"oef/advertising/#searching-for-schemas","text":"Agents searching for services do not have to match the advertised schema precisely as the OEF executes a fuzzy search algorithm/learned matching.","title":"Searching for schemas"},{"location":"oef/java-kotlin-API/","text":"// Popup window code function newPopup(url) { popupWindow = window.open( url,'popUpWindow','height=600px,width=900px,left=500,top=60,resizable=yes,scrollbars=yes,toolbar=yes,menubar=yes,location=no,directories=no,status=no') } Click here for the version 0.7x API.","title":"java kotlin API"},{"location":"oef/negotiating/","text":"The way Agents communicate is fundamentally different to the object-oriented paradigm. Instead of calling Agents directly, communication between Agents is more akin to human language exchanges such as in bartering scenarios. Quote Objects do it for free; agents do it because they want to. FIPA (Foundation for Intelligent Physical Agents) is a well known standard for agent negotiation. In the OEF, communication follows a minimal subset of the FIPA language. For instance: Buying Agent b requests a resource r from Selling Agent s by sending a call for proposal cfp(r) . Selling Agent s replies by sending a proposal to b with propose(r, p) , where r is the resource requested and p is the seller\u2019s asking price. Specifically, the negotiation system has the following components: A set of speech-acts where each item may also be called a locution: {cfp(r), propose(r,p), accept(), decline()} A reply structure, where each locution is only a valid reply to some other locutions. This is denoted in the following table: Locution Could reply to cfp(r) propose(r,p) cfp(r) or propose(r,p) accept() propose(r,p) decline() cfp(r) A set of moves where each move has the following format: id sender speech-act target Where id is the identity of the move in a dialogue, sender is the agent who sends this move, speech-act is the actual content of the move (i.e. its locution) and target is the id of the move this move is replying to. A dialogue is then just a sequence of moves, where the first move\u2019s target is 0 (the first move is not replying to any other move in the dialogue). An example of a simple negotiation between a buying Agent b and selling Agent s over the resource r is as follows: id Agent locution target 1 b cfp(r) 0 2 s propose(r, 20) 1 3 b propose(r, 10) 2 4 s propose(r, 15) 3 5 b accept() 4 Note the following simple protocol rules: The negotiation dialogues always start with a cfp(r) move. A dialogue terminates when an accept() or decline() is sent. Agents take turns to send moves in the dialogue. In other words, one agent could only send one move in its turn and has to wait for a response from the other agent before being able to send another move. Agents can only reply to the move of the other agent, and not their own. Current implementation In the current version of the OEF SDK, callbacks tell Agents which step of the FIPA protocol has occurred. Note All FIPA messages are implemented as byte streams or dictionary types. For example, Agent Alice sends a sendCFP (call for proposal) message containing the public key and query to Agent Bob via the OEF which forwards an onCFP . Agent Bob receives the onCFP event and replies with a sendPropose containing a list of proposals. Bob's sendPropose has the same identifier that came with the onCFP . This means that Alice can refer back to the CFP when she gets the onPropose event. onACK and onDeal finalise the communication (more). Finally, Agent Alice receives the byte payload from Agent Bob on sendMessage . Every message contains the following: dialogue id : the identifier of the dialogue in which the message is sent. destination : the agent identifier to whom the message is sent. message id : the message identifier for the dialogue. target : the identifier of the message to whom this message is answering.","title":"Negotiating"},{"location":"oef/negotiating/#current-implementation","text":"In the current version of the OEF SDK, callbacks tell Agents which step of the FIPA protocol has occurred. Note All FIPA messages are implemented as byte streams or dictionary types. For example, Agent Alice sends a sendCFP (call for proposal) message containing the public key and query to Agent Bob via the OEF which forwards an onCFP . Agent Bob receives the onCFP event and replies with a sendPropose containing a list of proposals. Bob's sendPropose has the same identifier that came with the onCFP . This means that Alice can refer back to the CFP when she gets the onPropose event. onACK and onDeal finalise the communication (more). Finally, Agent Alice receives the byte payload from Agent Bob on sendMessage . Every message contains the following: dialogue id : the identifier of the dialogue in which the message is sent. destination : the agent identifier to whom the message is sent. message id : the message identifier for the dialogue. target : the identifier of the message to whom this message is answering.","title":"Current implementation"},{"location":"oef/oef-install/","text":"Initial setup First, get Docker . Next, pull our published image. docker pull fetchai/oef-search:latest Grab the configuration file. curl https://docs.fetch.ai/oef/assets/node_config.json \\ --output node_config.json And run the Docker image with the configuration. docker run -it -v ` pwd ` :/config -p 20000 :20000 -p 10000 :10000 -p 40000 :40000 -p 7500 fetchai/oef-search:latest node no_sh --config_file /config/node_config.json A successful run will start producing stats dumps after a few seconds. You'll need to have several ports available on your machine: 10000 , 20000 , 30000 , and 7500 . Get the OEF SDK First, run the pip installation command: pip3 install -v -v -v --no-cache-dir oef After that, let's check we installed the SDK correctly: python3 from oef import agents When a function needs a core address, use 127.0.0.1 and port 10000 . Get the example code Download the working examples bundle . Or curl them here: curl https://docs.fetch.ai/oef/assets/examples.tgz \\ --output examples.tgz","title":"Oef install"},{"location":"oef/oef-install/#initial-setup","text":"First, get Docker . Next, pull our published image. docker pull fetchai/oef-search:latest Grab the configuration file. curl https://docs.fetch.ai/oef/assets/node_config.json \\ --output node_config.json And run the Docker image with the configuration. docker run -it -v ` pwd ` :/config -p 20000 :20000 -p 10000 :10000 -p 40000 :40000 -p 7500 fetchai/oef-search:latest node no_sh --config_file /config/node_config.json A successful run will start producing stats dumps after a few seconds. You'll need to have several ports available on your machine: 10000 , 20000 , 30000 , and 7500 .","title":"Initial setup"},{"location":"oef/oef-install/#get-the-oef-sdk","text":"First, run the pip installation command: pip3 install -v -v -v --no-cache-dir oef After that, let's check we installed the SDK correctly: python3 from oef import agents When a function needs a core address, use 127.0.0.1 and port 10000 .","title":"Get the OEF SDK"},{"location":"oef/oef-install/#get-the-example-code","text":"Download the working examples bundle . Or curl them here: curl https://docs.fetch.ai/oef/assets/examples.tgz \\ --output examples.tgz","title":"Get the example code"},{"location":"oef/public-key/","text":"A valid public key in the OEF contains only Base58 characters, which consist of alphanumeric characters, excluding the following characters: 0 (zero), O (capital o), I (capital i) and l (lower case L). You can generate test addresses with the the ledger-api-py (Python SDK) . Check the documentation here . Or... Generate a public key for your Agent with the crypto.py script which uses the Python cryptography library. Simply instantiate a Crypto object and call the public_key() function. @property def public_key ( self ) -> str : \"\"\" Returns a 219 character public key in base58 format \"\"\" return self . _public_key_b58 The library generates a private key and the function returns a Base58 public key string. Calling public_key() again returns the same public key. In the same script, there are data verification and signing functions. The sign_data() function takes a serialized byte stream of data, signs it, and returns signed data as an immutable sequence of bytes. def sign_data ( self , data : bytes ) -> bytes : \"\"\" Sign data with your own private key. :param data: the data to sign :return: the signature \"\"\" digest = self . _hash_data ( data ) signature = self . _private_key . sign ( digest , ec . ECDSA ( utils . Prehashed ( self . _chosen_hash ))) return signature The is_confirmed_integrity() function verifies signed data against a signature and a public key. def is_confirmed_integrity ( self , data : bytes , signature : bytes , signer_pbk : str ) -> bool : \"\"\" Confirrms the integrity of the data with respect to its signature. :param data: the data to be confirmed :param signature: the signature associated with the data :param signer_pbk: the public key of the signer :return: bool indicating whether the integrity is confirmed or not \"\"\" signer_pbk = self . _pbk_to_obj ( signer_pbk ) digest = self . _hash_data ( data ) try : signer_pbk . verify ( signature , digest , ec . ECDSA ( utils . Prehashed ( self . _chosen_hash ))) return True except CryptoError as e : logger . exception ( str ( e )) return False","title":"Public key"},{"location":"oef/python-API/","text":"// Popup window code function newPopup(url) { popupWindow = window.open( url,'popUpWindow','height=600px,width=900px,left=500,top=60,resizable=yes,scrollbars=yes,toolbar=yes,menubar=yes,location=no,directories=no,status=no') } Click here for the version 0.6x API. Version 0.7x coming soon.","title":"python API"},{"location":"oef/registering/","text":"Agents register to and deregister from the OEF. Before an Agent can advertise or search for services, it must register onto the OEF. AsyncioCore thread management The AsyncioCore class is a thread manager for Agent objects. Instantiate an AsyncioCore class and call the run_threaded() function to start the networking. Call stop() when you're done. core = AsyncioCore ( logger = logger ) core . run_threaded () // do stuff core . stop () Agent creation Create an Agent with a name and public key. The Agent connects to the OEF with the given OEF host and port number. Finally, include the AsyncioCore class in the Agent constructor. The following example builds a weather station agent that is managed by the AsyncioCore class. agent = WeatherStation ( \"weatherStationSecure\" , prv_key_file = \"examples/resources/agent_1.pem\" , oef_addr = \"127.0.0.1\" , oef_port = 10005 , core = core ) agent . connect () On attempting to connect to the OEF, the public key is verified. Include a single AsyncioCore class in many Agent objects. Agent state Query the state parameter of an Agent with get_state() . The Agent returns one of the following self-explanatory strings: offline . connecting . connected . failed . timedout . terminated . Single Agent reacting to arriving messages Call run() on a single Agent after connecting if the Agent is only going to react to arriving messages. This puts the Agent into a loop. The loop sleeps then checks for the Agent state. When the Agent is in a disconnected state, the loop calls stop() on the Agent . if __name__ == \"__main__\" : core = AsyncioCore ( logger = logger ) core . run_threaded () # create and connect the agent agent = WeatherClient ( \"weatherCLient\" , oef_addr = \"127.0.0.1\" , oef_port = 10000 , core = core ) agent . connect () # add queries to the agent try : agent . run () time . sleep ( 3 ) except Exception as ex : print ( \"EXCEPTION:\" , ex ) finally : agent . stop () agent . disconnect () core . stop () Single Agent doing intermittent work If you have an Agent which not only reacts to messages but also has to do some intermittent activity, do not call run() . Instead, after connecting, build a loop that checks the Agent state for some form of disconnection, at which point the loop calls stop() . While the Agent state is not disconnected, perform the required tasks. def doSearch (): # doing search here if __name__ == \"__main__\" : core = AsyncioCore ( logger = logger ) core . run_threaded () # create and connect the agent agent = WeatherClient ( \"weatherCLient\" , oef_addr = \"127.0.0.1\" , oef_port = 10000 , core = core ) agent . connect () # do stuff with the agent try : while agent . get_state () not in [ \"connected\" , \"connecting\" ]: agent . doSearch () time . sleep ( 5 ) except Exception as ex : print ( \"EXCEPTION:\" , ex ) finally : agent . stop () agent . disconnect () core . stop () Multiple Agent scenarios Do not call run() in scenarios in which you have more than one Agent in play. For example, when connecting to multiple OEF cores, set up each Agent and call connect() . Then perform the specific tasks. Note Logger can also be a print function. def doSpecificTasks ( agent ): # do stuff here if __name__ == \"__main__\" : core = AsyncioCore ( logger = print ) core . run_threaded () # create and connect the agent agent1 = WeatherClient ( \"weatherClient1\" , oef_addr = \"127.0.0.1\" , oef_port = 10000 , core = core ) agent1 . connect () agent2 = WeatherClient ( \"weatherClient2\" , oef_addr = \"127.0.0.1\" , oef_port = 10001 , core = core ) agent2 . connect () # add queries to the agent try while agent1 . get_state () in [ \"connected\" , \"connecting\" ] and agent2 . get_state () in [ \"connected\" , \"connecting\" ]: doSpecificTasks ( agent1 ) doSpecificTasks ( agent2 ) time . sleep ( 5 ) except Exception as ex : print ( \"EXCEPTION:\" , ex ) finally : agent1 . stop () agent1 . disconnect () agent2 . stop () agent2 . disconnect () core . stop () Role names An Agent can perform several roles at once. In order to distinguish between roles, an Agent supplies a different name for each role. This means that an agent could advertise several services using the same public key but different roles names, such as in this example: Public key and role name Data members advertised DEADBEEF/newspaper_seller available_newspaper_list available_magazine_list DEADBEEF/refuelling_station petrol_availability diesel_availability When an Agent conducts a search, it receives the public key and the role name of Agent(s) who are advertising matching services. A role name can be empty. This is the default case and can be used for simple Agent setups. In order to talk to Agents with multiple services, we use a Context which contains source and target information for every message. The target information, key and role, references the receiving Agent. Similarly the source information references the sending Agent. To send a reply the other way, the two parts can simply be swapped.","title":"Registering"},{"location":"oef/registering/#asynciocore-thread-management","text":"The AsyncioCore class is a thread manager for Agent objects. Instantiate an AsyncioCore class and call the run_threaded() function to start the networking. Call stop() when you're done. core = AsyncioCore ( logger = logger ) core . run_threaded () // do stuff core . stop ()","title":"AsyncioCore thread management"},{"location":"oef/registering/#agent-creation","text":"Create an Agent with a name and public key. The Agent connects to the OEF with the given OEF host and port number. Finally, include the AsyncioCore class in the Agent constructor. The following example builds a weather station agent that is managed by the AsyncioCore class. agent = WeatherStation ( \"weatherStationSecure\" , prv_key_file = \"examples/resources/agent_1.pem\" , oef_addr = \"127.0.0.1\" , oef_port = 10005 , core = core ) agent . connect () On attempting to connect to the OEF, the public key is verified. Include a single AsyncioCore class in many Agent objects.","title":"Agent creation"},{"location":"oef/registering/#agent-state","text":"Query the state parameter of an Agent with get_state() . The Agent returns one of the following self-explanatory strings: offline . connecting . connected . failed . timedout . terminated .","title":"Agent state"},{"location":"oef/registering/#single-agent-reacting-to-arriving-messages","text":"Call run() on a single Agent after connecting if the Agent is only going to react to arriving messages. This puts the Agent into a loop. The loop sleeps then checks for the Agent state. When the Agent is in a disconnected state, the loop calls stop() on the Agent . if __name__ == \"__main__\" : core = AsyncioCore ( logger = logger ) core . run_threaded () # create and connect the agent agent = WeatherClient ( \"weatherCLient\" , oef_addr = \"127.0.0.1\" , oef_port = 10000 , core = core ) agent . connect () # add queries to the agent try : agent . run () time . sleep ( 3 ) except Exception as ex : print ( \"EXCEPTION:\" , ex ) finally : agent . stop () agent . disconnect () core . stop ()","title":"Single Agent reacting to arriving messages"},{"location":"oef/registering/#single-agent-doing-intermittent-work","text":"If you have an Agent which not only reacts to messages but also has to do some intermittent activity, do not call run() . Instead, after connecting, build a loop that checks the Agent state for some form of disconnection, at which point the loop calls stop() . While the Agent state is not disconnected, perform the required tasks. def doSearch (): # doing search here if __name__ == \"__main__\" : core = AsyncioCore ( logger = logger ) core . run_threaded () # create and connect the agent agent = WeatherClient ( \"weatherCLient\" , oef_addr = \"127.0.0.1\" , oef_port = 10000 , core = core ) agent . connect () # do stuff with the agent try : while agent . get_state () not in [ \"connected\" , \"connecting\" ]: agent . doSearch () time . sleep ( 5 ) except Exception as ex : print ( \"EXCEPTION:\" , ex ) finally : agent . stop () agent . disconnect () core . stop ()","title":"Single Agent doing intermittent work"},{"location":"oef/registering/#multiple-agent-scenarios","text":"Do not call run() in scenarios in which you have more than one Agent in play. For example, when connecting to multiple OEF cores, set up each Agent and call connect() . Then perform the specific tasks. Note Logger can also be a print function. def doSpecificTasks ( agent ): # do stuff here if __name__ == \"__main__\" : core = AsyncioCore ( logger = print ) core . run_threaded () # create and connect the agent agent1 = WeatherClient ( \"weatherClient1\" , oef_addr = \"127.0.0.1\" , oef_port = 10000 , core = core ) agent1 . connect () agent2 = WeatherClient ( \"weatherClient2\" , oef_addr = \"127.0.0.1\" , oef_port = 10001 , core = core ) agent2 . connect () # add queries to the agent try while agent1 . get_state () in [ \"connected\" , \"connecting\" ] and agent2 . get_state () in [ \"connected\" , \"connecting\" ]: doSpecificTasks ( agent1 ) doSpecificTasks ( agent2 ) time . sleep ( 5 ) except Exception as ex : print ( \"EXCEPTION:\" , ex ) finally : agent1 . stop () agent1 . disconnect () agent2 . stop () agent2 . disconnect () core . stop ()","title":"Multiple Agent scenarios"},{"location":"oef/registering/#role-names","text":"An Agent can perform several roles at once. In order to distinguish between roles, an Agent supplies a different name for each role. This means that an agent could advertise several services using the same public key but different roles names, such as in this example: Public key and role name Data members advertised DEADBEEF/newspaper_seller available_newspaper_list available_magazine_list DEADBEEF/refuelling_station petrol_availability diesel_availability When an Agent conducts a search, it receives the public key and the role name of Agent(s) who are advertising matching services. A role name can be empty. This is the default case and can be used for simple Agent setups. In order to talk to Agents with multiple services, we use a Context which contains source and target information for every message. The target information, key and role, references the receiving Agent. Similarly the source information references the sending Agent. To send a reply the other way, the two parts can simply be swapped.","title":"Role names"},{"location":"oef/running-a-node/","text":"First, get Docker . Next, pull and launch our published image. docker pull fetchai/oef-search:latest Now download the node_config.json file. And run the Docker image with the configuration. docker run -it -v ` pwd ` :/config -p 20000 :20000 -p 10000 :10000 -p 40000 :40000 -p 7500 fetchai/oef-search:latest /config/node_config.json A successful run will start producing stats dumps after a few seconds. You'll need to have several ports available on your machine: 10000 , 20000 , 30000 , and 7500 . Now we have a node up and running, let's get the SDK.","title":"Running a node"},{"location":"oef/sdk/","text":"We will focus solely on Python SDK examples throughout the documentation. Python First, run the pip installation command: pip3 install -v -v -v --no-cache-dir oef After that, let's check we installed the SDK correctly: python3 from oef import agents When a function needs a core address, use 127.0.0.1 and port 10000 . Now download the working examples bundle .","title":"Sdk"},{"location":"oef/sdk/#python","text":"First, run the pip installation command: pip3 install -v -v -v --no-cache-dir oef After that, let's check we installed the SDK correctly: python3 from oef import agents When a function needs a core address, use 127.0.0.1 and port 10000 . Now download the working examples bundle .","title":"Python"},{"location":"oef/searching/","text":"Agent nodes search for services advertised by other Agents. The OEF manages the search process. In the example below, Agent Alice is looking for hotel rooms. Agent Bob is a node that has advertised hotel booking services. The OEF matches them up. Agent Alice is a node connected to the OEF 001 . She wants to book a hotel room and sends a search request to the OEF. Exactly what a search looks like is up to the agent. In this case, a search should contain the rough location and other specifics. For example, a hotel room provider may advertise a schema containing room availability , parking available , breakfast included , etc. The OEF nodes communicate with each other to find suitable matching agents. Agent Bob looks ideal. OEF 001 returns a list of Agents, their IDs, the OEF node they're attached to, and how to reach it, i.e. an IP address or hostname and port number. Alice decides to talk to Bob. She connects to a shared OEF 078 with the host and port combination she received. At connection time, Alice supplies her ID and answers a verification challenge given by the OEF. Agent Alice verifies successfully and OEF 078 starts talking to Alice. Alice can now ask the OEF to send a message to Bob on her behalf. She uses the ID from the search results as the target and adds her message; in this case a suitable CFP (Call For Proposal) to initiate a conversation with Bob. The OEF sends Alice's message on to Bob along with any other messages Bob is currently receiving from other agents. Wide and narrow searches There are two types of search the OEF supports, wide and narrow searches. A wide search will generate results from Agents not directly connected to the search initiating Agent. A narrow search will only generate results from Agents connected directly to the same OEF node. For example, in the following diagram, when Charlene does a wide search, results come back from Alice, Bob, and Damian. When Charlene does a narrow search, she only gets results from Damian. Query language The Query API allows you to: Query the OEF Node about specific kind of services. Query other agents to ask them about desired resources. A query is a set of constraints , defined over a data model . The outcome is a set of descriptions matching the query. In the next sections, we describe how to build queries with the Python SDK. Constraints A constraint is associated with an attribute name and imposes limitations on the values the attribute can assume. There are different types of constraints: relation The author of the book must be Stephen King . The publication year must be greater than 1990. set The genre must fall into the following set of genres: Horror , Science fiction , Non-fiction . range The average rating must be between 3.5 and 4.5. distance The nearest bookshop must be within a distance from a given location. The following descriptions and Python examples take you through the query constraint types: Relation Equal Not equal Less than Less than or equal Greater than Greater than or equal from oef.query import Constraint , Eq , NotEq , Lt , LtEq , Gt , GtEq # all the books whose author is Stephen King Constraint ( \"author\" , Eq ( \"Stephen King\" )) # all the books that are not of the genre Horror Constraint ( \"genre\" , NotEq ( \"Horror\" )) # all the books published before 1990 Constraint ( \"year\" , Lt ( 1990 )) # the same of before, but including 1990 Constraint ( \"year\" , LtEq ( 1990 )) # all the books with rating greater than 4.0 Constraint ( \"average_rating\" , Gt ( 4.0 )) # all the books published after 2000, included Constraint ( \"year\" , GtEq ( 2000 )) Set Set is a constraint type that allows you to restrict the values of the attribute in a specific set. There are two kind of Set constraints: In (a set of values) Not in (a set of values) from oef.query import Constraint , In , NotIn # all the books whose genre is one of `Horror`, `Science fiction`, `Non-fiction` Constraint ( \"genre\" , In ([ \"horror\" , \"science fiction\" , \"non-fiction\" ])) # all the books that have not been published neither in 1990, nor in 1995, nor in 2000 Constraint ( \"year\" , NotIn ([ 1990 , 1995 , 2000 ])) Range Range is a constraint type that allows you to restrict the values of the attribute within a given range. from oef.query import Constraint , Range # all the books whose title is between 'A' and 'B' (alphanumeric order) Constraint ( \"title\" , Range (( \"A\" , \"B\" ))) # all the books that have been published between 1960 and 1970 Constraint ( \"genre\" , Range (( 1960 , 1970 )) Distance Distance is a constraint type that allows you to put a limit on a Location . More specifically, you can set a maximum distance from a given location (the center ). from oef.query import Constraint , Distance from oef.schema import Location , Description # define a location of interest, e.g. the Tour Eiffel tour_eiffel = Location ( 48.8581064 , 2.29447 ) # find all the locations close to the Tour Eiffel within 1 km close_to_tour_eiffel = Constraint ( \"position\" , Distance ( tour_eiffel , 1.0 )) # Le Jules Verne, a famous restaurant close to the Tour Eiffel, satisfies the constraint. le_jules_verne_restaurant = Location ( 48.8579675 , 2.2951849 ) close_to_tour_eiffel . check ( Description ({ \"position\" : le_jules_verne_restaurant })) # gives `True` # The Colosseum does not satisfy the constraint (farther than 1 km from the Tour Eiffel). colosseum = Location ( 41.8902102 , 12.4922309 ) close_to_tour_eiffel . check ( Description ({ \"position\" : colosseum })) # gives `False` Constraint expressions The constraints above can be combined with common logical operators, i.e. and , or , and not using he Not , And , and Or classes. In particular we can specify any conjunction, disjunction, or negation of the previous constraints or composite constraint expression(s). For example: Books that belong to Horror genre and were published after 2000 but not authored by Stephen King . Books whose author is either J. K. Rowling or J. R. R. Tolkien . Not Not allows you to specify a negation of a constraint expression. from oef.query import Constraint , Not , Range # all the books whose year of publication is not between 1990 and 2000 Not ( Constraint ( \"year\" , Range (( 1990 , 2000 ))) And And allows you to specify a conjunction of constraints over an attribute. There must be at least 2 sub-expressions. from oef.query import Constraint , And , NotEq , Range # all the books whose title is between 'I' and 'J' (alphanumeric order) but not equal to 'It' And ([ Constraint ( \"title\" , Range (( \"I\" , \"J\" ))), Constraint ( \"title\" , NotEq ( \"It\" ))]) Or Or allows you to specify a disjunction of constraints. The number of sub-expressions must be at least 2. from oef.query import Constraint , Or , Lt , Gt # all the books that have been published either before the year 1960 or after the year 1970 Or ([ Constraint ( \"year\" , Lt ( 1960 )), Constraint ( \"year\" , Gt ( 1970 ))]) Queries A query is a list of constraint expressions . from oef.query import Query , Constraint , Eq , Gt , Eq # return all the books written by Stephen King published after 1990, and available as an e-book: Query ([ Constraint ( \"author\" , Eq ( \"Stephen King\" )), Constraint ( \"year\" , Gt ( 1990 )), Constraint ( \"ebook_available\" , Eq ( True )) ], book_model ) Where book_model is the DataModel object. Although the DataModel is an optional parameter, we recommended including it. The check method The check method checks whether a Description matches the Query . from oef.query import Query , Constraint , Eq , Gt , Eq from oef.schema import Description q = Query ([ Constraint ( \"author\" , Eq ( \"Stephen King\" )), Constraint ( \"year\" , Gt ( 1990 )), Constraint ( \"ebook_available\" , Eq ( True )) ]) # With a query, you can check that a `~oef.schema.Description` object satisfies the constraints. q . check ( Description ({ \"author\" : \"Stephen King\" , \"year\" : 1991 , \"ebook_available\" : True })) # True q . check ( Description ({ \"author\" : \"George Orwell\" , \"year\" : 1948 , \"ebook_available\" : False })) # False Validity A Query object must satisfy some conditions before it can be instantiated. There must be at least one constraint expression. If the data model is specified, then each constraint expression much be validated against the data model. A ConstraintExpr c is valid with respect to a DataModel according to the following: If c is an instance of And , Or , or Not , then every subexpression of c must be valid with respect to the data model. If c is an instance of Constraint , then: if the constraint type is one of Lt , LtEq , Gt , or GtEq , the value in the constructor must be str , int , or float . if the constraint type is a Range , then the types in the range must be int , str , float , or Location . if the constraint type is a Distance , then the only valid type is Location . if the constraint type is a Set , then the types supported are str , int , float , bool , Location . Notice that a set of bool is trivial, so you may find yourself more comfortable using an alternative. for the other constraint types, i.e. Eq and NotEq , the value can be one of the allowed types for AttributeSchema , that is str , int , float , bool , Location . Moreover, when c is a Constraint , the attribute must have a consistent type with regards to the data model. For example: Constraint ( \"foo\" , Eq ( True ))) Consider a DataModel where there is an AttributeSchema foo of type str . Then the constraint is not compatible with the mentioned data model, because the constraint expects an equality comparison with a boolean True , instead of a str .","title":"Searching"},{"location":"oef/searching/#wide-and-narrow-searches","text":"There are two types of search the OEF supports, wide and narrow searches. A wide search will generate results from Agents not directly connected to the search initiating Agent. A narrow search will only generate results from Agents connected directly to the same OEF node. For example, in the following diagram, when Charlene does a wide search, results come back from Alice, Bob, and Damian. When Charlene does a narrow search, she only gets results from Damian.","title":"Wide and narrow searches"},{"location":"oef/searching/#query-language","text":"The Query API allows you to: Query the OEF Node about specific kind of services. Query other agents to ask them about desired resources. A query is a set of constraints , defined over a data model . The outcome is a set of descriptions matching the query. In the next sections, we describe how to build queries with the Python SDK.","title":"Query language"},{"location":"oef/searching/#constraint-expressions","text":"The constraints above can be combined with common logical operators, i.e. and , or , and not using he Not , And , and Or classes. In particular we can specify any conjunction, disjunction, or negation of the previous constraints or composite constraint expression(s). For example: Books that belong to Horror genre and were published after 2000 but not authored by Stephen King . Books whose author is either J. K. Rowling or J. R. R. Tolkien .","title":"Constraint expressions"},{"location":"oef/searching/#queries","text":"A query is a list of constraint expressions . from oef.query import Query , Constraint , Eq , Gt , Eq # return all the books written by Stephen King published after 1990, and available as an e-book: Query ([ Constraint ( \"author\" , Eq ( \"Stephen King\" )), Constraint ( \"year\" , Gt ( 1990 )), Constraint ( \"ebook_available\" , Eq ( True )) ], book_model ) Where book_model is the DataModel object. Although the DataModel is an optional parameter, we recommended including it.","title":"Queries"},{"location":"oef/searching/#validity","text":"A Query object must satisfy some conditions before it can be instantiated. There must be at least one constraint expression. If the data model is specified, then each constraint expression much be validated against the data model. A ConstraintExpr c is valid with respect to a DataModel according to the following: If c is an instance of And , Or , or Not , then every subexpression of c must be valid with respect to the data model. If c is an instance of Constraint , then: if the constraint type is one of Lt , LtEq , Gt , or GtEq , the value in the constructor must be str , int , or float . if the constraint type is a Range , then the types in the range must be int , str , float , or Location . if the constraint type is a Distance , then the only valid type is Location . if the constraint type is a Set , then the types supported are str , int , float , bool , Location . Notice that a set of bool is trivial, so you may find yourself more comfortable using an alternative. for the other constraint types, i.e. Eq and NotEq , the value can be one of the allowed types for AttributeSchema , that is str , int , float , bool , Location . Moreover, when c is a Constraint , the attribute must have a consistent type with regards to the data model. For example: Constraint ( \"foo\" , Eq ( True ))) Consider a DataModel where there is an AttributeSchema foo of type str . Then the constraint is not compatible with the mentioned data model, because the constraint expects an equality comparison with a boolean True , instead of a str .","title":"Validity"},{"location":"tutorials/","text":"Tutorials Smart Contracts and Etch Hello world smart contract Deploying an Etch contract with Python Create FIP-1 token generation contract (basic contract, non-fungible)","title":"Introduction"},{"location":"tutorials/fet1/","text":"Create a token smart contract Most people interact with smart contracts that handle the issuance of tokens, such as the well known Ethereum ERC20 . Most token contracts are either: Non-fungible tokens (NFT): These are like collectables, as they cannot be split; you can't cut a baseball collector's card and have two that are worth 50% of the original. One of the most well-known of these is Cryptokitties . Most non-fungible tokens are ERC721 . Fungible tokens (FT): Fungible can be split, and are used for most token issuance. The circulating supply, the issuance foundation and the list of where the tokens are are held and enforced by a smart contract. Most fungible tokens on Ethereum, including non-native FET tokens, are based on ERC20 . In this tutorial, we are going to develop a fungible token contract. Note As Fetch.ai smart contracts do not have implicit addresses (as in Ethereum), the function signatures are slightly different, but the overall functionality remains the same. Initialisation function We first define the contract constructor function which is annotated with the @init keyword. The @init annotation tells the ledger that the function should be invoked upon initial deployment of the contract: persistent sharded balance_state : UInt64 ; persistent supply_state : UInt64 ; @init function init ( owner : Address ) use supply_state ; use balance_state [ owner ] ; supply_state . set ( 100000 u64 ); balance_state . set ( owner , 100000 u64 ); endfunction The transaction that submits the contract to the ledger is responsible for providing the constructor arguments. The above @init function creates a state for the owner issuing supply tokens. Furthermore, for this specific contract we have made the total supply programmable so that the contract can be reused and to facilitate testing. Queries Functions labeled with @query do not alter state, and they return a value to the caller. There can be many of these in a single contract. In this contract, they are used to return the contract name, total supply, and get the balance of an address. getName simply returns the contract name without further calculations: @query function getName (): String return \"FIP-1 fungible token\" ; endfunction The other two query mechanisms demonstrate two different ways of handling undefined states. totalSupply queries the state variable total_supply and returns it as a result: @query function totalSupply (): UInt64 use supply_state ; return supply_state . get (); endfunction On the other hand, balanceOf uses the sharded state of balance_state and does a dynamic look up based on an address . If the variable does not exist, it returns 0 . @query function balanceOf ( address : Address ) : UInt64 use balance_state [ address ] ; return balance_state . get ( address , 0 u64 ); endfunction Actions The FIP-1 contract defines one function annotated with @action . Actions can alter state and return a value. Like with queries, a contract can contain many of these. The only action in this contract transfers an amount between two different addresses. The source of the transfer has to be the caller of the @action , and the function is responsible for checking that the source address has signed the transaction. @action function transfer ( from : Address , to : Address , value : UInt64 ) : Bool if ( ! from . signedTx ()) return false ; endif if ( from == to ) return false ; endif use balance_state [ from , to ] ; var from_balance = balance_state . get ( from , 0 u64 ); var to_balance = balance_state . get ( to , 0 u64 ); if ( from_balance < value ) return false ; endif var u_from = from_balance - value ; var u_to = to_balance + value ; balance_state . set ( from , u_from ); balance_state . set ( to , u_to ); return true ; endfunction You can find the full contract here . Implementing allowance So far, the functions we have seen constitute a basic token contract to create and transfer tokens between participants. A more interesting functionality is the allowance mechanism in the FIP-1 contract, that gives one address the possibility of spending some amount based on the allowance details. To create this functionality we could use the normal State object by simply defining the object identifiers. However, a more appropriate mechanism for this purpose is the ShardedState which ensures that the payload is assigned to an appropriate shard within the system. Implementing the approve mechanism using the ShardedState is relatively easy as it provides dictionary-like functionality: @action function approve ( owner : Address , spender : Address , value : UInt256 ) : Bool var state = ShardedState < UInt256 > ( spender ); state . set ( owner , value ); return true ; endfunction The above builds object addresses by concatenating the spender address with the owner address. However, unlike a normal dictionary, ShardedState does not keep a record of which entries exist or not. Such functionality could be added by simply adding another state variable keeping track of owners. We will see an example on a similar type of functionality in the next part of this guide. Finally, implementing a query mechanism is equally straight forward: @query function allowance ( owner : Address , spender : Address ) : UInt256 var state = ShardedState < UInt256 > ( spender ); return state . get ( owner , UInt256 ( 0 u64 )); endfunction The contract provided here still needs additional functionality for allowance to be truly useful, as we have not implemented any method to actually spend the allowance.","title":"Create FET-1 contract"},{"location":"tutorials/fet1/#create-a-token-smart-contract","text":"Most people interact with smart contracts that handle the issuance of tokens, such as the well known Ethereum ERC20 . Most token contracts are either: Non-fungible tokens (NFT): These are like collectables, as they cannot be split; you can't cut a baseball collector's card and have two that are worth 50% of the original. One of the most well-known of these is Cryptokitties . Most non-fungible tokens are ERC721 . Fungible tokens (FT): Fungible can be split, and are used for most token issuance. The circulating supply, the issuance foundation and the list of where the tokens are are held and enforced by a smart contract. Most fungible tokens on Ethereum, including non-native FET tokens, are based on ERC20 . In this tutorial, we are going to develop a fungible token contract. Note As Fetch.ai smart contracts do not have implicit addresses (as in Ethereum), the function signatures are slightly different, but the overall functionality remains the same.","title":"Create a token smart contract"},{"location":"tutorials/fet1/#initialisation-function","text":"We first define the contract constructor function which is annotated with the @init keyword. The @init annotation tells the ledger that the function should be invoked upon initial deployment of the contract: persistent sharded balance_state : UInt64 ; persistent supply_state : UInt64 ; @init function init ( owner : Address ) use supply_state ; use balance_state [ owner ] ; supply_state . set ( 100000 u64 ); balance_state . set ( owner , 100000 u64 ); endfunction The transaction that submits the contract to the ledger is responsible for providing the constructor arguments. The above @init function creates a state for the owner issuing supply tokens. Furthermore, for this specific contract we have made the total supply programmable so that the contract can be reused and to facilitate testing.","title":"Initialisation function"},{"location":"tutorials/fet1/#queries","text":"Functions labeled with @query do not alter state, and they return a value to the caller. There can be many of these in a single contract. In this contract, they are used to return the contract name, total supply, and get the balance of an address. getName simply returns the contract name without further calculations: @query function getName (): String return \"FIP-1 fungible token\" ; endfunction The other two query mechanisms demonstrate two different ways of handling undefined states. totalSupply queries the state variable total_supply and returns it as a result: @query function totalSupply (): UInt64 use supply_state ; return supply_state . get (); endfunction On the other hand, balanceOf uses the sharded state of balance_state and does a dynamic look up based on an address . If the variable does not exist, it returns 0 . @query function balanceOf ( address : Address ) : UInt64 use balance_state [ address ] ; return balance_state . get ( address , 0 u64 ); endfunction","title":"Queries"},{"location":"tutorials/fet1/#actions","text":"The FIP-1 contract defines one function annotated with @action . Actions can alter state and return a value. Like with queries, a contract can contain many of these. The only action in this contract transfers an amount between two different addresses. The source of the transfer has to be the caller of the @action , and the function is responsible for checking that the source address has signed the transaction. @action function transfer ( from : Address , to : Address , value : UInt64 ) : Bool if ( ! from . signedTx ()) return false ; endif if ( from == to ) return false ; endif use balance_state [ from , to ] ; var from_balance = balance_state . get ( from , 0 u64 ); var to_balance = balance_state . get ( to , 0 u64 ); if ( from_balance < value ) return false ; endif var u_from = from_balance - value ; var u_to = to_balance + value ; balance_state . set ( from , u_from ); balance_state . set ( to , u_to ); return true ; endfunction You can find the full contract here .","title":"Actions"},{"location":"tutorials/fet1/#implementing-allowance","text":"So far, the functions we have seen constitute a basic token contract to create and transfer tokens between participants. A more interesting functionality is the allowance mechanism in the FIP-1 contract, that gives one address the possibility of spending some amount based on the allowance details. To create this functionality we could use the normal State object by simply defining the object identifiers. However, a more appropriate mechanism for this purpose is the ShardedState which ensures that the payload is assigned to an appropriate shard within the system. Implementing the approve mechanism using the ShardedState is relatively easy as it provides dictionary-like functionality: @action function approve ( owner : Address , spender : Address , value : UInt256 ) : Bool var state = ShardedState < UInt256 > ( spender ); state . set ( owner , value ); return true ; endfunction The above builds object addresses by concatenating the spender address with the owner address. However, unlike a normal dictionary, ShardedState does not keep a record of which entries exist or not. Such functionality could be added by simply adding another state variable keeping track of owners. We will see an example on a similar type of functionality in the next part of this guide. Finally, implementing a query mechanism is equally straight forward: @query function allowance ( owner : Address , spender : Address ) : UInt256 var state = ShardedState < UInt256 > ( spender ); return state . get ( owner , UInt256 ( 0 u64 )); endfunction The contract provided here still needs additional functionality for allowance to be truly useful, as we have not implemented any method to actually spend the allowance.","title":"Implementing allowance"},{"location":"tutorials/fet2/","text":"Create an FET-2 contract In this tutorial we are going to implement a subset of the functionality of an FET-2 contract in etch . We will be using UInt256 for identifiers and the SHA256() function to generate the identifiers of the initial tokens. We will need two records: an Address stating which tokens an address holds and a token record keeping track of the owner of the token. For the first of these tasks, we will use the State object in etch , and for the second we will use ShardedState . Initialisation function Assuming that we have defined an owner and a total_supply , the initialise function will do three things: Generate a list of token ids. Create a record of each token owner. Create a record of the tokens that an owner has. The dual relationship makes lookups efficient, but comes at the price of twice the book keeping. First, create the list of token ids: // Genereating tokens var token_id = UInt256 ( \"hello world\" ); for ( i in 0 : tokens . count ()) var hasher = SHA256 (); hasher . update ( token_id ); token_id = hasher . final (); tokens [ i ] = token_id ; endfor Next, assign an owner: // Assigning owner var owner_state = ShardedState < Address > ( \"tokens.owner\" ); for ( i in 0 : tokens . count ()) var tid = tokens [ i ]; owner_state . set ( toString ( tid ), owner ); endfor Finally, store the list of tokens on the creator's address: var objects_state = State < Array < UInt256 > > ( owner ); // Storing the tokens on the owners address objects_state . set ( tokens ); Queries In this section we will focus on the functions which implement a wallet overview and token details view, namely balanceOf(owner: Address) : UInt256 and ownerOf(token_id: UInt256) : Address . Both of these functions are short and easy to implement. First, we make it possible to query the balance: @ query function balanceOf ( owner : Address ) : UInt256 var objects_state = State < Array < UInt256 > > ( owner ); var tokens = objects_state . get ( Array < UInt256 > ( 0 ) ); var ret = UInt256 ( toUInt64 ( tokens . count ()) ); return ret ; endfunction Next, we make it possible to query the token owner: @ query function ownerOf ( token_id : UInt256 ) : Address var owner_state = ShardedState < Address > ( \"tokens.owner\" ); return owner_state . get ( toString ( token_id )); endfunction With these two query functions, it is possible to implement an FET-2 wallet on top of the smart ledger. We can also make several optimisations for these functions. For instance, by storing the number of tokens separately, we would not have to deserialise the full array. Actions The standard FET-2 contract has a number of different functions for transferring funds from one party to another. We will implement just one of these; they are all essentially variations of the same mechanism with more or less error checking built into them. Implement a single transfer function: function transferFrom ( from : Address , to : Address , token_id : UInt256 ) if ( ! from . signedTx ()) panic ( \"Invalid signature from owner.\" ); endif var owner_state = ShardedState < Address > ( \"tokens.owner\" ); var owner = owner_state . get ( toString ( token_id )); if ( owner != from ) panic ( \"Owner does not actually own the token\" ); endif var from_state = State < Array < UInt256 > > ( from ); var from_objects = from_state . get ( Array < UInt256 > ( 0 ) ); var found = false ; var position : Int32 ; for ( i in 0 : from_objects . count ()) var tid = from_objects [ i ]; if ( tid == token_id ) if ( found ) panic ( \"Contract broken - token is only supposed be represented once.\" ); endif found = true ; position = i ; break ; endif endfor if ( ! found ) panic ( \"Contract is fundamentally broken - owner has not been updated correctly\" ); endif from_objects [ position ] = from_objects [ from_objects . count () - 1 ]; from_objects . popBack (); var to_state = State < Array < UInt256 > > ( to ); var to_objects = to_state . get ( Array < UInt256 > ( 0 ) ); to_objects . append ( token_id ); // updating sender from_state . set ( from_objects ); // Updating receiver to_state . set ( to_objects ); // Updating owner owner = to ; owner_state . set ( toString ( token_id ), owner ); endfunction The above implementation requires the sender to sign the transaction, but can be extended to also requiring the receiver to sign as well. The full contract can be found here .","title":"Create an FET-2 contract"},{"location":"tutorials/fet2/#create-an-fet-2-contract","text":"In this tutorial we are going to implement a subset of the functionality of an FET-2 contract in etch . We will be using UInt256 for identifiers and the SHA256() function to generate the identifiers of the initial tokens. We will need two records: an Address stating which tokens an address holds and a token record keeping track of the owner of the token. For the first of these tasks, we will use the State object in etch , and for the second we will use ShardedState .","title":"Create an FET-2 contract"},{"location":"tutorials/fet2/#initialisation-function","text":"Assuming that we have defined an owner and a total_supply , the initialise function will do three things: Generate a list of token ids. Create a record of each token owner. Create a record of the tokens that an owner has. The dual relationship makes lookups efficient, but comes at the price of twice the book keeping. First, create the list of token ids: // Genereating tokens var token_id = UInt256 ( \"hello world\" ); for ( i in 0 : tokens . count ()) var hasher = SHA256 (); hasher . update ( token_id ); token_id = hasher . final (); tokens [ i ] = token_id ; endfor Next, assign an owner: // Assigning owner var owner_state = ShardedState < Address > ( \"tokens.owner\" ); for ( i in 0 : tokens . count ()) var tid = tokens [ i ]; owner_state . set ( toString ( tid ), owner ); endfor Finally, store the list of tokens on the creator's address: var objects_state = State < Array < UInt256 > > ( owner ); // Storing the tokens on the owners address objects_state . set ( tokens );","title":"Initialisation function"},{"location":"tutorials/fet2/#queries","text":"In this section we will focus on the functions which implement a wallet overview and token details view, namely balanceOf(owner: Address) : UInt256 and ownerOf(token_id: UInt256) : Address . Both of these functions are short and easy to implement. First, we make it possible to query the balance: @ query function balanceOf ( owner : Address ) : UInt256 var objects_state = State < Array < UInt256 > > ( owner ); var tokens = objects_state . get ( Array < UInt256 > ( 0 ) ); var ret = UInt256 ( toUInt64 ( tokens . count ()) ); return ret ; endfunction Next, we make it possible to query the token owner: @ query function ownerOf ( token_id : UInt256 ) : Address var owner_state = ShardedState < Address > ( \"tokens.owner\" ); return owner_state . get ( toString ( token_id )); endfunction With these two query functions, it is possible to implement an FET-2 wallet on top of the smart ledger. We can also make several optimisations for these functions. For instance, by storing the number of tokens separately, we would not have to deserialise the full array.","title":"Queries"},{"location":"tutorials/fet2/#actions","text":"The standard FET-2 contract has a number of different functions for transferring funds from one party to another. We will implement just one of these; they are all essentially variations of the same mechanism with more or less error checking built into them. Implement a single transfer function: function transferFrom ( from : Address , to : Address , token_id : UInt256 ) if ( ! from . signedTx ()) panic ( \"Invalid signature from owner.\" ); endif var owner_state = ShardedState < Address > ( \"tokens.owner\" ); var owner = owner_state . get ( toString ( token_id )); if ( owner != from ) panic ( \"Owner does not actually own the token\" ); endif var from_state = State < Array < UInt256 > > ( from ); var from_objects = from_state . get ( Array < UInt256 > ( 0 ) ); var found = false ; var position : Int32 ; for ( i in 0 : from_objects . count ()) var tid = from_objects [ i ]; if ( tid == token_id ) if ( found ) panic ( \"Contract broken - token is only supposed be represented once.\" ); endif found = true ; position = i ; break ; endif endfor if ( ! found ) panic ( \"Contract is fundamentally broken - owner has not been updated correctly\" ); endif from_objects [ position ] = from_objects [ from_objects . count () - 1 ]; from_objects . popBack (); var to_state = State < Array < UInt256 > > ( to ); var to_objects = to_state . get ( Array < UInt256 > ( 0 ) ); to_objects . append ( token_id ); // updating sender from_state . set ( from_objects ); // Updating receiver to_state . set ( to_objects ); // Updating owner owner = to ; owner_state . set ( toString ( token_id ), owner ); endfunction The above implementation requires the sender to sign the transaction, but can be extended to also requiring the receiver to sign as well. The full contract can be found here .","title":"Actions"},{"location":"tutorials/python-deployment/","text":"Deploying an Etch Contract with the Python Ledger API The following tutorial assumes that you already have a constellation instance running on port 8000 and that you have installed the the Python API. Details for running a node are here . Details of the Python API are here . Requirements We're going to keep this simple, and refer to FIP-1, our basic token generation contract. The FIP-1 contract implements the following functions: totalSupply() : UInt256 gets the total token supply. balanceOf(owner: Address): UInt256 gets the balance of an account having address owner . transfer(to: Address, value: UInt256) : Bool sends value amount of tokens to address to . Deploying the contract: We're going to create a new script, let's call it deploy.py Import Let's get the initial things out of the way, let's import: from fetchai.ledger.api import LedgerApi , TokenApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address from contextlib import contextmanager Connect to network Then, connect to a local running node: api = None if api is None : api = LedgerApi ( host = \"127.0.0.1\" , port = 8000 ) Setup accounts Now, we'll read in our etch contract, and create a couple of entities to test with: with open ( 'contract.txt' , 'r' ) as ct : contract_text = ct . read () print ( contract_text ) # create our first private key pair entity1 = Entity () address1 = Address ( entity1 ) # create a second private key pair entity2 = Entity () address2 = Address ( entity2 ) Create balance To test, we need a balance: api . sync ( api . tokens . wealth ( entity1 , 10000 )) (Note this will functionality will be removed and a faucet will take it's place). Create the smart contract object We create the contract object, and deploy it: contract = Contract ( contract_text , entity1 ) api . sync ( contract . create ( api , entity1 , 4000 )) Query the contract The named argument has to be the exact name of the variable we're accessing in balanceOf for example, if the state had a named var of \"userX\" the below code would be: print (contract.query(api, 'balanceOf', userX=address1)) this is an important note for other functions you might create. print ( contract . query ( api , 'totalSupply' )) print ( contract . query ( api , 'balanceOf' , address = address1 )) Make a transaction Using the two entities we created earlier, and their addressed we transact 200 from entity1 to entity2, then check the balance: # transfer from one to the other using our newly deployed contract tok_transfer_amount = 200 fet_tx_fee = 160 api . sync ( contract . action ( api , 'transfer' , fet_tx_fee , [ entity1 ], address1 , address2 , tok_transfer_amount )) #Query new balance: print ( contract . query ( api , 'balanceOf' , address = address1 )) You can find the source here .","title":"Deploying an Etch contract with Python"},{"location":"tutorials/python-deployment/#deploying-an-etch-contract-with-the-python-ledger-api","text":"The following tutorial assumes that you already have a constellation instance running on port 8000 and that you have installed the the Python API. Details for running a node are here . Details of the Python API are here .","title":"Deploying an Etch Contract with the Python Ledger API"},{"location":"tutorials/python-deployment/#requirements","text":"We're going to keep this simple, and refer to FIP-1, our basic token generation contract. The FIP-1 contract implements the following functions: totalSupply() : UInt256 gets the total token supply. balanceOf(owner: Address): UInt256 gets the balance of an account having address owner . transfer(to: Address, value: UInt256) : Bool sends value amount of tokens to address to .","title":"Requirements"},{"location":"tutorials/python-deployment/#deploying-the-contract","text":"We're going to create a new script, let's call it deploy.py","title":"Deploying the contract:"},{"location":"tutorials/python-deployment/#import","text":"Let's get the initial things out of the way, let's import: from fetchai.ledger.api import LedgerApi , TokenApi from fetchai.ledger.contract import Contract from fetchai.ledger.crypto import Entity , Address from contextlib import contextmanager","title":"Import"},{"location":"tutorials/python-deployment/#connect-to-network","text":"Then, connect to a local running node: api = None if api is None : api = LedgerApi ( host = \"127.0.0.1\" , port = 8000 )","title":"Connect to network"},{"location":"tutorials/python-deployment/#setup-accounts","text":"Now, we'll read in our etch contract, and create a couple of entities to test with: with open ( 'contract.txt' , 'r' ) as ct : contract_text = ct . read () print ( contract_text ) # create our first private key pair entity1 = Entity () address1 = Address ( entity1 ) # create a second private key pair entity2 = Entity () address2 = Address ( entity2 )","title":"Setup accounts"},{"location":"tutorials/python-deployment/#create-balance","text":"To test, we need a balance: api . sync ( api . tokens . wealth ( entity1 , 10000 )) (Note this will functionality will be removed and a faucet will take it's place).","title":"Create balance"},{"location":"tutorials/python-deployment/#create-the-smart-contract-object","text":"We create the contract object, and deploy it: contract = Contract ( contract_text , entity1 ) api . sync ( contract . create ( api , entity1 , 4000 ))","title":"Create the smart contract object"},{"location":"tutorials/python-deployment/#query-the-contract","text":"The named argument has to be the exact name of the variable we're accessing in balanceOf for example, if the state had a named var of \"userX\" the below code would be: print (contract.query(api, 'balanceOf', userX=address1)) this is an important note for other functions you might create. print ( contract . query ( api , 'totalSupply' )) print ( contract . query ( api , 'balanceOf' , address = address1 ))","title":"Query the contract"},{"location":"tutorials/python-deployment/#make-a-transaction","text":"Using the two entities we created earlier, and their addressed we transact 200 from entity1 to entity2, then check the balance: # transfer from one to the other using our newly deployed contract tok_transfer_amount = 200 fet_tx_fee = 160 api . sync ( contract . action ( api , 'transfer' , fet_tx_fee , [ entity1 ], address1 , address2 , tok_transfer_amount )) #Query new balance: print ( contract . query ( api , 'balanceOf' , address = address1 )) You can find the source here .","title":"Make a transaction"}]}